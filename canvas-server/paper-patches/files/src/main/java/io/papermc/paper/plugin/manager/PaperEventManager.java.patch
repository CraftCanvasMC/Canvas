--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -4,6 +_,7 @@
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
+import io.canvasmc.canvas.Config;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -24,6 +_,8 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 
 class PaperEventManager {
@@ -35,12 +_,57 @@
     }
 
     // SimplePluginManager
+    // Canvas start
+    private final ReentrantLock lock = new ReentrantLock();
+    private final Condition eventFinished = lock.newCondition();
+    private boolean callingSingleThreadEvent = false;
+
     public void callEvent(@NotNull Event event) {
-        if (event.isAsynchronous() && this.server.isPrimaryThread()) {
+        if (Config.INSTANCE.pluginCompatibilityMode && !event.isAsynchronous()) {
+            if (!event.getHandlers().hasRegisteredListeners()) {
+                return;
+            }
+
+            lock.lock();
+            try {
+                while (callingSingleThreadEvent) {
+                    try {
+                        eventFinished.await();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                        return;
+                    }
+                }
+
+                callingSingleThreadEvent = true;
+            } finally {
+                lock.unlock();
+            }
+
+            try {
+                callEventInternal(event);
+            } finally {
+                lock.lock();
+                try {
+                    callingSingleThreadEvent = false;
+                    eventFinished.signalAll();
+                } finally {
+                    lock.unlock();
+                }
+            }
+            return;
+        }
+
+        callEventInternal(event);
+    }
+
+    public void callEventInternal(@NotNull Event event) {
+        /* if (event.isAsynchronous() && this.server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
         } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
-        }
+        } */
+    // Canvas end
 
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
