From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Sun, 26 Jan 2025 11:45:33 -0800
Subject: [PATCH] Threaded Entity Scheduling


diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index bba8fe41cf1c5d8ba04c8b4d62504d24d6f55d14..e0033831b796b43f02b1467b404578add12f8079 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.entity.ThreadedEntityScheduler;
 import io.papermc.paper.FeatureHooks;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import java.lang.management.ManagementFactory;
@@ -63,6 +64,10 @@ public class WatchdogThread extends Thread {
     {
         level.lastWatchdogTick = WatchdogThread.monotonicMillis();
     }
+
+    public static void tickEntityThread(@NotNull ThreadedEntityScheduler entityScheduler) {
+        entityScheduler.lastWatchdogTick = WatchdogThread.monotonicMillis();
+    }
     // Canvas end
 
     public static void doStop() {
@@ -188,6 +193,13 @@ public class WatchdogThread extends Thread {
                     break;
                 }
             }
+            ThreadedEntityScheduler entityScheduler = MinecraftServer.getThreadedServer().entityScheduler;
+            if (checkEntityScheduler(entityScheduler, currentTime)) {
+                laggingConsume.accept(entityScheduler);
+                if (shouldBreak.get()) {
+                    break;
+                }
+            }
             for (ServerLevel level : server.getAllLevels()) {
                 if (checkLevelThread(level, currentTime)) {
                     laggingConsume.accept(level);
@@ -215,6 +227,9 @@ public class WatchdogThread extends Thread {
         return level.lastWatchdogTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!level.running || (currentTime > level.lastWatchdogTick + this.earlyWarningEvery && !DISABLE_WATCHDOG));
     }
 
+    private boolean checkEntityScheduler(@NotNull ThreadedEntityScheduler entityScheduler, long currentTime) {
+        return entityScheduler.lastWatchdogTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!entityScheduler.running || (currentTime > entityScheduler.lastWatchdogTick + this.earlyWarningEvery && !DISABLE_WATCHDOG));
+    }
     // Canvas end
     private static void dumpThread(ThreadInfo thread, Logger log) {
         log.log(Level.SEVERE, "------------------------------");
