--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -3,39 +_,40 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.entity.tracking.ThreadedTracker;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.Long2ByteMaps;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiFunction;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.IntConsumer;
@@ -54,7 +_,6 @@
 import net.minecraft.nbt.NbtException;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundChunksBiomesPacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
@@ -73,7 +_,6 @@
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
-import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.level.chunk.ProtoChunk;
@@ -84,16 +_,13 @@
 import net.minecraft.world.level.chunk.status.WorldGenContext;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
-import net.minecraft.world.level.chunk.storage.SerializableChunkData;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
 import net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator;
 import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
 import net.minecraft.world.level.levelgen.RandomState;
-import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.slf4j.Logger;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider, GeneratingChunkMap, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemChunkMap { // Paper - rewrite chunk system
@@ -120,7 +_,7 @@
     private final ChunkGeneratorStructureState chunkGeneratorState;
     private final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop = new LongOpenHashSet();
+    public final ConcurrentSet<Long> toDrop = new ConcurrentSet<>(); // Canvas
     private boolean modified;
     // Paper - rewrite chunk system
     public final ChunkProgressListener progressListener;
@@ -129,8 +_,10 @@
     public final AtomicInteger tickingGenerated = new AtomicInteger();  // Paper - public
     private final String storageName;
     private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
+    // Canvas start - synchronize
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>());
+    private final Long2ByteMap chunkTypeCache = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
+    // Canvas end
     // Paper - rewrite chunk system
     public int serverViewDistance;
     public final WorldGenContext worldGenContext; // Paper - public
@@ -212,7 +_,7 @@
         ConsecutiveExecutor consecutiveExecutor = new ConsecutiveExecutor(dispatcher, "worldgen");
         this.progressListener = progressListener;
         this.chunkStatusListener = chunkStatusListener;
-        ConsecutiveExecutor consecutiveExecutor1 = new ConsecutiveExecutor(dispatcher, "light");
+        ConsecutiveExecutor consecutiveExecutor1 = onLightExecutorInit(ConsecutiveExecutor::new);
         // Paper - rewrite chunk system
         this.lightEngine = new ThreadedLevelLightEngine(
             lightChunk, this, this.level.dimensionType().hasSkyLight(), consecutiveExecutor1, null // Paper - rewrite chunk system
@@ -231,6 +_,19 @@
         this.setServerViewDistance(viewDistance);
         this.worldGenContext = new WorldGenContext(level, generator, structureManager, this.lightEngine, null, this::setChunkUnsaved); // Paper - rewrite chunk system
     }
+    // Canvas start - threaded light engine
+    private ExecutorService lightThread = null;
+
+    private ConsecutiveExecutor onLightExecutorInit(BiFunction<Executor, String, ConsecutiveExecutor> original) {
+        lightThread = new ThreadPoolExecutor(
+            1, 1,
+            0, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactoryBuilder().setPriority(Thread.NORM_PRIORITY - 1).setDaemon(true).setNameFormat(String.format("%s - Light", level.dimension().location().toDebugFileName())).build()
+        );
+        return original.apply(lightThread, "light");
+    }
+    // Canvas end
 
     private void setChunkUnsaved(ChunkPos chunkPos) {
         // Paper - rewrite chunk system
@@ -251,7 +_,11 @@
 
         final ServerPlayer[] backingSet = inRange.getRawDataUnchecked();
         for (int i = 0, len = inRange.size(); i < len; i++) {
-            ++(backingSet[i].mobCounts[index]);
+            // Canvas start - caution ref lists
+            ServerPlayer player = backingSet[i];
+            if (player == null) continue;
+            ++(player.mobCounts[index]);
+            // Canvas end
         }
     }
 
@@ -268,7 +_,11 @@
         }
         final ServerPlayer[] backingSet = inRange.getRawDataUnchecked();
         for (int i = 0, len = inRange.size(); i < len; i++) {
-            ++(backingSet[i].mobBackoffCounts[idx]);
+            // Canvas start - caution ref lists
+            ServerPlayer player = backingSet[i];
+            if (player == null) continue;
+            ++(player.mobBackoffCounts[idx]);
+            // Canvas end
         }
     }
     // Paper end - per player mob count backoff
@@ -310,7 +_,7 @@
     }
 
     @Nullable
-    protected ChunkHolder getUpdatingChunkIfPresent(long chunkPos) {
+    public ChunkHolder getUpdatingChunkIfPresent(long chunkPos) { // Canvas - protected -> public
         // Paper start - rewrite chunk system
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
         return holder == null ? null : holder.vanillaChunkHolder;
@@ -409,12 +_,18 @@
         // Paper end - rewrite chunk system
     }
 
-    protected void tick(BooleanSupplier hasMoreTime) {
+    // Canvas start - allow autosave and unload on chunkloader
+    public void tick(BooleanSupplier hasMoreTime) {
+        this.tick(hasMoreTime, false);
+    }
+
+    public void tick(BooleanSupplier hasMoreTime, boolean overrideSave) { // protected -> public
+    // Canvas end
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("poi");
         this.poiManager.tick(hasMoreTime);
         profilerFiller.popPush("chunk_unload");
-        if (!this.level.noSave()) {
+        if (overrideSave || !this.level.noSave()) { // Canvas
             this.processUnloads(hasMoreTime);
         }
 
@@ -730,12 +_,13 @@
         final ServerPlayer[] raw = players.getRawDataUnchecked();
         final int len = players.size();
 
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
+        // Objects.checkFromIndexSize(0, len, raw.length); // Canvas - but why tho?
+        for (int i = 0; i < raw.length; ++i) { // Canvas
             final ServerPlayer serverPlayer = raw[i];
+            if (serverPlayer == null) continue; // Canvas - caution ref lists
             // Paper start - PlayerNaturallySpawnCreaturesEvent
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
-            blockRange = 16384.0D;
+            blockRange = Config.INSTANCE.playerNearChunkDetectionRange; // Canvas
             if (reducedRange) {
                 event = serverPlayer.playerNaturallySpawnedEvent;
                 if (event == null || event.isCancelled()) continue;
@@ -765,10 +_,11 @@
         final ServerPlayer[] raw = players.getRawDataUnchecked();
         final int len = players.size();
 
-        Objects.checkFromIndexSize(0, len, raw.length);
-        for (int i = 0; i < len; ++i) {
+        // Objects.checkFromIndexSize(0, len, raw.length); // Canvas - why do we do this??
+        for (int i = 0; i < raw.length; ++i) { // Canvas
             final ServerPlayer player = raw[i];
-            if (this.playerIsCloseEnoughForSpawning(player, chunkPos, 16384.0D)) { // Spigot
+            if (player == null) continue; // Canvas - caution ref lists
+            if (this.playerIsCloseEnoughForSpawning(player, chunkPos, Config.INSTANCE.playerNearChunkDetectionRange)) { // Spigot // Canvas
                 if (ret == null) {
                     ret = new ArrayList<>(len - i);
                     ret.add(player);
@@ -938,19 +_,27 @@
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
+        // Canvas start - threaded tracker
+        if (true) {
+            ThreadedTracker.INSTANCE.tick(level);
+            return;
+        }
+        // Canvas end
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = entityLookup.trackerEntities;
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) continue; // Canvas - caution ref lists
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkData().nearbyPlayers);
+            ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity cse =  ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity); ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(cse.moonrise$getChunkData() == null ? null : cse.moonrise$getChunkData().nearbyPlayers);
+            @Nullable FullChunkStatus chunkStatus = ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus(); // Canvas
             if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$hasPlayers()
-                || ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus().isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                || (chunkStatus != null && chunkStatus.isOrAfter(FullChunkStatus.ENTITY_TICKING))) { // Canvas
                 tracker.serverEntity.sendChanges();
             }
         }
@@ -1080,7 +_,7 @@
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        public final Set<ServerPlayerConnection> seenBy = Sets.newConcurrentHashSet(); // Paper - Perf: optimise map impl // Canvas - threaded tracker, and make this concurrent-compatible for threaded dimensions
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1110,6 +_,7 @@
 
             for (int i = 0, len = players.size(); i < len; ++i) {
                 final ServerPlayer player = playersRaw[i];
+                if (player == null) continue; // Canvas - caution ref lists
                 this.updatePlayer(player);
             }
 
