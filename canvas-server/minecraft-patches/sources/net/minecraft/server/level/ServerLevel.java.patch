--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -5,29 +_,42 @@
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.entity.tnt.TNTMergeManager;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.server.chunk.ChunkPriorityManager;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.QueuedTaskScheduler;
+import io.canvasmc.canvas.util.TPSCalculator;
+import io.canvasmc.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMaps;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
-import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -38,26 +_,33 @@
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
+import net.minecraft.core.RegistryAccess;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundExplodePacket;
-import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -65,6 +_,7 @@
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
@@ -76,9 +_,9 @@
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.Unit;
-import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -105,6 +_,7 @@
 import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
 import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.alchemy.PotionBrewing;
 import net.minecraft.world.item.crafting.RecipeManager;
 import net.minecraft.world.level.BlockEventData;
@@ -130,18 +_,14 @@
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
-import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
-import net.minecraft.world.level.chunk.storage.SimpleRegionStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
 import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -161,7 +_,6 @@
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.level.storage.ServerLevelData;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
@@ -179,12 +_,13 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = Lists.newCopyOnWriteArrayList(); // Canvas
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
+    public ItemStack ominousBanner; // Canvas
     private int lastSpawnChunkRadius;
-    final EntityTickList entityTickList = new EntityTickList();
+    public final EntityTickList entityTickList = new EntityTickList(); // Canvas
     // Paper - rewrite chunk system
     private final GameEventDispatcher gameEventDispatcher;
     public boolean noSave;
@@ -194,22 +_,23 @@
     private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
-    volatile boolean isUpdatingNavigations;
+    final Set<Mob> navigatingMobs = new ConcurrentSet<>(); // Canvas
+    final AtomicBoolean isUpdatingNavigations = new AtomicBoolean(false); // Canvas
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
+    private final List<BlockEventData> blockEvents = new CopyOnWriteArrayList<>(); // Canvas
+    private final Queue<BlockEventData> blockEventsToReschedule = new ConcurrentLinkedQueue<>(); // Canvas
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectConcurrentHashMap<>(); // Canvas
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private double preciseTime; // Purpur - Configurable daylight cycle
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
+    public final QueuedTaskScheduler taskScheduler = new QueuedTaskScheduler(); // Canvas
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess levelStorageAccess;
@@ -218,6 +_,11 @@
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
+    // Canvas start - Threaded Dimensions
+    private int emptyTicks;
+    private int sendAllPlayerInfoIn;
+    public TPSCalculator tpsCalculator = new TPSCalculator();
+    // Canvas end
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -344,6 +_,13 @@
     public final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler moonrise$getChunkTaskScheduler() {
         return this.chunkTaskScheduler;
     }
+    // Canvas start - optimize moonrise
+
+    private final ChunkPriorityManager priorityManager = new ChunkPriorityManager();
+    public ChunkPriorityManager getPriorityManager() {
+        return priorityManager;
+    }
+    // Canvas end
 
     @Override
     public final ca.spottedleaf.moonrise.patches.chunk_system.io.MoonriseRegionFileIO.RegionDataController  moonrise$getChunkDataController() {
@@ -499,7 +_,7 @@
     // Paper start - chunk tick iteration
     private static final ServerChunkCache.ChunkAndHolder[] EMPTY_PLAYER_CHUNK_HOLDERS = new ServerChunkCache.ChunkAndHolder[0];
     private final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_PLAYER_CHUNK_HOLDERS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+    private final it.unimi.dsi.fastutil.longs.Long2IntMap playerTickingRequests = Long2IntMaps.synchronize(new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap()); // Canvas
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> moonrise$getPlayerTickingChunks() {
@@ -527,7 +_,7 @@
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
 
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
+        if (this.playerTickingRequests.compute(chunkKey, (k, v) -> (v == null ? 0 : v) + 1) != 1) { // Canvas
             // already added
             return;
         }
@@ -549,7 +_,10 @@
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
+        // Canvas start
+        int val = this.playerTickingRequests.compute(chunkKey, (_, v) -> (v == null ? 0 : v) - 1);
+        val += 1;
+        // Canvas end
 
         if (val <= 0) {
             throw new IllegalStateException("Negative counter");
@@ -702,6 +_,16 @@
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
+        this.ominousBanner = Objects.requireNonNullElse(this.registryAccess(), RegistryAccess.EMPTY).lookup(Registries.BANNER_PATTERN).map(Raid::getOminousBannerInstance).orElse(null); // Canvas
+        // Canvas start
+        ServerChunkCache cmgr = getChunkSource();
+
+        int viewDistance = DistanceUtils.resolveViewDistance(this);
+        cmgr.setViewDistance(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this);
+        cmgr.setSimulationDistance(simulationDistance - 1);
+        // Canvas end
     }
 
     // Paper start
@@ -733,8 +_,148 @@
     public StructureManager structureManager() {
         return this.structureManager;
     }
-
-    public void tick(BooleanSupplier hasTimeLeft) {
+    // Canvas start - Multithreaded Dimension Ticking
+    private final List<Connection> activeConnections = new ObjectArrayList<>();
+    private final Object lock = new Object();
+
+    private int ticksSinceLastBlockEventsTickCall = 0;
+    private int ticksSinceLastRaidTickCall = 0;
+    private int ticksSinceLastTickCustomSpawnersCall = 0;
+
+    public void notifyNewConnection(Connection connection) {
+        synchronized (lock) {
+            activeConnections.add(connection);
+        }
+    }
+    public void removeConnection(Connection connection) {
+        synchronized (lock)  {
+            activeConnections.remove(connection);
+        }
+    }
+
+    private boolean tickEmptyLevel() {
+        if (this.server.isEmptyTickSkipping()) {
+            return true;
+        }
+        int serverEmptySecondsLimit = this.server.pauseWhileEmptySeconds() * 20;
+        if (serverEmptySecondsLimit > 0 && Config.INSTANCE.emptySleepPerWorlds) {
+            if (this.players.isEmpty() && !this.tickRateManager.isSprinting() && this.server.pluginsBlockingSleep.isEmpty()) {
+                ++this.emptyTicks;
+            } else {
+                this.emptyTicks = 0;
+            }
+
+            if (this.emptyTicks >= serverEmptySecondsLimit) {
+                if (this.emptyTicks == serverEmptySecondsLimit) {
+                    MinecraftServer.LOGGER.info("Level empty for {} seconds, pausing", this.server.pauseWhileEmptySeconds());
+                }
+                this.bukkitScheduler.mainThreadHeartbeat();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    protected void tickConnection() {
+        for (ServerPlayer player : this.players) {
+            player.connection.suspendFlushing();
+        }
+        Iterator<Connection> iterator = this.activeConnections.iterator();
+        while (iterator.hasNext()) {
+            Connection networkmanager = iterator.next();
+
+            if (!networkmanager.isConnecting()) {
+                if (networkmanager.isConnected()) {
+                    try {
+                        networkmanager.tick();
+                    } catch (Exception exception) {
+                        if (networkmanager.isMemoryConnection()) {
+                            throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                        }
+
+                        LOGGER.warn("Failed to handle packet for {}", networkmanager.getLoggableAddress(this.server.logIPs()), exception);
+                        MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                        networkmanager.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                            networkmanager.disconnect(ichatmutablecomponent);
+                        }));
+                        networkmanager.setReadOnly();
+                    }
+                } else {
+                    if (networkmanager.preparing) continue;
+                    iterator.remove();
+                    networkmanager.handleDisconnection();
+                }
+            }
+        }
+    }
+
+    public void syncTimeToPlayers() {
+        ClientboundSetTimePacket timePacket = new ClientboundSetTimePacket(getGameTime(), getDayTime(), getGameRules().getBoolean(GameRules.RULE_DAYLIGHT));
+        for (final ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.connection.send(timePacket);
+            }
+        }
+    }
+
+    public void squeezeTasks() {
+        // this.runAllTasks();
+    }
+
+    public void tickPlayerList() {
+        if (!Config.INSTANCE.runPlayerListTickOnIndependentLevel) return;
+        if (++this.sendAllPlayerInfoIn > 600) {
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = this.players.get(i);
+
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.getServer().getPlayerList().
+                    players.stream().filter(input -> target.getBukkitEntity().canSee(input.getBukkitEntity())).collect(Collectors.toList())));
+            }
+            this.sendAllPlayerInfoIn = 0;
+        }
+
+    }
+
+    public void tick(BooleanSupplier hasTimeLeft, int tickCount) {
+        this.tickRateManager.tick();
+        this.tickConnection();
+
+        if (this.tickEmptyLevel()) {
+            return;
+        }
+        this.tpsCalculator.doTick();
+        // Mark handling tick AFTER ticking empty level check
+        this.handlingTick = true;
+        this.bukkitScheduler.mainThreadHeartbeat();
+
+        for (final Entity entity : this.getEntities().getAll()) {
+            if (entity.isRemoved()) {
+                continue;
+            }
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        chunkSource.tick(() -> true, false);
+
+        if (this.tickCount % Config.INSTANCE.timeResyncInterval == 0) {
+            // Resync time every configurable amount of ticks
+            syncTimeToPlayers();
+        }
+
+        hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+        hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        // net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+        updateLagCompensationTick();
+        hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        Queue<Runnable> copyOf = new ConcurrentLinkedQueue<>(this.queuedForNextTickPre);
+        this.queuedForNextTickPre.clear();
+        for (final Runnable runnable : copyOf) {
+            runnable.run();
+        }
+    // Canvas end
         ProfilerFiller profilerFiller = Profiler.get();
         this.handlingTick = true;
         TickRateManager tickRateManager = this.tickRateManager();
@@ -778,26 +_,46 @@
             this.tickTime();
         }
 
+        this.squeezeTasks(); // Canvas
         profilerFiller.push("tickPending");
         if (!this.isDebug() && runsNormally) {
             long l = this.getGameTime();
+            // Canvas start
+            if (this.blockTicks.ticksSinceLastBlockTickCall++ > Config.INSTANCE.ticksBetweenBlockTicking) {
             profilerFiller.push("blockTicks");
             this.blockTicks.tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
+                this.blockTicks.ticksSinceLastBlockTickCall = 0;
+            }
+            if (this.fluidTicks.ticksSinceLastFluidTickCall++ > Config.INSTANCE.ticksBetweenFluidTicking) {
             profilerFiller.popPush("fluidTicks");
             this.fluidTicks.tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks
+                this.fluidTicks.ticksSinceLastFluidTickCall = 0;
+            }
+            // Canvas end
             profilerFiller.pop();
         }
 
         profilerFiller.popPush("raid");
         if (runsNormally) {
+            // Canvas start
+            if (this.ticksSinceLastRaidTickCall++ > Config.INSTANCE.ticksBetweenRaidTicking) {
             this.raids.tick();
+                this.ticksSinceLastRaidTickCall = 0;
+            }
+            // Canvas end
         }
 
         profilerFiller.popPush("chunkSource");
         this.getChunkSource().tick(hasTimeLeft, true);
+        this.squeezeTasks(); // Canvas
         profilerFiller.popPush("blockEvents");
         if (runsNormally) {
+            // Canvas start
+            if (this.ticksSinceLastBlockEventsTickCall++ > Config.INSTANCE.ticksBetweenBlockEvents) {
             this.runBlockEvents();
+                this.ticksSinceLastBlockEventsTickCall = 0;
+            }
+            // Canvas end
         }
 
         this.handlingTick = false;
@@ -816,9 +_,15 @@
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
-                    entity -> {
+            /* // Canvas start // - threaded entity ticking
+            for (final Entity entity : this.entityTickList.entities) {
+                if (Config.shouldCheckMasks && Config.COMPILED_LOCATIONS.contains(entity.getTypeLocation())) {
+                    int lived = entity.tickCount;
+                    if (!entity.getMask().shouldTick || lived % entity.getMask().tickRate != 0) {
+                        continue;
+                    }
+                }
+            // Canvas end
                         if (!entity.isRemoved()) {
                             if (!tickRateManager.isEntityFrozen(entity)) {
                                 profilerFiller.push("checkDespawn");
@@ -841,21 +_,83 @@
                             }
                         }
                     }
-                );
+            */ // Canvas // - threaded entity ticking
+            this.tickEntities(false); // Canvas - threaded entity ticking
             profilerFiller.pop();
-            this.tickBlockEntities();
+            this.tickBlockEntities(profilerFiller);
         }
 
         profilerFiller.push("entityManagement");
         // Paper - rewrite chunk system
         profilerFiller.pop();
-    }
+        // Canvas start - Threaded Dimensions
+        copyOf = new ConcurrentLinkedQueue<>(this.queuedForNextTickPost);
+        this.queuedForNextTickPost.clear();
+        for (final Runnable runnable : copyOf) {
+            runnable.run();
+        }
+        tickPlayerList();
+        for (ServerPlayer player : this.players) {
+            player.connection.chunkSender.sendNextChunks(player);
+            player.connection.resumeFlushing();
+        }
+        explosionDensityCache.clear();
+        this.runAllTasks();
+        // Canvas end
+    }
+    // Canvas start - threaded entity ticking
+
+    public void tickEntities(boolean isThreaded) {
+        if (Config.INSTANCE.threadedEntityTicking && !isThreaded) {
+            for (final ServerPlayer player : this.players) {
+                entityTick(player);
+            }
+            return;
+        }
+        this.entityTickList.forEach((entity) -> {
+            if (isThreaded && entity instanceof ServerPlayer) return; // Dont tick players threaded, that's still on Level.
+            if (Config.CHECK_ENTITY_MASKS && Config.COMPILED_ENTITY_MASK_LOCATIONS.contains(entity.getTypeLocation())) {
+                int lived = entity.tickCount;
+                if (!entity.getMask().shouldTick || lived % entity.getMask().tickRate != 0) {
+                    entity.tickCount++; // Increment this still, since if we don't, this entity will never tick again(if its run on delay)
+                    return;
+                }
+            }
+            entityTick(entity);
+        });
+    }
+
+    private void entityTick(Entity entity) {
+        if (!entity.isRemoved()) {
+            if (!tickRateManager.isEntityFrozen(entity)) {
+                entity.checkDespawn();
+                Entity vehicle = entity.getVehicle();
+                if (vehicle != null) {
+                    if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
+                        return;
+                    }
+
+                    entity.stopRiding();
+                }
+
+                try {
+                    this.tickNonPassenger(entity);
+                } catch (Throwable var6) {
+                    final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+                    MinecraftServer.LOGGER.error(msg, var6);
+                    getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, var6)));
+                    entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+                }
+                this.moonrise$midTickTasks();
+            }
+        }
+    }
+    // Canvas end
 
     @Override
     public boolean shouldTickBlocksAt(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        return holder != null && holder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -874,10 +_,17 @@
                     this.setDayTime(this.preciseTime);
                 } else
                 // Purpur end - Configurable daylight cycle
-                this.setDayTime(this.levelData.getDayTime() + 1L);
+                this.setDayTime(lagCompensation(this.levelData.getDayTime()) + 1L); // Canvas
             }
         }
     }
+    // Canvas start
+
+    private long lagCompensation(long original) {
+        if (!Config.INSTANCE.lagCompensation.enabled || !Config.INSTANCE.lagCompensation.timeAcceleration) return original;
+        return original + this.tpsCalculator.applicableMissedTicks();
+    }
+    // Canvas end
 
     public void setDayTime(long time) {
         this.serverLevelData.setDayTime(time);
@@ -898,14 +_,20 @@
     // Purpur end - Configurable daylight cycle
 
     public void tickCustomSpawners(boolean spawnEnemies, boolean spawnFriendlies) {
+        // Canvas start
+        if (this.ticksSinceLastTickCustomSpawnersCall++ > Config.INSTANCE.ticksBetweenCustomSpawnersTick) {
         for (CustomSpawner customSpawner : this.customSpawners) {
             customSpawner.tick(this, spawnEnemies, spawnFriendlies);
         }
+        this.ticksSinceLastTickCustomSpawnersCall = 0;
+        }
+        // Canvas end
     }
 
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
         this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> player.stopSleepInBed(false, false));
+        this.server.forceTimeSynchronization(); // Canvas
     }
 
     // Paper start - optimise random ticking
@@ -1006,15 +_,23 @@
         profilerFiller.popPush("iceandsnow");
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
+            // Canvas start - precipitation intervals
+            if (chunk.ticksSinceLastPrecipitationCall++ > Config.INSTANCE.ticksBetweenPrecipitationUpdates) {
+                chunk.ticksSinceLastPrecipitationCall = 0;
+            // Canvas end
         for (int i = 0; i < randomTickSpeed; i++) {
             if (simpleRandom.nextInt(48) == 0) {  // Paper - optimise random ticking
                 this.tickPrecipitation(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             }
         }
+            } // Canvas
         } // Paper - Option to disable ice and snow
 
         profilerFiller.popPush("tickBlocks");
-        if (randomTickSpeed > 0) {
+        // Canvas start - random tick intervals
+        if (chunk.ticksSinceLastRandomTickCall++ > Config.INSTANCE.ticksBetweenRandomTickUpdates && randomTickSpeed > 0) {
+            chunk.ticksSinceLastRandomTickCall = 0;
+        // Canvas end
             this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
         }
 
@@ -1150,6 +_,11 @@
     }
 
     private void advanceWeatherCycle() {
+        // Canvas start
+        if (Config.INSTANCE.disableWeatherCycle) {
+            return;
+        }
+        // Canvas end
         boolean isRaining = this.isRaining();
         if (this.dimensionType().hasSkyLight()) {
             if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE)) {
@@ -1284,7 +_,15 @@
     }
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
-        BlockState blockState = this.getBlockState(pos);
+        // Canvas start
+        int x = SectionPos.blockToSectionCoord(pos.getX());
+        int z = SectionPos.blockToSectionCoord(pos.getZ());
+        LevelChunk chunk = this.chunkSource.getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) {
+            return;
+        }
+        BlockState blockState = chunk.getBlockState(pos);
+        // Canvas end
         FluidState fluidState = blockState.getFluidState();
         if (fluidState.is(fluid)) {
             fluidState.tick(this, pos, blockState);
@@ -1298,7 +_,15 @@
     }
 
     private void tickBlock(BlockPos pos, Block block) {
-        BlockState blockState = this.getBlockState(pos);
+        // Canvas start
+        int x = SectionPos.blockToSectionCoord(pos.getX());
+        int z = SectionPos.blockToSectionCoord(pos.getZ());
+        LevelChunk chunk = this.chunkSource.getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) {
+            return;
+        }
+        BlockState blockState = chunk.getBlockState(pos);
+        // Canvas end
         if (blockState.is(block)) {
             blockState.tick(this, pos, this.random);
         }
@@ -1312,24 +_,25 @@
 
     // Paper start - log detailed entity tick information
     // TODO replace with varhandle
-    static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
+    // Canvas start
+    /* static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
 
     public static List<Entity> getCurrentlyTickingEntities() {
         Entity ticking = currentlyTickingEntity.get();
         List<Entity> ret = java.util.Arrays.asList(ticking == null ? new Entity[0] : new Entity[] { ticking });
 
         return ret;
-    }
+    } */ // Canvas end
     // Paper end - log detailed entity tick information
 
     public void tickNonPassenger(Entity entity) {
-        // Paper start - log detailed entity tick information
+        /* // Paper start - log detailed entity tick information // Canvas start
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
         try {
             if (currentlyTickingEntity.get() == null) {
                 currentlyTickingEntity.lazySet(entity);
             }
-            // Paper end - log detailed entity tick information
+            // Paper end - log detailed entity tick information */ // Canvas end
         entity.setOldPosAndRot();
         ProfilerFiller profilerFiller = Profiler.get();
         entity.tickCount++;
@@ -1347,11 +_,11 @@
             this.tickPassenger(entity, entity1, isActive); // Paper - EAR 2
         }
         // Paper start - log detailed entity tick information
-        } finally {
+        /* } finally { // Canvas start
             if (currentlyTickingEntity.get() == entity) {
                 currentlyTickingEntity.lazySet(null);
             }
-        }
+        } */ // Canvas end
         // Paper end - log detailed entity tick information
     }
 
@@ -1485,6 +_,7 @@
 
             return AbortableIterationConsumer.Continuation.CONTINUE;
         });
+        this.syncTimeToPlayers(); // Canvas - ensure time resync
     }
 
     public List<? extends EnderDragon> getDragons() {
@@ -1611,7 +_,7 @@
         return this.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
     }
 
-    public boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+    public synchronized boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) { // Canvas - synchronize
         // CraftBukkit end
         if (entity.getSelfAndPassengers().map(Entity::getUUID).anyMatch(this.moonrise$getEntityLookup()::hasEntity)) { // Paper - rewrite chunk system
             return false;
@@ -1764,10 +_,36 @@
         // Paper end - Prevent GameEvents being fired from unloaded chunks
         this.gameEventDispatcher.post(gameEvent, pos, context);
     }
+    // Canvas start
+    private final Set<PathNavigation> activeNavigations = new ConcurrentSet<>();
+
+    private Iterator<Mob> getActiveListeners(Set<Mob> set) {
+        return Collections.emptyIterator();
+    }
+
+    public void lithium$setNavigationActive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.add((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    public void lithium$setNavigationInactive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.remove((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    private void updateActiveListeners(BlockPos pos, List<PathNavigation> list) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        for (PathNavigation entityNavigation : activeNavigations) {
+            if (entityNavigation.shouldRecomputePath(pos)) {
+                list.add(entityNavigation);
+            }
+        }
+    }
+    // Canvas end
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get() && false) { // Canvas
             String string = "recursive call to sendBlockUpdated";
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
@@ -1781,7 +_,13 @@
             List<PathNavigation> list = new ObjectArrayList<>();
 
             try { // Paper - catch CME see below why
-            for (Mob mob : this.navigatingMobs) {
+                // Canvas start
+                Iterator<Mob> iterator = getActiveListeners(this.navigatingMobs);
+                updateActiveListeners(pos, list);
+
+                while (iterator.hasNext()) {
+                    Mob mob = iterator.next();
+                // Canvas end
                 PathNavigation navigation = mob.getNavigation();
                 if (navigation.shouldRecomputePath(pos)) {
                     list.add(navigation);
@@ -1798,13 +_,13 @@
             // Paper end - catch CME see below why
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // Canvas
 
                 for (PathNavigation pathNavigation : list) {
                     pathNavigation.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // Canvas
             }
         }
         } // Paper - option to disable pathfinding updates
@@ -1812,13 +_,13 @@
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - atomic
         this.updateNeighborsAt(pos, block, ExperimentalRedstoneUtils.initialOrientation(this, null, null));
     }
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - atomic
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation);
     }
 
@@ -2159,8 +_,8 @@
     }
 
     @Override
-    public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+    public ServerTickRateManager tickRateManager() { // Canvas
+        return this.tickRateManager; // Canvas
     }
 
     @Override
@@ -2420,7 +_,7 @@
         CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
 
         for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
-            BlockPos pos = tickingBlockEntity.getPos();
+            BlockPos pos = getPosOrOrigin(tickingBlockEntity); // Canvas
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
     }
@@ -2474,6 +_,16 @@
     public ServerLevel getLevel() {
         return this;
     }
+    // Canvas start
+
+    private BlockPos getPosOrOrigin(TickingBlockEntity instance) {
+        BlockPos pos = instance.getPos();
+        if (pos == null) {
+            return BlockPos.ZERO;
+        }
+        return pos;
+    }
+    // Canvas end
 
     @VisibleForTesting
     public String getWatchdogStats() {
@@ -2540,7 +_,7 @@
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
+        ((BlockableEventLoop<?>) (MinecraftServer.getThreadedServer().hasStarted() ? this : this.server)).execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
     }
 
     public PathTypeCache getPathTypeCache() {
@@ -2548,7 +_,7 @@
     }
 
     @Override
-    public void close() throws IOException {
+    public void close() { // Canvas
         super.close();
         // Paper - rewrite chunk system
     }
@@ -2564,9 +_,7 @@
 
     private boolean isPositionTickingWithEntitiesLoaded(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        // isTicking implies the chunk is loaded, and the chunk is loaded now implies the entities are loaded
-        return chunkHolder != null && chunkHolder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -2579,15 +_,13 @@
 
     public boolean isNaturalSpawningAllowed(BlockPos pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(ChunkPos chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -2659,6 +_,35 @@
     // Paper end - optimize redstone (Alternate Current)
 
     final class EntityCallbacks implements LevelCallback<Entity> {
+        // Canvas start
+        private ServerLevel outer;
+
+        EntityCallbacks() {
+            this.outer = ServerLevel.this;
+        }
+
+        private boolean startListeningOnEntityLoad(Set<Mob> set, Object mobEntityObj) {
+            Mob mobEntity = (Mob) mobEntityObj;
+            PathNavigation navigation = mobEntity.getNavigation();
+            (mobEntity).lithium$setRegisteredToWorld(navigation);
+            if (navigation.getPath() != null) {
+                (this.outer).lithium$setNavigationActive(mobEntity);
+            }
+            return set.add(mobEntity);
+        }
+
+        private boolean stopListeningOnEntityUnload(Set<Mob> set, Object mobEntityObj) {
+            Mob mobEntity = (Mob) mobEntityObj;
+            if ((mobEntity).lithium$isRegisteredToWorld()) {
+                PathNavigation registeredNavigation = ((Mob) mobEntity).lithium$getRegisteredNavigation();
+                if (registeredNavigation.getPath() != null) {
+                    (this.outer).lithium$setNavigationInactive(mobEntity);
+                }
+                (mobEntity).lithium$setRegisteredToWorld(null);
+            }
+            return set.remove(mobEntity);
+        }
+        // Canvas end
         @Override
         public void onCreated(Entity entity) {
         }
@@ -2686,7 +_,8 @@
         }
 
         @Override
-        public void onTrackingStart(Entity entity) {
+        public synchronized void onTrackingStart(Entity entity) { // Canvas - synchronize
+            TNTMergeManager.onEntityLoad(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
@@ -2695,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.add(mob);
+                startListeningOnEntityLoad(this.outer.navigatingMobs, mob); // Canvas
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2729,6 +_,7 @@
 
         @Override
         public void onTrackingEnd(Entity entity) {
+            TNTMergeManager.onEntityUnload(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
             // Spigot start // TODO I don't think this is needed anymore
             if (entity instanceof Player player) {
@@ -2765,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.remove(mob);
+                stopListeningOnEntityUnload(this.outer.navigatingMobs, mob); // Canvas
             }
 
             if (entity instanceof EnderDragon enderDragon) {
