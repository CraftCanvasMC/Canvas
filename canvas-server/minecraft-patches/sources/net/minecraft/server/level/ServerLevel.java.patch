--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1,12 +_,24 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.entity.tnt.TNTMergeManager;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.scheduler.CanvasPerWorldScheduler;
+import io.canvasmc.canvas.server.chunk.ChunkPriorityManager;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.SimpleThreadLocalRandomSource;
+import io.canvasmc.canvas.util.TPSCalculator;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMaps;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -19,15 +_,22 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -35,29 +_,38 @@
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import it.unimi.dsi.fastutil.objects.ObjectSets;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
+import net.minecraft.core.RegistryAccess;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundExplodePacket;
-import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -65,6 +_,7 @@
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
@@ -79,6 +_,7 @@
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -105,6 +_,7 @@
 import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
 import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.alchemy.PotionBrewing;
 import net.minecraft.world.item.crafting.RecipeManager;
 import net.minecraft.world.level.BlockEventData;
@@ -123,6 +_,7 @@
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.SnowLayerBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.FuelValues;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
@@ -168,6 +_,7 @@
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
+import org.agrona.collections.ObjectHashSet;
 import org.slf4j.Logger;
 
 public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevelReader, ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickServerLevel { // Paper - rewrite chunk system // Paper - chunk tick iteration
@@ -179,12 +_,25 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    // Canvas start - use concurrent - add empty world sleeping
+    final List<ServerPlayer> players = new CopyOnWriteArrayList<>() {
+        @Override
+        public boolean add(final ServerPlayer player) {
+            if (ServerLevel.this.isSleeping()) {
+                ServerLevel.this.wake();
+            }
+            return super.add(player);
+        }
+    };
+    // Canvas end
     public final ServerChunkCache chunkSource;
-    private final MinecraftServer server;
+    // private final MinecraftServer server; // Canvas - clashes with super
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
+    public final ChunkHolderManager.LevelHolderData chunkHolderData; // Canvas
+    public ItemStack ominousBanner; // Canvas
+    public ChunkPos randomSpawnSelection; // Canvas
     private int lastSpawnChunkRadius;
-    final EntityTickList entityTickList = new EntityTickList();
+    public final EntityTickList entityTickList = new EntityTickList(); // Canvas
     // Paper - rewrite chunk system
     private final GameEventDispatcher gameEventDispatcher;
     public boolean noSave;
@@ -194,16 +_,16 @@
     private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
-    volatile boolean isUpdatingNavigations;
+    final Set<Mob> navigatingMobs = Sets.newConcurrentHashSet(); // Canvas
+    final AtomicBoolean isUpdatingNavigations = new AtomicBoolean(false); // Canvas
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
+    private final List<BlockEventData> blockEvents = new CopyOnWriteArrayList<>(); // Canvas
+    private final Queue<BlockEventData> blockEventsToReschedule = new ConcurrentLinkedQueue<>(); // Canvas
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<EnderDragonPart> dragonParts = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap<>()); // Canvas - synchronize
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
@@ -218,6 +_,22 @@
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
+    // Canvas start - Threaded Dimensions
+    // we add a lock on entity callbacks because plugins,
+    // commands, etc, can execute on any thread.
+    // because of this, the entity lookup updates are no
+    // longer stable or safe. to combat this, we add
+    // a lock on entity move/remove/add per level
+    // which essentially makes it so that only 1
+    // entity per level can be moved/removed/added
+    // at a time. while this is ungodly stupid, this
+    // is the only way to do this reliably, given that
+    // we can't lock per chunk(if the entity is moving
+    // into a new chunk, then it won't lock on the new chunk)
+    public final Object entityLevelCallbackLock = new Object();
+    private int sendAllPlayerInfoIn;
+    public TPSCalculator tpsCalculator = new TPSCalculator();
+    // Canvas end
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -344,6 +_,13 @@
     public final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler moonrise$getChunkTaskScheduler() {
         return this.chunkTaskScheduler;
     }
+    // Canvas start - optimize moonrise
+
+    private final ChunkPriorityManager priorityManager = new ChunkPriorityManager(this);
+    public ChunkPriorityManager getPriorityManager() {
+        return priorityManager;
+    }
+    // Canvas end
 
     @Override
     public final ca.spottedleaf.moonrise.patches.chunk_system.io.MoonriseRegionFileIO.RegionDataController  moonrise$getChunkDataController() {
@@ -499,7 +_,7 @@
     // Paper start - chunk tick iteration
     private static final ServerChunkCache.ChunkAndHolder[] EMPTY_PLAYER_CHUNK_HOLDERS = new ServerChunkCache.ChunkAndHolder[0];
     private final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> playerTickingChunks = new ca.spottedleaf.moonrise.common.list.ReferenceList<>(EMPTY_PLAYER_CHUNK_HOLDERS);
-    private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap playerTickingRequests = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+    private final it.unimi.dsi.fastutil.longs.Long2IntMap playerTickingRequests = Long2IntMaps.synchronize(new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap()); // Canvas
 
     @Override
     public final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.server.level.ServerChunkCache.ChunkAndHolder> moonrise$getPlayerTickingChunks() {
@@ -527,7 +_,7 @@
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
 
-        if (this.playerTickingRequests.addTo(chunkKey, 1) != 0) {
+        if (this.playerTickingRequests.compute(chunkKey, (k, v) -> (v == null ? 0 : v) + 1) != 1) { // Canvas
             // already added
             return;
         }
@@ -549,7 +_,10 @@
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)(Object)this, chunkX, chunkZ, "Cannot remove ticking request async");
 
         final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ);
-        final int val = this.playerTickingRequests.addTo(chunkKey, -1);
+        // Canvas start
+        int val = this.playerTickingRequests.compute(chunkKey, (_, v) -> (v == null ? 0 : v) - 1);
+        val += 1;
+        // Canvas end
 
         if (val <= 0) {
             throw new IllegalStateException("Negative counter");
@@ -597,7 +_,7 @@
         this.uuid = org.bukkit.craftbukkit.util.WorldUUID.getUUID(levelStorageAccess.levelDirectory.path().toFile());
         // CraftBukkit end
         this.tickTime = tickTime;
-        this.server = server;
+        // this.server = server; // Canvas - clashes with super
         // Purpur start - Allow toggling special MobSpawners per world
         this.customSpawners = new ArrayList<>();
         if (purpurConfig.phantomSpawning) {
@@ -689,6 +_,7 @@
         // Paper start - rewrite chunk system
         this.moonrise$setEntityLookup(new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup((ServerLevel)(Object)this, ((ServerLevel)(Object)this).new EntityCallbacks()));
         this.chunkTaskScheduler = new ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler((ServerLevel)(Object)this);
+        this.chunkHolderData = new ChunkHolderManager.LevelHolderData();
         this.entityDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.EntityDataController(
             new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.EntityDataController.EntityRegionFileStorage(
                 new RegionStorageInfo(levelStorageAccess.getLevelId(), dimension, "entities"),
@@ -702,6 +_,16 @@
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
+        this.ominousBanner = Objects.requireNonNullElse(this.registryAccess(), RegistryAccess.EMPTY).lookup(Registries.BANNER_PATTERN).map(Raid::getOminousBannerInstance).orElse(null); // Canvas
+        // Canvas start
+        ServerChunkCache cmgr = getChunkSource();
+
+        int viewDistance = DistanceUtils.resolveViewDistance(this);
+        cmgr.setViewDistance(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this);
+        cmgr.setSimulationDistance(simulationDistance - 1);
+        // Canvas end
     }
 
     // Paper start
@@ -733,8 +_,117 @@
     public StructureManager structureManager() {
         return this.structureManager;
     }
-
-    public void tick(BooleanSupplier hasTimeLeft) {
+    // Canvas start - Multithreaded Dimension Ticking
+    private final List<Connection> activeConnections = new ObjectArrayList<>();
+    private final Object lock = new Object();
+
+    private int ticksSinceLastBlockEventsTickCall = 0;
+    private int ticksSinceLastRaidTickCall = 0;
+    private int ticksSinceLastTickCustomSpawnersCall = 0;
+
+    public static final int WORLD_INIT_NOT_CHECKED = 0;
+    public static final int WORLD_INIT_CHECKING = 1;
+    public static final int WORLD_INIT_CHECKED = 2;
+
+    public void notifyNewConnection(Connection connection) {
+        synchronized (lock) {
+            activeConnections.add(connection);
+        }
+    }
+    public void removeConnection(Connection connection) {
+        synchronized (lock)  {
+            activeConnections.remove(connection);
+        }
+    }
+
+    protected void tickConnection() {
+        for (ServerPlayer player : this.players) {
+            player.connection.suspendFlushing();
+        }
+        Iterator<Connection> iterator = this.activeConnections.iterator();
+        while (iterator.hasNext()) {
+            Connection networkmanager = iterator.next();
+
+            if (!networkmanager.isConnecting()) {
+                if (networkmanager.isConnected()) {
+                    try {
+                        networkmanager.tick();
+                    } catch (Exception exception) {
+                        if (networkmanager.isMemoryConnection()) {
+                            throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                        }
+
+                        LOGGER.warn("Failed to handle packet for {}", networkmanager.getLoggableAddress(this.server.logIPs()), exception);
+                        MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                        networkmanager.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                            networkmanager.disconnect(ichatmutablecomponent);
+                        }));
+                        networkmanager.setReadOnly();
+                    }
+                } else {
+                    if (networkmanager.preparing) continue;
+                    iterator.remove();
+                    networkmanager.handleDisconnection();
+                }
+            }
+        }
+    }
+
+    public void syncTimeToPlayers() {
+        ClientboundSetTimePacket timePacket = new ClientboundSetTimePacket(getGameTime(), getDayTime(), getGameRules().getBoolean(GameRules.RULE_DAYLIGHT));
+        for (final ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.connection.send(timePacket);
+            }
+        }
+    }
+
+    public void tickPlayerList() {
+        if (++this.sendAllPlayerInfoIn > 600) {
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = this.players.get(i);
+
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.getServer().getPlayerList().
+                    players.stream().filter(input -> target.getBukkitEntity().canSee(input.getBukkitEntity())).collect(Collectors.toList())));
+            }
+            this.sendAllPlayerInfoIn = 0;
+        }
+
+    }
+
+    public void worldtick(BooleanSupplier hasTimeLeft, int tickCount) {
+        this.handlingTick = true;
+        this.tickRateManager.tick();
+        this.tickConnection();
+
+        this.tpsCalculator.doTick();
+        this.bukkitScheduler.mainThreadHeartbeat();
+
+        // tick the "region" scheduler
+        ((CanvasPerWorldScheduler) this.server.server.getRegionScheduler()).tick(this);
+        for (final Entity entity : this.getEntities().getAll()) {
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                if (entity.isRemoved()) {
+                    continue;
+                }
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        chunkSource.tick(() -> true, false);
+
+        hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+        hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        // net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+        updateLagCompensationTick();
+        hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        Queue<Runnable> copyOf = new ConcurrentLinkedQueue<>(this.queuedForNextTickPre);
+        this.queuedForNextTickPre.clear();
+        for (final Runnable runnable : copyOf) {
+            runnable.run();
+        }
+    // Canvas end
         ProfilerFiller profilerFiller = Profiler.get();
         this.handlingTick = true;
         TickRateManager tickRateManager = this.tickRateManager();
@@ -781,23 +_,41 @@
         profilerFiller.push("tickPending");
         if (!this.isDebug() && runsNormally) {
             long l = this.getGameTime();
+            // Canvas start
+            if (this.blockTicks.ticksSinceLastBlockTickCall++ > Config.INSTANCE.ticksBetweenBlockTicking) {
             profilerFiller.push("blockTicks");
             this.blockTicks.tick(l, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
+                this.blockTicks.ticksSinceLastBlockTickCall = 0;
+            }
+            if (this.fluidTicks.ticksSinceLastFluidTickCall++ > Config.INSTANCE.ticksBetweenFluidTicking) {
             profilerFiller.popPush("fluidTicks");
             this.fluidTicks.tick(l, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks
+                this.fluidTicks.ticksSinceLastFluidTickCall = 0;
+            }
+            // Canvas end
             profilerFiller.pop();
         }
 
         profilerFiller.popPush("raid");
         if (runsNormally) {
+            // Canvas start
+            if (this.ticksSinceLastRaidTickCall++ > Config.INSTANCE.ticksBetweenRaidTicking) {
             this.raids.tick();
+                this.ticksSinceLastRaidTickCall = 0;
+            }
+            // Canvas end
         }
 
         profilerFiller.popPush("chunkSource");
         this.getChunkSource().tick(hasTimeLeft, true);
         profilerFiller.popPush("blockEvents");
         if (runsNormally) {
+            // Canvas start
+            if (this.ticksSinceLastBlockEventsTickCall++ > Config.INSTANCE.ticksBetweenBlockEvents) {
             this.runBlockEvents();
+                this.ticksSinceLastBlockEventsTickCall = 0;
+            }
+            // Canvas end
         }
 
         this.handlingTick = false;
@@ -816,46 +_,74 @@
             }
 
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
-            this.entityTickList
-                .forEach(
-                    entity -> {
-                        if (!entity.isRemoved()) {
-                            if (!tickRateManager.isEntityFrozen(entity)) {
-                                profilerFiller.push("checkDespawn");
-                                entity.checkDespawn();
-                                profilerFiller.pop();
-                                if (true) { // Paper - rewrite chunk system
-                                    Entity vehicle = entity.getVehicle();
-                                    if (vehicle != null) {
-                                        if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
-                                            return;
-                                        }
-
-                                        entity.stopRiding();
-                                    }
-
-                                    profilerFiller.push("tick");
-                                    this.guardEntityTick(this::tickNonPassenger, entity);
-                                    profilerFiller.pop();
-                                }
-                            }
-                        }
-                    }
-                );
+            this.tickEntities(); // Canvas - optimize entity ticking
             profilerFiller.pop();
-            this.tickBlockEntities();
+            this.tickBlockEntities(profilerFiller);
         }
 
         profilerFiller.push("entityManagement");
         // Paper - rewrite chunk system
         profilerFiller.pop();
-    }
+        // Canvas start - Threaded Dimensions
+        copyOf = new ConcurrentLinkedQueue<>(this.queuedForNextTickPost);
+        this.queuedForNextTickPost.clear();
+        for (final Runnable runnable : copyOf) {
+            runnable.run();
+        }
+        tickPlayerList();
+        for (ServerPlayer player : this.players) {
+            player.connection.chunkSender.sendNextChunks(player);
+            player.connection.resumeFlushing();
+        }
+        explosionDensityCache.clear();
+        // Canvas end
+    }
+    // Canvas start - optimized entity ticking
+
+    public void tickEntities() {
+        this.entityTickList.forEach((entity) -> {
+            if (Config.CHECK_ENTITY_MASKS && Config.COMPILED_ENTITY_MASK_LOCATIONS.contains(entity.getTypeLocation())) {
+                int lived = entity.tickCount;
+                if (!entity.getMask().shouldTick || lived % entity.getMask().tickRate != 0) {
+                    entity.tickCount++; // Increment this still, since if we don't, this entity will never tick again(if its run on delay)
+                    return;
+                }
+            }
+            entityTick(entity);
+        });
+    }
+
+    private void entityTick(Entity entity) {
+        if (!entity.isRemoved()) {
+            if (!tickRateManager.isEntityFrozen(entity)) {
+                entity.checkDespawn();
+                Entity vehicle = entity.getVehicle();
+                if (vehicle != null) {
+                    if (!vehicle.isRemoved() && vehicle.hasPassenger(entity)) {
+                        return;
+                    }
+
+                    entity.stopRiding();
+                }
+
+                try {
+                    this.tickNonPassenger(entity);
+                } catch (Throwable var6) {
+                    final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+                    MinecraftServer.LOGGER.error(msg, var6);
+                    getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, var6)));
+                    entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+                }
+                this.moonrise$midTickTasks();
+            }
+        }
+    }
+    // Canvas end
 
     @Override
     public boolean shouldTickBlocksAt(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        return holder != null && holder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -874,10 +_,18 @@
                     this.setDayTime(this.preciseTime);
                 } else
                 // Purpur end - Configurable daylight cycle
-                this.setDayTime(this.levelData.getDayTime() + 1L);
+                this.setDayTime(lagCompensation(this.levelData.getDayTime()) + 1L); // Canvas - lag compensation
+                if (this.tickCount % 20 == 0) this.syncTimeToPlayers(); // Canvas - resync every 20 ticks
             }
         }
     }
+    // Canvas start
+
+    private long lagCompensation(long original) {
+        if (!Config.INSTANCE.lagCompensation.enabled || !Config.INSTANCE.lagCompensation.timeAcceleration) return original;
+        return original + this.tpsCalculator.applicableMissedTicks();
+    }
+    // Canvas end
 
     public void setDayTime(long time) {
         this.serverLevelData.setDayTime(time);
@@ -898,23 +_,29 @@
     // Purpur end - Configurable daylight cycle
 
     public void tickCustomSpawners(boolean spawnEnemies, boolean spawnFriendlies) {
+        // Canvas start
+        if (this.ticksSinceLastTickCustomSpawnersCall++ > Config.INSTANCE.ticksBetweenCustomSpawnersTick) {
         for (CustomSpawner customSpawner : this.customSpawners) {
             customSpawner.tick(this, spawnEnemies, spawnFriendlies);
         }
+        this.ticksSinceLastTickCustomSpawnersCall = 0;
+        }
+        // Canvas end
     }
 
     private void wakeUpAllPlayers() {
         this.sleepStatus.removeAllSleepers();
         this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList()).forEach(player -> player.stopSleepInBed(false, false));
+        this.server.forceTimeSynchronization(); // Canvas
     }
 
     // Paper start - optimise random ticking
-    private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+    private final SimpleThreadLocalRandomSource simpleRandom = SimpleThreadLocalRandomSource.INSTANCE; // Canvas
 
     private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
         final LevelChunkSection[] sections = chunk.getSections();
         final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom;
+        final SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Canvas
         final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
 
         final ChunkPos cpos = chunk.getPos();
@@ -961,7 +_,7 @@
     // Paper end - optimise random ticking
 
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom; // Paper - optimise random ticking
+        final SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Canvas
         ChunkPos pos = chunk.getPos();
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
@@ -1005,15 +_,23 @@
         profilerFiller.popPush("iceandsnow");
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
+            // Canvas start - precipitation intervals
+            if (chunk.ticksSinceLastPrecipitationCall++ > Config.INSTANCE.ticksBetweenPrecipitationUpdates) {
+                chunk.ticksSinceLastPrecipitationCall = 0;
+            // Canvas end
         for (int i = 0; i < randomTickSpeed; i++) {
             if (simpleRandom.nextInt(48) == 0) {  // Paper - optimise random ticking
                 this.tickPrecipitation(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             }
         }
+            } // Canvas
         } // Paper - Option to disable ice and snow
 
         profilerFiller.popPush("tickBlocks");
-        if (randomTickSpeed > 0) {
+        // Canvas start - random tick intervals
+        if (chunk.ticksSinceLastRandomTickCall++ > Config.INSTANCE.ticksBetweenRandomTickUpdates && randomTickSpeed > 0) {
+            chunk.ticksSinceLastRandomTickCall = 0;
+        // Canvas end
             this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
         }
 
@@ -1283,7 +_,15 @@
     }
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
-        BlockState blockState = this.getBlockState(pos);
+        // Canvas start
+        int x = SectionPos.blockToSectionCoord(pos.getX());
+        int z = SectionPos.blockToSectionCoord(pos.getZ());
+        LevelChunk chunk = this.chunkSource.getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) {
+            return;
+        }
+        BlockState blockState = chunk.getBlockState(pos);
+        // Canvas end
         FluidState fluidState = blockState.getFluidState();
         if (fluidState.is(fluid)) {
             fluidState.tick(this, pos, blockState);
@@ -1311,24 +_,25 @@
 
     // Paper start - log detailed entity tick information
     // TODO replace with varhandle
-    static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
+    // Canvas start
+    /* static final java.util.concurrent.atomic.AtomicReference<Entity> currentlyTickingEntity = new java.util.concurrent.atomic.AtomicReference<>();
 
     public static List<Entity> getCurrentlyTickingEntities() {
         Entity ticking = currentlyTickingEntity.get();
         List<Entity> ret = java.util.Arrays.asList(ticking == null ? new Entity[0] : new Entity[] { ticking });
 
         return ret;
-    }
+    } */ // Canvas end
     // Paper end - log detailed entity tick information
 
     public void tickNonPassenger(Entity entity) {
-        // Paper start - log detailed entity tick information
+        /* // Paper start - log detailed entity tick information // Canvas start
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot tick an entity off-main");
         try {
             if (currentlyTickingEntity.get() == null) {
                 currentlyTickingEntity.lazySet(entity);
             }
-            // Paper end - log detailed entity tick information
+            // Paper end - log detailed entity tick information */ // Canvas end
         entity.setOldPosAndRot();
         ProfilerFiller profilerFiller = Profiler.get();
         entity.tickCount++;
@@ -1346,11 +_,11 @@
             this.tickPassenger(entity, entity1, isActive); // Paper - EAR 2
         }
         // Paper start - log detailed entity tick information
-        } finally {
+        /* } finally { // Canvas start
             if (currentlyTickingEntity.get() == entity) {
                 currentlyTickingEntity.lazySet(null);
             }
-        }
+        } */ // Canvas end
         // Paper end - log detailed entity tick information
     }
 
@@ -1610,7 +_,7 @@
         return this.tryAddFreshEntityWithPassengers(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
     }
 
-    public boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+    public synchronized boolean tryAddFreshEntityWithPassengers(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) { // Canvas - synchronize
         // CraftBukkit end
         if (entity.getSelfAndPassengers().map(Entity::getUUID).anyMatch(this.moonrise$getEntityLookup()::hasEntity)) { // Paper - rewrite chunk system
             return false;
@@ -1763,10 +_,36 @@
         // Paper end - Prevent GameEvents being fired from unloaded chunks
         this.gameEventDispatcher.post(gameEvent, pos, context);
     }
+    // Canvas start
+    private final Set<PathNavigation> activeNavigations = new ConcurrentSet<>();
+
+    private Iterator<Mob> getActiveListeners(Set<Mob> set) {
+        return Collections.emptyIterator();
+    }
+
+    public void lithium$setNavigationActive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.add((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    public void lithium$setNavigationInactive(Mob mobEntity) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        activeNavigations.remove((mobEntity).lithium$getRegisteredNavigation());
+    }
+
+    private void updateActiveListeners(BlockPos pos, List<PathNavigation> list) {
+        Set<PathNavigation> activeNavigations = (this).activeNavigations;
+        for (PathNavigation entityNavigation : activeNavigations) {
+            if (entityNavigation.shouldRecomputePath(pos)) {
+                list.add(entityNavigation);
+            }
+        }
+    }
+    // Canvas end
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get() && false) { // Canvas
             String string = "recursive call to sendBlockUpdated";
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
@@ -1780,7 +_,13 @@
             List<PathNavigation> list = new ObjectArrayList<>();
 
             try { // Paper - catch CME see below why
-            for (Mob mob : this.navigatingMobs) {
+                // Canvas start
+                Iterator<Mob> iterator = getActiveListeners(this.navigatingMobs);
+                updateActiveListeners(pos, list);
+
+                while (iterator.hasNext()) {
+                    Mob mob = iterator.next();
+                // Canvas end
                 PathNavigation navigation = mob.getNavigation();
                 if (navigation.shouldRecomputePath(pos)) {
                     list.add(navigation);
@@ -1797,13 +_,13 @@
             // Paper end - catch CME see below why
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // Canvas
 
                 for (PathNavigation pathNavigation : list) {
                     pathNavigation.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // Canvas
             }
         }
         } // Paper - option to disable pathfinding updates
@@ -1811,29 +_,29 @@
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - atomic
         this.updateNeighborsAt(pos, block, ExperimentalRedstoneUtils.initialOrientation(this, null, null));
     }
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, null, orientation);
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement // Canvas - atomic
+        this.neighborUpdater.get().updateNeighborsAtExceptFromFacing(pos, block, null, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block block, Direction facing, @Nullable Orientation orientation) {
-        this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, block, facing, orientation);
+        this.neighborUpdater.get().updateNeighborsAtExceptFromFacing(pos, block, facing, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void neighborChanged(BlockPos pos, Block block, @Nullable Orientation orientation) {
-        this.neighborUpdater.neighborChanged(pos, block, orientation);
+        this.neighborUpdater.get().neighborChanged(pos, block, orientation); // Canvas - threadlocal
     }
 
     @Override
     public void neighborChanged(BlockState state, BlockPos pos, Block block, @Nullable Orientation orientation, boolean movedByPiston) {
-        this.neighborUpdater.neighborChanged(state, pos, block, orientation, movedByPiston);
+        this.neighborUpdater.get().neighborChanged(state, pos, block, orientation, movedByPiston); // Canvas - threadlocal
     }
 
     @Override
@@ -2157,10 +_,10 @@
         return this.server.getRecipeManager();
     }
 
-    @Override
+    /* @Override // Canvas start - clashes with super
     public TickRateManager tickRateManager() {
         return this.server.tickRateManager();
-    }
+    } */ // Canvas end
 
     @Override
     public boolean noSave() {
@@ -2419,7 +_,7 @@
         CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("y").addColumn("z").addColumn("type").build(output);
 
         for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) {
-            BlockPos pos = tickingBlockEntity.getPos();
+            BlockPos pos = getPosOrOrigin(tickingBlockEntity); // Canvas
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
     }
@@ -2449,6 +_,17 @@
     public Iterable<Entity> getAllEntities() {
         return this.getEntities().getAll();
     }
+    // Canvas start - getAllBlockEntities
+
+    public Iterable<BlockEntity> getAllBlockEntities() {
+        Set<BlockEntity> blockEntities = new ObjectHashSet<>();
+        for (final ServerChunkCache.ChunkAndHolder chunkAndHolder : this.tickingChunks.getRawDataUnchecked()) {
+            if (chunkAndHolder == null) continue;
+            blockEntities.addAll(chunkAndHolder.chunk().blockEntities.values());
+        }
+        return blockEntities;
+    }
+    // Canvas end
 
     @Override
     public String toString() {
@@ -2473,6 +_,16 @@
     public ServerLevel getLevel() {
         return this;
     }
+    // Canvas start
+
+    private BlockPos getPosOrOrigin(TickingBlockEntity instance) {
+        BlockPos pos = instance.getPos();
+        if (pos == null) {
+            return BlockPos.ZERO;
+        }
+        return pos;
+    }
+    // Canvas end
 
     @VisibleForTesting
     public String getWatchdogStats() {
@@ -2539,7 +_,7 @@
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
+        this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts());
     }
 
     public PathTypeCache getPathTypeCache() {
@@ -2547,7 +_,7 @@
     }
 
     @Override
-    public void close() throws IOException {
+    public void close() { // Canvas
         super.close();
         // Paper - rewrite chunk system
     }
@@ -2561,32 +_,27 @@
         return this.moonrise$getAnyChunkIfLoaded(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkPos)) != null; // Paper - rewrite chunk system
     }
 
-    private boolean isPositionTickingWithEntitiesLoaded(long chunkPos) {
+    public boolean isPositionTickingWithEntitiesLoaded(long chunkPos) { // Canvas - private -> public
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        // isTicking implies the chunk is loaded, and the chunk is loaded now implies the entities are loaded
-        return chunkHolder != null && chunkHolder.isTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.blockTickingChunkHolders.contains(chunkPos); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean isPositionEntityTicking(BlockPos pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(BlockPos pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(pos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
     public boolean isNaturalSpawningAllowed(ChunkPos chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = this.moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos));
-        return chunkHolder != null && chunkHolder.isEntityTickingReady();
+        return this.moonrise$getChunkTaskScheduler().chunkHolderManager.entityTickingChunkHolders.contains(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkPos)); // Canvas - faster impl
         // Paper end - rewrite chunk system
     }
 
@@ -2658,6 +_,35 @@
     // Paper end - optimize redstone (Alternate Current)
 
     final class EntityCallbacks implements LevelCallback<Entity> {
+        // Canvas start
+        private ServerLevel outer;
+
+        EntityCallbacks() {
+            this.outer = ServerLevel.this;
+        }
+
+        private boolean startListeningOnEntityLoad(Set<Mob> set, Object mobEntityObj) {
+            Mob mobEntity = (Mob) mobEntityObj;
+            PathNavigation navigation = mobEntity.getNavigation();
+            (mobEntity).lithium$setRegisteredToWorld(navigation);
+            if (navigation.getPath() != null) {
+                (this.outer).lithium$setNavigationActive(mobEntity);
+            }
+            return set.add(mobEntity);
+        }
+
+        private boolean stopListeningOnEntityUnload(Set<Mob> set, Object mobEntityObj) {
+            Mob mobEntity = (Mob) mobEntityObj;
+            if ((mobEntity).lithium$isRegisteredToWorld()) {
+                PathNavigation registeredNavigation = ((Mob) mobEntity).lithium$getRegisteredNavigation();
+                if (registeredNavigation.getPath() != null) {
+                    (this.outer).lithium$setNavigationInactive(mobEntity);
+                }
+                (mobEntity).lithium$setRegisteredToWorld(null);
+            }
+            return set.remove(mobEntity);
+        }
+        // Canvas end
         @Override
         public void onCreated(Entity entity) {
             entity.setOldPosAndRot(); // Paper - update old pos / rot for new entities as it will default to Vec3.ZERO
@@ -2686,7 +_,8 @@
         }
 
         @Override
-        public void onTrackingStart(Entity entity) {
+        public synchronized void onTrackingStart(Entity entity) { // Canvas - synchronize
+            TNTMergeManager.onEntityLoad(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
@@ -2695,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.add(mob);
+                startListeningOnEntityLoad(this.outer.navigatingMobs, mob); // Canvas
             }
 
             if (entity instanceof EnderDragon enderDragon) {
@@ -2729,6 +_,7 @@
 
         @Override
         public void onTrackingEnd(Entity entity) {
+            TNTMergeManager.onEntityUnload(entity); // Canvas - tnt merging
             org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
             // Spigot start // TODO I don't think this is needed anymore
             if (entity instanceof Player player) {
@@ -2765,14 +_,14 @@
             }
 
             if (entity instanceof Mob mob) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // Canvas
                     String string = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
-                ServerLevel.this.navigatingMobs.remove(mob);
+                stopListeningOnEntityUnload(this.outer.navigatingMobs, mob); // Canvas
             }
 
             if (entity instanceof EnderDragon enderDragon) {
