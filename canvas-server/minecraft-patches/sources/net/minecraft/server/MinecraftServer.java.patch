--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -13,6 +_,13 @@
 import com.mojang.jtracy.DiscontinuousFrame;
 import com.mojang.jtracy.TracyClient;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.scheduler.TickScheduler;
+import io.canvasmc.canvas.server.MultiWatchdogThread;
+import io.canvasmc.canvas.server.ThreadedServer;
+import io.canvasmc.canvas.util.ConnectionPool;
+import io.canvasmc.canvas.util.TPSCalculator;
+import io.canvasmc.canvas.util.AsyncProcessor;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -32,6 +_,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -43,6 +_,8 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
@@ -73,6 +_,7 @@
 import net.minecraft.network.chat.ChatDecorator;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketType;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
@@ -81,6 +_,7 @@
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.bossevents.CustomBossEvents;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.DemoMode;
 import net.minecraft.server.level.PlayerRespawnLogic;
 import net.minecraft.server.level.ServerChunkCache;
@@ -136,6 +_,7 @@
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.flag.FeatureFlags;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.alchemy.PotionBrewing;
 import net.minecraft.world.item.crafting.RecipeManager;
 import net.minecraft.world.level.ChunkPos;
@@ -171,18 +_,21 @@
 import net.minecraft.world.level.storage.WorldData;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
 import org.slf4j.Logger;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
     private static MinecraftServer SERVER; // Paper
+    private static ThreadedServer THREADED_SERVER; // Canvas
     public static final Logger LOGGER = LogUtils.getLogger();
     public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
-    private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
+    public static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit // Canvas - private -> public
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND; // Canvas - private -> public
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
     private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
@@ -199,6 +_,7 @@
     public LevelStorageSource.LevelStorageAccess storageSource;
     public final PlayerDataStorage playerDataStorage;
     private final List<Runnable> tickables = Lists.newArrayList();
+    public volatile boolean notifyStop; // Canvas - better notification of stop - volatile
     private MetricsRecorder metricsRecorder = InactiveMetricsRecorder.INSTANCE;
     private Consumer<ProfileResults> onMetricsRecordingStopped = results -> this.stopRecordingMetrics();
     private Consumer<Path> onMetricsRecordingFinished = path -> {};
@@ -209,19 +_,19 @@
     private ServerConnectionListener connection;
     public final ChunkProgressListenerFactory progressListenerFactory;
     @Nullable
-    private ServerStatus status;
+    public ServerStatus status; // Canvas - private -> public
     @Nullable
-    private ServerStatus.Favicon statusIcon;
+    public ServerStatus.Favicon statusIcon; // Canvas - private -> public
     private final RandomSource random = RandomSource.create();
     public final DataFixer fixerUpper;
     private String localIp;
     private int port = -1;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
+    public Map<ResourceKey<Level>, ServerLevel> levels = Collections.synchronizedMap(new LinkedHashMap<>()); // Canvas - private -> public - synchronized
     private PlayerList playerList;
     private volatile boolean running = true;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
-    private boolean stopped;
+    public boolean stopped; // Canvas - private -> public
     private int tickCount;
     private int ticksUntilAutosave = 6000;
     protected final Proxy proxy;
@@ -245,14 +_,14 @@
     private boolean isDemo;
     private volatile boolean isReady;
     private long lastOverloadWarningNanos;
-    protected final Services services;
+    public final Services services; // Canvas - protected -> public
     private long lastServerStatus;
     public final Thread serverThread;
     private long lastTickNanos = Util.getNanos();
     private long taskExecutionStartNanos = Util.getNanos();
     private long idleTimeNanos;
-    private long nextTickTimeNanos = Util.getNanos();
-    private boolean waitingForNextTick = false;
+    public long nextTickTimeNanos; // Canvas - private -> public
+    public boolean waitingForNextTick; // Canvas - private -> public
     private long delayedTasksMaxNextTickTimeNanos;
     private boolean mayHaveDelayedTasks;
     private final PackRepository packRepository;
@@ -292,8 +_,8 @@
     // CraftBukkit end
     // Spigot start
     public static final int TPS = 20;
-    public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
-    private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
+    // Canvas - rewrite tick system
+    // Canvas - rewrite tick system
     @Deprecated(forRemoval = true) // Paper
     public final double[] recentTps = new double[4]; // Purpur - Add 5 second tps average in /tps
     // Spigot end
@@ -302,17 +_,32 @@
     public volatile Thread shutdownThread; // Paper - Improved watchdog support
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
-    private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
+    public final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping // Canvas - private -> public
+    public AsyncProcessor mobSpawnExecutor = new AsyncProcessor("MobSpawning");
     public boolean lagging = false; // Purpur - Lagging threshold
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
     protected boolean upnp = false; // Purpur - UPnP Port Forwarding
 
+    // Canvas start - Threaded Dimensions
+    private volatile boolean isTicking = false;
+    public final TPSCalculator tpsCalculator = new TPSCalculator(); // lag compensation
+    public final ConnectionPool connectionPool = new ConnectionPool(this);
+
+    public boolean isTicking() {
+        return isTicking;
+    }
+
+    // Canvas end
     public static <S extends MinecraftServer> S spin(Function<Thread, S> threadFunction) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
         AtomicReference<S> atomicReference = new AtomicReference<>();
-        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> atomicReference.get().runServer(), "Server thread");
+        // Canvas start - Threaded Server
+        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> {
+            THREADED_SERVER.spin();
+        }, "Server thread");
+        // Canvas end
         thread.setUncaughtExceptionHandler((thread1, exception) -> LOGGER.error("Uncaught exception in server thread", exception));
-        thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
+        thread.setPriority(Config.INSTANCE.ticking.tickLoopThreadPriority); // Paper - Perf: Boost priority // Canvas - match config
         if (Runtime.getRuntime().availableProcessors() > 4) {
             thread.setPriority(8);
         }
@@ -331,14 +_,15 @@
         this.chunkSystemCrash = throwable;
     }
 
-    private static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us
-    private static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
-    private static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
+    public static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us // Canvas - private -> public
+    public static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us // Canvas - private -> public
+    public static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us // Canvas - private -> public
 
-    private long lastMidTickExecute;
-    private long lastMidTickExecuteFailure;
+    private final ThreadLocal<Long> lastMidTickExecute = ThreadLocal.withInitial(() -> 0L); // Canvas - threadlocal
+    private final ThreadLocal<Long> lastMidTickExecuteFailure = ThreadLocal.withInitial(() -> 0L); // Canvas - threadlocal
 
     private boolean tickMidTickTasks() {
+        if (true) return false; // Canvas - we cannot poll chunk tasks on main
         // give all worlds a fair chance at by targeting them all.
         // if we execute too many tasks, that's fine - we have logic to correctly handle overuse of allocated time.
         boolean executed = false;
@@ -361,7 +_,7 @@
     @Override
     public final void moonrise$executeMidTickTasks() {
         final long startTime = System.nanoTime();
-        if ((startTime - this.lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - this.lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
+        if ((startTime - this.lastMidTickExecute.get()) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - this.lastMidTickExecuteFailure.get()) <= TASK_EXECUTION_FAILURE_BACKOFF) { // Canvas - threadlocal
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
             // so, backoff to prevent this
             return;
@@ -374,7 +_,7 @@
 
             if (!moreTasks || diff >= MAX_CHUNK_EXEC_TIME) {
                 if (!moreTasks) {
-                    this.lastMidTickExecuteFailure = currTime;
+                    this.lastMidTickExecuteFailure.set(currTime); // Canvas - threadlocal
                 }
 
                 // note: negative values reduce the time
@@ -387,7 +_,7 @@
                 final double overuseCount = (double)overuse/(double)MAX_CHUNK_EXEC_TIME;
                 final long extraSleep = (long)Math.round(overuseCount*CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
 
-                this.lastMidTickExecute = currTime + extraSleep;
+                this.lastMidTickExecute.set(currTime + extraSleep); // Canvas - threadlocal
                 return;
             }
         }
@@ -474,13 +_,20 @@
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper - add paper configuration files
+        // Canvas start - rewrite tick system
+        THREADED_SERVER = new ThreadedServer(this);
+        this.tps5s = new io.canvasmc.canvas.RollingAverage(5); // Purpur - Add 5 second tps average in /tps
+        this.tps1 = new io.canvasmc.canvas.RollingAverage(60);
+        this.tps5 = new io.canvasmc.canvas.RollingAverage(60 * 5);
+        this.tps15 = new io.canvasmc.canvas.RollingAverage(60 * 15);
+        // Canvas end
     }
 
     private void readScoreboard(DimensionDataStorage dataStorage) {
         dataStorage.computeIfAbsent(this.getScoreboard().dataFactory(), "scoreboard");
     }
 
-    protected abstract boolean initServer() throws IOException;
+    public abstract boolean initServer() throws IOException; // Canvas - protected -> public
 
     protected void loadLevel(String levelId) { // CraftBukkit
         if (!JvmProfiler.INSTANCE.isRunning()) {
@@ -807,7 +_,7 @@
                 }
             }
             // CraftBukkit end
-            ChunkPos chunkPos = new ChunkPos(chunkSource.randomState().sampler().findSpawnPosition()); // Paper - Only attempt to find spawn position if there isn't a fixed spawn position set
+            ChunkPos chunkPos = level.randomSpawnSelection == null ? new ChunkPos(chunkSource.randomState().sampler().findSpawnPosition()) : level.randomSpawnSelection; // Paper - Only attempt to find spawn position if there isn't a fixed spawn position set // Canvas
             int spawnHeight = chunkSource.getGenerator().getSpawnHeight(level);
             if (spawnHeight < level.getMinY()) {
                 BlockPos worldPosition = chunkPos.getWorldPosition();
@@ -876,6 +_,7 @@
             // CraftBukkit start
             // this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
             this.executeModerately();
+            break; // Canvas
         }
 
         // this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
@@ -978,7 +_,7 @@
     }
 
     // CraftBukkit start
-    private boolean hasStopped = false;
+    public volatile boolean hasStopped = false; // Canvas - private -> public - volatile
     private boolean hasLoggedStop = false; // Paper - Debugging
     private final Object stopLock = new Object();
     public final boolean hasStopped() {
@@ -990,19 +_,69 @@
 
     public void stopServer() {
         // CraftBukkit start - prevent double stopping on multiple threads
+        // Canvas start - ensure we don't run stop off main
+        if (!Thread.currentThread().equals(this.serverThread)) {
+            this.notifyStop = true;
+            return;
+        }
+        // Canvas end
         synchronized(this.stopLock) {
             if (this.hasStopped) return;
             this.hasStopped = true;
         }
+        // Canvas start - Threaded Dimensions
+        ThreadedServer.LOGGER.info("Halting tick-loops");
+        ThreadedServer.LOGGER.info("Awaiting scheduler termination for 60s...");
+        long startNanos = Util.getNanos();
+        ThreadedServer threadedServer = MinecraftServer.getThreadedServer();
+        // cleanup tick-loops, ensure all are terminated.
+        threadedServer.markPrepareHalt(); // notify to threads we are halting
+        if (TickScheduler.getScheduler().halt(true, TimeUnit.SECONDS.toNanos(60L))) {
+            ThreadedServer.LOGGER.info("Scheduler halted");
+        } else {
+            ThreadedServer.LOGGER.warn("Scheduler did not terminate within 60s, proceeding with shutdown anyways");
+            TickScheduler.getScheduler().dumpAliveThreadTraces("Did not shut down in time");
+        }
+        long nanoTickTime = Util.getNanos() - startNanos;
+        ThreadedServer.LOGGER.info("Successfully halted all tick-loops in {}ms", (nanoTickTime / 1_000_000));
+
+        LOGGER.info("Respawning dead players...");
+        for (ServerPlayer player : this.playerList.players) {
+            if (player.isDeadOrDying() || (player.isRemoved() && player.getRemovalReason() == net.minecraft.world.entity.Entity.RemovalReason.KILLED)) {
+                this.playerList.respawn(player, false, net.minecraft.world.entity.Entity.RemovalReason.KILLED, PlayerRespawnEvent.RespawnReason.DEATH);
+                LOGGER.info("Respawned {}", player.getDisplayName().getString());
+            }
+        }
+
+        // close current inventory
+        LOGGER.info("Closing player inventories...");
+        for (final ServerPlayer player : this.playerList.players) {
+            try {
+                // close inventory
+                if (player.containerMenu != player.inventoryMenu) {
+                    player.closeContainer(InventoryCloseEvent.Reason.DISCONNECT);
+                }
+
+                // drop carried item
+                if (!player.containerMenu.getCarried().isEmpty()) {
+                    ItemStack carried = player.containerMenu.getCarried();
+                    player.containerMenu.setCarried(ItemStack.EMPTY);
+                    player.drop(carried, false);
+                }
+            } catch (final Throwable thr) {
+                LOGGER.error("Failed to close player inventory for player: {}", player, thr);
+            }
+        }
+        LOGGER.info("Closed player inventories");
+        // Canvas end
         if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
         shutdownThread = Thread.currentThread(); // Paper - Improved watchdog support
-        org.spigotmc.WatchdogThread.doStop(); // Paper - Improved watchdog support
+        MultiWatchdogThread.doStop(); // Paper - Improved watchdog support // Canvas - rewrite watchdog
         // CraftBukkit end
         if (this.metricsRecorder.isRecording()) {
             this.cancelRecordingMetrics();
         }
 
-        LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
         // Purpur start - UPnP Port Forwarding
         if (upnp) {
@@ -1078,12 +_,15 @@
         }
         // Paper end - rewrite chunk system
         // Paper start - Improved watchdog support - move final shutdown items here
+        LOGGER.info("Shutting down executors"); // Canvas - better shutdown logging
         Util.shutdownExecutors();
+        this.mobSpawnExecutor.shutdown(); // Canvas - async mob spawning
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (final Exception ignored) {
         }
         io.papermc.paper.log.CustomLogManager.forceReset(); // Paper - Reset loggers after shutdown
+        LOGGER.info("Exiting server"); // Canvas - better shutdown logging
         this.onServerExit();
         // Paper end - Improved watchdog support - move final shutdown items here
     }
@@ -1123,13 +_,15 @@
 
     // Paper start - Further improve server tick loop
     private static final long SEC_IN_NANO = 1000000000;
-    private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
+    // private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L; // Canvas - rewrite tick system
     private long lastTick = 0;
     private long catchupTime = 0;
-    public final RollingAverage tps5s = new RollingAverage(5); // Purpur - Add 5 second tps average in /tps
-    public final RollingAverage tps1 = new RollingAverage(60);
-    public final RollingAverage tps5 = new RollingAverage(60 * 5);
-    public final RollingAverage tps15 = new RollingAverage(60 * 15);
+    // Canvas start - use ours
+    public final io.canvasmc.canvas.RollingAverage tps5s; // Purpur - Add 5 second tps average in /tps
+    public final io.canvasmc.canvas.RollingAverage tps1;
+    public final io.canvasmc.canvas.RollingAverage tps5;
+    public final io.canvasmc.canvas.RollingAverage tps15;
+    // Canvas end
 
     public static class RollingAverage {
         private final int size;
@@ -1170,10 +_,11 @@
             return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
         }
     }
-    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    // Canvas - rewrite tick system
     // Paper end
 
     protected void runServer() {
+        if (true) throw new UnsupportedOperationException(); /* // Canvas - Threaded Dimensions
         try {
             if (!this.initServer()) {
                 throw new IllegalStateException("Failed to initialize server");
@@ -1301,7 +_,7 @@
                     this.mayHaveDelayedTasks = true;
                     this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + l, this.nextTickTimeNanos);
                     // Purpur start - Configurable TPS Catchup
-                    if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup /*|| !gg.pufferfish.pufferfish.PufferfishConfig.tpsCatchup*/) { // Purpur - Configurable TPS Catchup
+                    if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup /*|| !gg.pufferfish.pufferfish.PufferfishConfig.tpsCatchup*//*) { // Purpur - Configurable TPS Catchup // Canvas - compile error with syntax
                         this.nextTickTimeNanos = currentTime + l;
                         this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
                     }
@@ -1348,7 +_,123 @@
                 //this.onServerExit(); // Paper - Improved watchdog support; moved into stop
             }
         }
-    }
+        */
+    }
+    // Canvas start - Multithreaded Dimension Ticking
+
+    public long tick(long tickSection) {
+        if (!isTicking) {
+            // mark first tick starting
+            isTicking = true;
+        }
+        long currentTime;
+        long i;
+
+        if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+            i = 0L;
+            this.nextTickTimeNanos = Util.getNanos();
+            this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+        } else {
+            i = this.tickRateManager.nanosecondsPerTick();
+            long j = Util.getNanos() - this.nextTickTimeNanos;
+
+            if (j > MinecraftServer.OVERLOADED_THRESHOLD_NANOS + 20L * i && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * i) {
+                long k = j / i;
+
+                if (this.server.getWarnOnOverload()) {
+                    MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k);
+                }
+                this.nextTickTimeNanos += k * i;
+                this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+            }
+        }
+
+        currentTime = Util.getNanos();
+        if (++MinecraftServer.currentTick % getThreadedServer().getScheduler().getSampleRate() == 0) {
+            final long diff = currentTime - tickSection;
+            final java.math.BigDecimal currentTps = getThreadedServer().getScheduler().getTpsBase().divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+            tps5s.add(currentTps, diff);
+            tps1.add(currentTps, diff);
+            tps5.add(currentTps, diff);
+            tps15.add(currentTps, diff);
+
+            this.recentTps[0] = tps5s.getAverage();
+            this.recentTps[1] = tps1.getAverage();
+            this.recentTps[2] = tps5.getAverage();
+            this.recentTps[3] = tps15.getAverage();
+            lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+            tickSection = currentTime;
+        }
+
+        boolean flag = i == 0L;
+
+        if (this.debugCommandProfilerDelayStart) {
+            this.debugCommandProfilerDelayStart = false;
+            this.debugCommandProfiler = new TimeProfiler(Util.getNanos(), this.tickCount);
+        }
+
+        lastTick = currentTime;
+        this.nextTickTimeNanos += i;
+
+        try {
+            Profiler.Scope profiler_a = Profiler.use(this.createProfiler());
+
+            try {
+                ProfilerFiller gameprofilerfiller = Profiler.get();
+
+                gameprofilerfiller.push("tick");
+                this.tickFrame.start();
+                // We update it through here so that we can easily access this var throughout the lifecycle
+                ThreadedServer.SHOULD_KEEP_TICKING = flag ? () -> false : this::haveTime;
+                this.tickServer(ThreadedServer.SHOULD_KEEP_TICKING);
+
+                final Throwable crash = this.chunkSystemCrash;
+                if (crash != null) {
+                    this.chunkSystemCrash = null;
+                    throw new RuntimeException("Chunk system crash propagated to tick()", crash);
+                }
+
+                this.tickFrame.end();
+                gameprofilerfiller.popPush("nextTickWait");
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + i, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup && false) { // Canvas - don't run tps catchup
+                    this.nextTickTimeNanos = currentTime + i;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+                if (flag) {
+                    this.tickRateManager.endTickWork();
+                }
+
+                gameprofilerfiller.pop();
+                this.logFullTickTime();
+            } catch (Throwable throwable) {
+                if (profiler_a != null) {
+                    try {
+                        profiler_a.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
+                    }
+                }
+
+                throw throwable;
+            }
+
+            if (profiler_a != null) {
+                profiler_a.close();
+            }
+        } finally {
+            this.endMetricsRecordingTick();
+        }
+
+        this.isReady = true;
+        JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
+        return tickSection;
+    }
+    // Canvas end
 
     private void logFullTickTime() {
         long nanos = Util.getNanos();
@@ -1374,7 +_,7 @@
         }
     }
 
-    private static CrashReport constructOrExtractCrashReport(Throwable cause) {
+    public static CrashReport constructOrExtractCrashReport(Throwable cause) { // Canvas - private -> public
         ReportedException reportedException = null;
 
         for (Throwable throwable = cause; throwable != null; throwable = throwable.getCause()) {
@@ -1474,7 +_,7 @@
         if (super.pollTask()) {
             this.moonrise$executeMidTickTasks(); // Paper - rewrite chunk system
             return true;
-        } else {
+        } else if (!getThreadedServer().hasStarted()) { // Canvas
             boolean ret = false; // Paper - force execution of all worlds, do not just bias the first
             if (this.tickRateManager.isSprinting() || this.haveTime()) {
                 for (ServerLevel serverLevel : this.getAllLevels()) {
@@ -1486,6 +_,7 @@
 
             return ret; // Paper - force execution of all worlds, do not just bias the first
         }
+        return false; // Canvas
     }
 
     @Override
@@ -1494,7 +_,7 @@
         super.doRunTask(task);
     }
 
-    private Optional<ServerStatus.Favicon> loadStatusIcon() {
+    public Optional<ServerStatus.Favicon> loadStatusIcon() { // Canvas - private -> public
         Optional<Path> optional = Optional.of(this.getFile("server-icon.png"))
             .filter(path -> Files.isRegularFile(path))
             .or(() -> this.storageSource.getIconFile().filter(path -> Files.isRegularFile(path)));
@@ -1531,8 +_,17 @@
         return false;
     }
 
+    // Canvas start
+    private boolean emptyTickSleeping = false;
+
+    public boolean isEmptyTickSkipping() {
+        return emptyTickSleeping;
+    }
+
+    // Canvas end
     public void tickServer(BooleanSupplier hasTimeLeft) {
-        org.spigotmc.WatchdogThread.tick(); // Spigot
+        if (this.notifyStop) this.stopServer(); // Canvas
+        // Canvas - rewrite watchdog
         long nanos = Util.getNanos();
         int i = this.pauseWhileEmptySeconds() * 20;
         this.removeDisabledPluginsBlockingSleep(); // Paper - API to allow/disallow tick sleeping
@@ -1547,6 +_,13 @@
                 this.server.spark.tickStart(); // Paper - spark
                 if (this.emptyTicks == i) {
                     LOGGER.info("Server empty for {} seconds, pausing", this.pauseWhileEmptySeconds());
+                    // Canvas start
+                    Set<TickScheduler.FullTick<?>> loops = TickScheduler.FullTick.ALL_REGISTERED.stream().filter(TickScheduler.FullTick::shouldSleep).collect(Collectors.toSet());
+                    LOGGER.info("Notifying {} tick-loops of sleep", loops.size());
+                    for (final TickScheduler.FullTick<?> loop : loops) {
+                        loop.sleep();
+                    }
+                    // Canvas end
                     this.autoSave();
                 }
 
@@ -1556,19 +_,33 @@
                 while ((task = this.processQueue.poll()) != null) {
                     task.run();
                 }
-                for (final ServerLevel level : this.levels.values()) {
+                // Canvas start - Multithreaded Dimension Ticking
+                // We tick the chunk source on the levels respective thread
+                /* for (final ServerLevel level : this.levels.values()) {
                     // process unloads
                     level.getChunkSource().tick(() -> true, false);
-                }
+                } */ // Canvas end
                 // Paper end - avoid issues with certain tasks not processing during sleep
                 this.server.spark.executeMainThreadTasks(); // Paper - spark
                 this.tickConnection();
                 this.server.spark.tickEnd(((double)(System.nanoTime() - lastTick) / 1000000D)); // Paper - spark
+                emptyTickSleeping = true; // Canvas
                 return;
             }
+            // Canvas start
+            else if (emptyTickSleeping) {
+                Set<TickScheduler.FullTick<?>> loops = TickScheduler.FullTick.ALL_REGISTERED;
+                LOGGER.info("Waking tick-loops from sleep state");
+                for (final TickScheduler.FullTick<?> loop : loops) {
+                    loop.wake();
+                }
+            }
+            // Canvas end
         }
 
+        emptyTickSleeping = false; // Canvas
         this.server.spark.tickStart(); // Paper - spark
+        this.tpsCalculator.doTick(); // Canvas
         new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper - Server Tick Events
         this.tickCount++;
         this.tickRateManager.tick();
@@ -1608,7 +_,7 @@
         this.server.spark.executeMainThreadTasks(); // Paper - spark
         // Paper start - Server Tick Events
         long endTime = System.nanoTime();
-        long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
+        long remaining = (getThreadedServer().getScheduler().getTimeBetweenTicks() - (endTime - lastTick)) - catchupTime; // Canvas - rewrite tick system
         new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double)(endTime - lastTick) / 1000000D), remaining).callEvent();
         // Paper end - Server Tick Events
         this.server.spark.tickEnd(((double)(endTime - lastTick) / 1000000D)); // Paper - spark
@@ -1664,11 +_,11 @@
         }
     }
 
-    protected abstract SampleLogger getTickTimeLogger();
+    public abstract SampleLogger getTickTimeLogger(); // Canvas - protected -> public
 
     public abstract boolean isTickTimeLoggingEnabled();
 
-    private ServerStatus buildServerStatus() {
+    public ServerStatus buildServerStatus() { // Canvas - private -> public
         ServerStatus.Players players = this.buildPlayerStatus();
         return new ServerStatus(
             io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), // Paper - Adventure
@@ -1701,11 +_,12 @@
 
     protected void tickChildren(BooleanSupplier hasTimeLeft) {
         ProfilerFiller profilerFiller = Profiler.get();
-        this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
+        // this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing()); // Canvas - moved to worlds
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
+        // Canvas start - move to level threads
+        /* getAllLevels().forEach(level -> {
             for (final net.minecraft.world.entity.Entity entity : level.getEntities().getAll()) {
                 if (entity.isRemoved()) {
                     continue;
@@ -1715,7 +_,8 @@
                     bukkit.taskScheduler.executeTick();
                 }
             }
-        });
+        }); */
+        // Canvas end
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         profilerFiller.push("commandFunctions");
@@ -1730,7 +_,8 @@
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        // Canvas start - Multithreaded Dimension Ticking - moved to ServerLevel
+        /* for (final ServerLevel level : this.getAllLevels()) {
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1747,9 +_,9 @@
                 entityplayer.connection.send(packet); // Add support for per player time
                 // Paper end - Perf: Optimize time updates
             }
-        }
+        } */ // Canvas end
 
-        this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
+        /* this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked // Canvas start - Multithreaded Dimension Ticking
         for (ServerLevel serverLevel : this.getAllLevels()) {
             serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
             serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
@@ -1763,7 +_,7 @@
                 this.synchronizeTime(serverLevel);
                 profilerFiller.pop();
             }
-            // CraftBukkit end */
+            // CraftBukkit end // Canvas - compile error with craftbukkit comment
 
             profilerFiller.push("tick");
 
@@ -1779,7 +_,7 @@
             profilerFiller.pop();
             serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
-        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked */ // Canvas end
 
         profilerFiller.popPush("connection");
         this.tickConnection();
@@ -1797,10 +_,7 @@
 
         profilerFiller.popPush("send chunks");
 
-        for (ServerPlayer serverPlayer : this.playerList.getPlayers()) {
-            serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
-            serverPlayer.connection.resumeFlushing();
-        }
+        // Canvas - Threaded Dimensions
 
         profilerFiller.pop();
     }
@@ -1810,6 +_,12 @@
     }
 
     private void synchronizeTime(ServerLevel level) {
+        // Canvas start - not all worlds have the same time anymore due to tick isolation
+        if (true) {
+            level.syncTimeToPlayers();
+            return;
+        }
+        // Canvas end
         this.playerList
             .broadcastAll(
                 new ClientboundSetTimePacket(level.getGameTime(), level.getDayTime(), level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)),
@@ -1822,7 +_,7 @@
         profilerFiller.push("timeSync");
 
         for (ServerLevel serverLevel : this.getAllLevels()) {
-            this.synchronizeTime(serverLevel);
+            serverLevel.syncTimeToPlayers(); // Canvas
         }
 
         profilerFiller.pop();
@@ -1870,6 +_,7 @@
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        level.retire(); // Canvas - Threaded Dimensions
     }
     // CraftBukkit end
 
@@ -2638,6 +_,12 @@
     public static MinecraftServer getServer() {
         return SERVER; // Paper
     }
+    // Canvas start
+
+    public static ThreadedServer getThreadedServer() {
+        return THREADED_SERVER;
+    }
+    // Canvas end
 
     @Deprecated
     public static RegistryAccess getDefaultRegistryAccess() {
@@ -2776,7 +_,12 @@
         }
     }
 
-    public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
+    // Canvas start - virtual threads
+    public final java.util.concurrent.ExecutorService chatExecutor =
+        Config.INSTANCE.virtualThreads.shouldReplaceChatExecutor() ?
+            Executors.newVirtualThreadPerTaskExecutor() :
+            java.util.concurrent.Executors.newCachedThreadPool(
+    // Canvas end
         new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
 
@@ -2852,7 +_,7 @@
         return ServerLinks.EMPTY;
     }
 
-    protected int pauseWhileEmptySeconds() {
+    public int pauseWhileEmptySeconds() { // Canvas - protected -> public
         return 0;
     }
 
@@ -2918,13 +_,16 @@
     // Paper start - Add tick times API and /mspt command
     public static class TickTimes {
         private final long[] times;
+        private final long intervalNs; // Canvas - expand tick times
 
         public TickTimes(int length) {
             times = new long[length];
+            this.intervalNs = 50 * 1_000_000 ; // Canvas - expand tick times - ms -> nanos -- ms * 1_000_000
         }
 
-        void add(int index, long time) {
+        public void add(int index, long time) { // Canvas - public
             times[index % times.length] = time;
+            index++; // Canvas - expand tick times
         }
 
         public long[] getTimes() {
@@ -2938,6 +_,17 @@
             }
             return ((double) total / (double) times.length) * 1.0E-6D;
         }
+        // Canvas start - expand tick times
+
+        public double getUtilization() {
+            long totalExecutionTime = 0L;
+            for (long time : times) {
+                totalExecutionTime += time;
+            }
+            long totalElapsedTime = times.length * intervalNs;
+            return ((double) totalExecutionTime / totalElapsedTime) * 100;
+        }
+        // Canvas end
     }
     // Paper end - Add tick times API and /mspt command
 
