--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -3,6 +_,8 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.entity.SleepingBlockEntity;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import java.util.Collections;
@@ -95,7 +_,8 @@
     // Paper end
     // Paper start - rewrite chunk system
     private boolean postProcessingDone;
-    private net.minecraft.server.level.ServerChunkCache.ChunkAndHolder chunkAndHolder;
+    public net.minecraft.server.level.ServerChunkCache.ChunkAndHolder chunkAndHolder; // Canvas - private -> public
+    public volatile boolean heightMapPrimed = false; // Canvas
 
     @Override
     public final boolean moonrise$isPostProcessingDone() {
@@ -120,6 +_,8 @@
     private final int maxSection;
     private final boolean debug;
     private final BlockState defaultBlockState;
+    public int ticksSinceLastPrecipitationCall = 0; // Canvas
+    public int ticksSinceLastRandomTickCall = 0; // Canvas
 
     @Override
     public final BlockState moonrise$getBlock(final int x, final int y, final int z) {
@@ -267,11 +_,18 @@
     public BlockState getBlockStateFinal(final int x, final int y, final int z) {
         // Copied and modified from below
         final int sectionIndex = this.getSectionIndex(y);
-        if (sectionIndex < 0 || sectionIndex >= this.sections.length
-            || this.sections[sectionIndex].nonEmptyBlockCount == 0) {
-            return Blocks.AIR.defaultBlockState();
-        }
-        return this.sections[sectionIndex].states.get((y & 15) << 8 | (z & 15) << 4 | x & 15);
+        // Canvas start - optimize block state lookup
+        if (sectionIndex < 0 || sectionIndex >= this.sections.length) {
+            return Blocks.AIR.defaultBlockState();
+        }
+
+        final LevelChunkSection section = this.sections[sectionIndex];
+        if (section.nonEmptyBlockCount == 0) {
+            return Blocks.AIR.defaultBlockState();
+        }
+
+        return section.states.get((y & 15) << 8 | (z & 15) << 4 | (x & 15));
+        // Canvas end
     }
     @Override
     public BlockState getBlockState(BlockPos pos) {
@@ -404,7 +_,7 @@
                 if (!section.getBlockState(i, i1, i2).is(block)) {
                     return null;
                 } else {
-                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates.get() || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled. // Canvas - atomic
                         state.onPlace(this.level, pos, blockState, isMoving);
                     }
 
@@ -534,6 +_,7 @@
 
                 if (blockState.getBlock() != blockState1.getBlock()) {
                     LOGGER.warn("Block state mismatch on block entity {} in position {}, {} != {}, updating", blockEntity, blockPos, blockState, blockState1);
+                    new Throwable().printStackTrace(); // Canvas - print stacktrace for mismatch
                 }
 
                 blockEntity.setBlockState(blockState);
@@ -620,7 +_,7 @@
 
     // CraftBukkit start
     public void loadCallback() {
-        if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
+        if (this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         // Paper start
         this.loadedTicketLevel = true;
         // Paper end
@@ -661,7 +_,7 @@
     }
 
     public void unloadCallback() {
-        if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
+        if (!this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         org.bukkit.Server server = this.level.getCraftServer();
         org.bukkit.craftbukkit.event.CraftEventFactory.callEntitiesUnloadEvent(this.level, this.chunkPos, ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(this.locX, this.locZ).getEntityChunk().getAllEntities()); // Paper - rewrite chunk system
         org.bukkit.Chunk bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
@@ -758,7 +_,7 @@
                     BlockPos blockPos = ProtoChunk.unpackOffsetCoordinates(_short, this.getSectionYFromSectionIndex(i), pos);
                     BlockState blockState = this.getBlockState(blockPos);
                     FluidState fluidState = blockState.getFluidState();
-                    if (!fluidState.isEmpty()) {
+                    if (!Config.INSTANCE.disableFluidTickingInPostProcessGenerationStep && !fluidState.isEmpty()) { // Canvas - disable fluid ticking on post process gen
                         fluidState.tick(level, blockPos, blockState);
                     }
 
@@ -792,7 +_,8 @@
                 blockEntity = ((EntityBlock)blockState.getBlock()).newBlockEntity(pos, blockState);
             } else {
                 blockEntity = null;
-                LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", pos, blockState);
+                LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", pos, blockState, new Throwable()); // Canvas - print calltrace
+                return null; // Canvas - just return, dont send extra logs.
             }
         } else {
             blockEntity = BlockEntity.loadStatic(pos, blockState, tag, this.level.registryAccess());
@@ -875,12 +_,22 @@
                     (pos, ticker1) -> {
                         TickingBlockEntity tickingBlockEntity = this.createTicker(blockEntity, ticker);
                         if (ticker1 != null) {
+                            // Canvas start
+                            if (blockEntity instanceof SleepingBlockEntity sleepingBlockEntity) {
+                                sleepingBlockEntity.lithium$setTickWrapper(ticker1);
+                            }
+                            // Canvas end
                             ticker1.rebind(tickingBlockEntity);
                             return (LevelChunk.RebindableTickingBlockEntityWrapper)ticker1;
                         } else if (this.isInLevel()) {
                             LevelChunk.RebindableTickingBlockEntityWrapper rebindableTickingBlockEntityWrapper = new LevelChunk.RebindableTickingBlockEntityWrapper(
                                 tickingBlockEntity
                             );
+                            // Canvas start
+                            if (blockEntity instanceof SleepingBlockEntity sleepingBlockEntity) {
+                                sleepingBlockEntity.lithium$setTickWrapper(rebindableTickingBlockEntityWrapper);
+                            }
+                            // Canvas end
                             this.level.addBlockEntityTicker(rebindableTickingBlockEntityWrapper);
                             return rebindableTickingBlockEntityWrapper;
                         } else {
@@ -904,6 +_,19 @@
             this.blockEntity = blockEntity;
             this.ticker = ticker;
         }
+        // Canvas start
+
+        private <T extends BlockEntity> void lagCompensation(Runnable original) {
+            original.run();
+            if (!Config.INSTANCE.lagCompensation.enabled) return;
+            if (!Config.INSTANCE.lagCompensation.blockEntityAcceleration) return;
+            if (LevelChunk.this.level.isClientSide()) return;
+
+            for (int i = 0; i < ((ServerLevel) this.blockEntity.getLevel()).tpsCalculator.applicableMissedTicks(); i++) {
+                original.run();
+            }
+        }
+        // Canvas end
 
         @Override
         public void tick() {
@@ -915,7 +_,11 @@
                         profilerFiller.push(this::getType);
                         BlockState blockState = LevelChunk.this.getBlockState(blockPos);
                         if (this.blockEntity.getType().isValid(blockState)) {
-                            this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), blockState, this.blockEntity);
+                            // Canvas start
+                            lagCompensation(() -> {
+                                this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), blockState, this.blockEntity);
+                            });
+                            // Canvas end
                             this.loggedInvalidBlockState = false;
                         // Paper start - Remove the Block Entity if it's invalid
                         } else {
@@ -972,14 +_,14 @@
         void run(LevelChunk chunk);
     }
 
-    static class RebindableTickingBlockEntityWrapper implements TickingBlockEntity {
-        private TickingBlockEntity ticker;
+    public static class RebindableTickingBlockEntityWrapper implements TickingBlockEntity { // Canvas - package-private -> public
+        public TickingBlockEntity ticker; // Canvas - private -> public
 
         RebindableTickingBlockEntityWrapper(TickingBlockEntity ticker) {
             this.ticker = ticker;
         }
 
-        void rebind(TickingBlockEntity ticker) {
+        public void rebind(TickingBlockEntity ticker) { // Canvas - package-private -> public
             this.ticker = ticker;
         }
 
