--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -16,7 +_,10 @@
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonObject;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.fastutil.Long2ByteConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
 import it.unimi.dsi.fastutil.longs.LongHeapPriorityQueue;
@@ -38,7 +_,7 @@
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
-import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -195,6 +_,13 @@
         final PlayerChunkLoaderData loader = new PlayerChunkLoaderData(this.world, player);
 
         ((ChunkSystemServerPlayer)player).moonrise$setChunkLoader(loader);
+        // Canvas start
+        int viewDistance = DistanceUtils.resolveViewDistance(this.world);
+        player.moonrise$getChunkLoader().updateClientChunkRadius(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this.world);
+        player.moonrise$getChunkLoader().updateClientSimulationDistance(simulationDistance - 1);
+        // Canvas end
         loader.add();
     }
 
@@ -301,7 +_,7 @@
         return false;
     }
 
-    public void tick() {
+    public synchronized void tick() { // Canvas
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
@@ -341,8 +_,8 @@
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+        private final ConcurrentSet<Long> sentChunks = new ConcurrentSet<>(); // Canvas - use concurrent equivalent
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -358,7 +_,7 @@
             GENERATED_TICKET_LEVEL,
             TICK_TICKET_LEVEL
         };
-        private final Long2ByteOpenHashMap chunkTicketStage = new Long2ByteOpenHashMap();
+        private final Long2ByteConcurrentHashMap chunkTicketStage = new Long2ByteConcurrentHashMap(); // Canvas - concurrent
         {
             this.chunkTicketStage.defaultReturnValue(CHUNK_TICKET_STAGE_NONE);
         }
@@ -380,10 +_,19 @@
             final int centerX = PlayerChunkLoaderData.this.lastChunkX;
             final int centerZ = PlayerChunkLoaderData.this.lastChunkZ;
 
+            // Canvas start
+            if (Config.INSTANCE.useEuclideanDistanceSquaredChunkPriorities) {
+                return Integer.compare(
+                    (c1x - centerX) * (c1x - centerX) + (c1z - centerZ) * (c1z - centerZ),
+                    (c2x - centerX) * (c2x - centerX) + (c2z - centerZ) * (c2z - centerZ)
+                );
+            } else {
             return Integer.compare(
                 Math.abs(c1x - centerX) + Math.abs(c1z - centerZ),
                 Math.abs(c2x - centerX) + Math.abs(c2z - centerZ)
             );
+            }
+            // Canvas end
         };
         private final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
         private final LongHeapPriorityQueue tickingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
@@ -486,7 +_,7 @@
             }
 
             @Override
-            protected void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) {
+            protected synchronized void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) { // Canvas
                 final long chunk = CoordinateUtils.getChunkKey(chunkX, chunkZ);
                 // note: by the time this is called, the tick cleanup should have ran - so, if the chunk is at
                 // the tick stage it was deemed in range for loading. Thus, we need to move it to generated
@@ -540,12 +_,12 @@
             );
         }
 
-        private Packet<?> updateClientChunkRadius(final int radius) {
+        public Packet<?> updateClientChunkRadius(final int radius) { // Canvas - private -> public
             this.lastSentChunkRadius = radius;
             return new ClientboundSetChunkCacheRadiusPacket(radius);
         }
 
-        private Packet<?> updateClientSimulationDistance(final int distance) {
+        public Packet<?> updateClientSimulationDistance(final int distance) { // Canvas - private -> public
             this.lastSentSimulationDistance = distance;
             return new ClientboundSetSimulationDistancePacket(distance);
         }
@@ -620,7 +_,7 @@
             return Math.max(Math.abs(dx), Math.abs(dz)) <= this.lastTickDistance;
         }
 
-        private boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) {
+        private synchronized boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) { // Canvas
             for (int dz = -radius; dz <= radius; ++dz) {
                 for (int dx = -radius; dx <= radius; ++dx) {
                     if ((dx | dz) == 0) {
@@ -639,19 +_,12 @@
             return true;
         }
 
-        void updateQueues(final long time) {
+        synchronized void updateQueues(final long time) { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
             }
-            // update rate limits
-            final double loadRate = this.getMaxChunkLoadRate();
-            final double genRate = this.getMaxChunkGenRate();
-            final double sendRate = this.getMaxChunkSendRate();
-
-            this.chunkLoadTicketLimiter.tickAllocation(time, loadRate, loadRate);
-            this.chunkGenerateTicketLimiter.tickAllocation(time, genRate, genRate);
-            this.chunkSendLimiter.tickAllocation(time, sendRate, sendRate);
+            // Canvas - optimize moonrise
 
             // try to progress chunk loads
             while (!this.loadingQueue.isEmpty()) {
@@ -678,8 +_,7 @@
             }
 
             // try to push more chunk loads
-            final long maxLoads = Math.max(0L, Math.min(MAX_RATE, Math.min(this.loadQueue.size(), this.getMaxChunkLoads())));
-            final int maxLoadsThisTick = (int)this.chunkLoadTicketLimiter.takeAllocation(time, loadRate, maxLoads);
+            final int maxLoadsThisTick = this.loadQueue.size(); // Canvas - optimize moonrise
             if (maxLoadsThisTick > 0) {
                 final LongArrayList chunks = new LongArrayList(maxLoadsThisTick);
                 for (int i = 0; i < maxLoadsThisTick; ++i) {
@@ -754,9 +_,7 @@
             }
 
             // try to push more chunk generations
-            final long maxGens = Math.max(0L, Math.min(MAX_RATE, Math.min(this.genQueue.size(), this.getMaxChunkGenerates())));
-            // preview the allocations, as we may not actually utilise all of them
-            final long maxGensThisTick = this.chunkGenerateTicketLimiter.previewAllocation(time, genRate, maxGens);
+            final long maxGensThisTick = this.genQueue.size(); // Canvas - optimize moonrise
             long ratedGensThisTick = 0L;
             while (!this.genQueue.isEmpty()) {
                 final long chunkKey = this.genQueue.firstLong();
@@ -786,8 +_,7 @@
                 );
                 this.generatingQueue.enqueue(chunkKey);
             }
-            // take the allocations we actually used
-            this.chunkGenerateTicketLimiter.takeAllocation(time, genRate, ratedGensThisTick);
+            // Canvas - optimize moonrise
 
             // try to pull ticking chunks
             while (!this.tickingQueue.isEmpty()) {
@@ -817,10 +_,10 @@
             }
 
             // try to pull sending chunks
-            final long maxSends = Math.max(0L, Math.min(MAX_RATE, Integer.MAX_VALUE)); // note: no logic to track concurrent sends
-            final int maxSendsThisTick = Math.min((int)this.chunkSendLimiter.takeAllocation(time, sendRate, maxSends), this.sendQueue.size());
+            final int maxSendsThisTick = Config.INSTANCE.chunks.chunkSending.rateLimitChunkSends == -1 ? this.sendQueue.size() : Config.INSTANCE.chunks.chunkSending.rateLimitChunkSends; // Canvas - optimize moonrise
             // we do not return sends that we took from the allocation back because we want to limit the max send rate, not target it
             for (int i = 0; i < maxSendsThisTick; ++i) {
+                if (this.sendQueue.isEmpty()) break; // Canvas - optimize moonrise
                 final long pendingSend = this.sendQueue.firstLong();
                 final int pendingSendX = CoordinateUtils.getChunkX(pendingSend);
                 final int pendingSendZ = CoordinateUtils.getChunkZ(pendingSend);
@@ -885,9 +_,7 @@
 
             // reset limiters, they will start at a zero allocation
             final long time = System.nanoTime();
-            this.chunkLoadTicketLimiter.reset(time);
-            this.chunkGenerateTicketLimiter.reset(time);
-            this.chunkSendLimiter.reset(time);
+            // Canvas - optimize moonrise
 
             // now we can update
             this.update();
@@ -906,7 +_,7 @@
             );
         }
 
-        void update() {
+        synchronized void update() { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
@@ -1086,7 +_,7 @@
         }
 
         public LongOpenHashSet getSentChunksRaw() {
-            return this.sentChunks;
+            return new LongOpenHashSet(this.sentChunks); // Canvas
         }
     }
 }
