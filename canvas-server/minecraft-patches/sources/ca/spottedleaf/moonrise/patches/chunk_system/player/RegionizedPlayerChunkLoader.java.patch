--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -16,6 +_,14 @@
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonObject;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
+import io.canvasmc.canvas.scheduler.TickScheduler;
+import io.canvasmc.canvas.server.level.distance.command.DistanceUtils;
+import io.canvasmc.canvas.util.fastutil.Long2ByteConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.Long2ByteMaps;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
@@ -39,6 +_,7 @@
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -189,21 +_,33 @@
         }
 
         if (((ChunkSystemServerPlayer)player).moonrise$getChunkLoader() != null) {
-            throw new IllegalStateException("Player is already added to player chunk loader");
+            return; // Canvas - already added, ignore.
         }
 
         final PlayerChunkLoaderData loader = new PlayerChunkLoaderData(this.world, player);
 
-        ((ChunkSystemServerPlayer)player).moonrise$setChunkLoader(loader);
+        // Canvas start
+        // ((ChunkSystemServerPlayer)player).moonrise$setChunkLoader(loader); // move down
+        int viewDistance = DistanceUtils.resolveViewDistance(this.world);
+        loader.updateClientChunkRadius(viewDistance - 1);
+
+        int simulationDistance = DistanceUtils.resolveSimulationDistance(this.world);
+        loader.updateClientSimulationDistance(simulationDistance - 1);
         loader.add();
+        // ensure everything is ready before we mark the chunk loader in the player
+        // this helps prevent a race condition where another thread is requesting
+        // data from the chunk loader, and it hasn't finished init yet.
+        // to fix this, we init before setting the chunk loader inside the player object
+        player.moonrise$setChunkLoader(loader);
+        // Canvas end
     }
 
     public void updatePlayer(final ServerPlayer player) {
         final PlayerChunkLoaderData loader = ((ChunkSystemServerPlayer)player).moonrise$getChunkLoader();
         if (loader != null) {
-            loader.update();
+            // loader.update(); // Canvas - no
             // update view distances for nearby players
-            ((ChunkSystemServerLevel)loader.world).moonrise$getNearbyPlayers().tickPlayer(player);
+            (loader.world).moonrise$getNearbyPlayers(player.chunkPosition()).tickPlayer(player); // Canvas - Threaded Regions
         }
     }
 
@@ -304,9 +_,9 @@
     public void tick() {
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
-        for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
+        for (final ServerPlayer player : new java.util.ArrayList<>(ServerRegions.getTickData(this.world).getLocalPlayers())) { // Canvas - Threaded Regions
             final PlayerChunkLoaderData loader = ((ChunkSystemServerPlayer)player).moonrise$getChunkLoader();
-            if (loader == null || loader.removed || loader.world != this.world) {
+            if (loader == null || loader.removed || loader.world != this.world || !loader.canTick) { // Canvas - can tick
                 // not our problem anymore
                 continue;
             }
@@ -325,6 +_,7 @@
 
         private final ServerPlayer player;
         private final ServerLevel world;
+        public volatile boolean canTick; // Canvas - can tick
 
         private int lastChunkX = Integer.MIN_VALUE;
         private int lastChunkZ = Integer.MIN_VALUE;
@@ -341,8 +_,8 @@
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas - concurrent
+        private final ConcurrentSet<Long> sentChunks = new ConcurrentSet<>(); // Canvas - concurrent
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -380,17 +_,28 @@
             final int centerX = PlayerChunkLoaderData.this.lastChunkX;
             final int centerZ = PlayerChunkLoaderData.this.lastChunkZ;
 
+            // Canvas start
+            if (Config.INSTANCE.chunks.generation.useEuclideanDistanceSquaredChunkPriorities) {
+                return Integer.compare(
+                    (c1x - centerX) * (c1x - centerX) + (c1z - centerZ) * (c1z - centerZ),
+                    (c2x - centerX) * (c2x - centerX) + (c2z - centerZ) * (c2z - centerZ)
+                );
+            } else {
             return Integer.compare(
                 Math.abs(c1x - centerX) + Math.abs(c1z - centerZ),
                 Math.abs(c2x - centerX) + Math.abs(c2z - centerZ)
             );
+            }
+            // Canvas end
         };
-        private final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue tickingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue generatingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue genQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue loadingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
-        private final LongHeapPriorityQueue loadQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        // Canvas start - private -> public
+        public final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue tickingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue generatingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue genQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue loadingQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        public final LongHeapPriorityQueue loadQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
+        // Canvas end
 
         private volatile boolean removed;
 
@@ -411,7 +_,7 @@
             this.delayedTicketOps.addLast(op);
         }
 
-        private void sendChunk(final int chunkX, final int chunkZ) {
+        public void sendChunk(final int chunkX, final int chunkZ) { // Canvas - private -> public
             if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 ((ChunkSystemChunkHolder)((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().chunkHolderManager
                         .getChunkHolder(chunkX, chunkZ).vanillaChunkHolder).moonrise$addReceivedChunk(this.player);
@@ -425,7 +_,7 @@
             throw new IllegalStateException();
         }
 
-        private void sendUnloadChunk(final int chunkX, final int chunkZ) {
+        public void sendUnloadChunk(final int chunkX, final int chunkZ) { // Canvas - private -> public
             if (!this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 return;
             }
@@ -540,12 +_,12 @@
             );
         }
 
-        private Packet<?> updateClientChunkRadius(final int radius) {
+        public Packet<?> updateClientChunkRadius(final int radius) { // Canvas - private -> public
             this.lastSentChunkRadius = radius;
             return new ClientboundSetChunkCacheRadiusPacket(radius);
         }
 
-        private Packet<?> updateClientSimulationDistance(final int distance) {
+        public Packet<?> updateClientSimulationDistance(final int distance) { // Canvas - private -> public
             this.lastSentSimulationDistance = distance;
             return new ClientboundSetSimulationDistancePacket(distance);
         }
@@ -639,10 +_,10 @@
             return true;
         }
 
-        void updateQueues(final long time) {
+        void updateQueues(final long time) {
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
-                throw new IllegalStateException("Ticking removed player chunk loader");
+                return; // Canvas - this can change mid-update, so we may crash even though previously this was fine. just return.
             }
             // update rate limits
             final double loadRate = this.getMaxChunkLoadRate();
@@ -669,7 +_,7 @@
                 // try to move to generate queue
                 final byte prev = this.chunkTicketStage.put(pendingLoadChunk, CHUNK_TICKET_STAGE_LOADED);
                 if (prev != CHUNK_TICKET_STAGE_LOADING) {
-                    throw new IllegalStateException("Previous state should be " + CHUNK_TICKET_STAGE_LOADING + ", not " + prev);
+                    continue; // Canvas - just skip
                 }
 
                 if (this.canGenerateChunks || this.isLoadedChunkGeneratable(pending)) {
@@ -679,14 +_,14 @@
 
             // try to push more chunk loads
             final long maxLoads = Math.max(0L, Math.min(MAX_RATE, Math.min(this.loadQueue.size(), this.getMaxChunkLoads())));
-            final int maxLoadsThisTick = (int)this.chunkLoadTicketLimiter.takeAllocation(time, loadRate, maxLoads);
+            final int maxLoadsThisTick = Config.INSTANCE.chunks.rateLimiters.disableChunkLoadRateLimiter ? (int) maxLoads : (int)this.chunkLoadTicketLimiter.takeAllocation(time, loadRate, maxLoads); // Canvas - allow disabling rate limiters
             if (maxLoadsThisTick > 0) {
                 final LongArrayList chunks = new LongArrayList(maxLoadsThisTick);
                 for (int i = 0; i < maxLoadsThisTick; ++i) {
                     final long chunk = this.loadQueue.dequeueLong();
                     final byte prev = this.chunkTicketStage.put(chunk, CHUNK_TICKET_STAGE_LOADING);
                     if (prev != CHUNK_TICKET_STAGE_NONE) {
-                        throw new IllegalStateException("Previous state should be " + CHUNK_TICKET_STAGE_NONE + ", not " + prev);
+                        continue; // Canvas - just skip
                     }
                     this.pushDelayedTicketOp(
                         ChunkHolderManager.TicketOperation.addOp(
@@ -740,7 +_,7 @@
 
                 final byte prev = this.chunkTicketStage.put(pendingGenChunk, CHUNK_TICKET_STAGE_GENERATED);
                 if (prev != CHUNK_TICKET_STAGE_GENERATING) {
-                    throw new IllegalStateException("Previous state should be " + CHUNK_TICKET_STAGE_GENERATING + ", not " + prev);
+                    continue; // Canvas - just skip
                 }
 
                 // try to move to send queue
@@ -756,7 +_,7 @@
             // try to push more chunk generations
             final long maxGens = Math.max(0L, Math.min(MAX_RATE, Math.min(this.genQueue.size(), this.getMaxChunkGenerates())));
             // preview the allocations, as we may not actually utilise all of them
-            final long maxGensThisTick = this.chunkGenerateTicketLimiter.previewAllocation(time, genRate, maxGens);
+            final long maxGensThisTick = Config.INSTANCE.chunks.rateLimiters.disableChunkGenRateLimiter ? maxGens : this.chunkGenerateTicketLimiter.previewAllocation(time, genRate, maxGens); // Canvas - allow disabling rate limiters
             long ratedGensThisTick = 0L;
             while (!this.genQueue.isEmpty()) {
                 final long chunkKey = this.genQueue.firstLong();
@@ -775,7 +_,7 @@
 
                 final byte prev = this.chunkTicketStage.put(chunkKey, CHUNK_TICKET_STAGE_GENERATING);
                 if (prev != CHUNK_TICKET_STAGE_LOADED) {
-                    throw new IllegalStateException("Previous state should be " + CHUNK_TICKET_STAGE_LOADED + ", not " + prev);
+                    continue; // Canvas - just skip
                 }
                 this.pushDelayedTicketOp(
                     ChunkHolderManager.TicketOperation.addAndRemove(
@@ -812,13 +_,13 @@
                 // note: there is no queue to add after ticking
                 final byte prev = this.chunkTicketStage.put(pendingTicking, CHUNK_TICKET_STAGE_TICK);
                 if (prev != CHUNK_TICKET_STAGE_GENERATED) {
-                    throw new IllegalStateException("Previous state should be " + CHUNK_TICKET_STAGE_GENERATED + ", not " + prev);
+                    continue; // Canvas - just skip
                 }
             }
 
             // try to pull sending chunks
             final long maxSends = Math.max(0L, Math.min(MAX_RATE, Integer.MAX_VALUE)); // note: no logic to track concurrent sends
-            final int maxSendsThisTick = Math.min((int)this.chunkSendLimiter.takeAllocation(time, sendRate, maxSends), this.sendQueue.size());
+            final int maxSendsThisTick = Config.INSTANCE.chunks.rateLimiters.disableChunkSendRateLimiter ? this.sendQueue.size() : Math.min((int)this.chunkSendLimiter.takeAllocation(time, sendRate, maxSends), this.sendQueue.size()); // Canvas - allow disabling rate limiters
             // we do not return sends that we took from the allocation back because we want to limit the max send rate, not target it
             for (int i = 0; i < maxSendsThisTick; ++i) {
                 final long pendingSend = this.sendQueue.firstLong();
@@ -832,7 +_,7 @@
                 }
                 if (!((ChunkSystemLevelChunk)chunk).moonrise$isPostProcessingDone()) {
                     // not yet post-processed, need to do this so that tile entities can properly be sent to clients
-                    chunk.postProcessGeneration(this.world);
+                    if (!Config.INSTANCE.ticking.enableThreadedRegionizing) chunk.postProcessGeneration(this.world); // Canvas - Threaded Regions - this needs to be run on the region thread.
                     // check if there was any recursive action
                     if (this.removed || this.sendQueue.isEmpty() || this.sendQueue.firstLong() != pendingSend) {
                         return;
@@ -852,6 +_,7 @@
         }
 
         void add() {
+            this.canTick = false; // Canvas - can tick
             TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Adding removed player chunk loader");
@@ -891,6 +_,7 @@
 
             // now we can update
             this.update();
+            this.canTick = true; // Canvas - can tick
         }
 
         private boolean isLoadedChunkGeneratable(final int chunkX, final int chunkZ) {
@@ -909,7 +_,7 @@
         void update() {
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
-                throw new IllegalStateException("Updating removed player chunk loader");
+                return; // Canvas - just return...
             }
             final ViewDistances playerDistances = ((ChunkSystemServerPlayer)this.player).moonrise$getViewDistanceHolder().getViewDistances();
             final ViewDistances worldDistances = ((ChunkSystemServerLevel)this.world).moonrise$getViewDistanceHolder().getViewDistances();
@@ -1059,6 +_,7 @@
         }
 
         void remove() {
+            this.canTick = false; // Canvas - can tick
             TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Removing removed player chunk loader");
@@ -1086,7 +_,7 @@
         }
 
         public LongOpenHashSet getSentChunksRaw() {
-            return this.sentChunks;
+            return new LongOpenHashSet(this.sentChunks); // Canvas
         }
     }
 }
