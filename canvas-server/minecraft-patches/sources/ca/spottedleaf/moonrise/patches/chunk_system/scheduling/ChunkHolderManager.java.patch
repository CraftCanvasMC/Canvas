--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -20,6 +_,8 @@
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.server.chunk.DynamicChunkPosLongSet;
+import io.canvasmc.canvas.util.ConcurrentLinkedDequeTree;
 import it.unimi.dsi.fastutil.longs.Long2ByteLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -40,16 +_,26 @@
 import net.minecraft.util.Unit;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import org.agrona.collections.Long2ObjectHashMap;
+import org.agrona.collections.Object2ObjectHashMap;
+import org.agrona.collections.ObjectHashSet;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.PrimitiveIterator;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -71,36 +_,17 @@
     private static final long PROBE_MARKER = Long.MIN_VALUE + 1;
     public final ReentrantAreaLock ticketLockArea;
 
-    private final ConcurrentLong2ReferenceChainedHashTable<SortedArraySet<Ticket<?>>> tickets = new ConcurrentLong2ReferenceChainedHashTable<>();
-    private final ConcurrentLong2ReferenceChainedHashTable<Long2IntOpenHashMap> sectionToChunkToExpireCount = new ConcurrentLong2ReferenceChainedHashTable<>();
+    private final Map<Long, SortedArraySet<Ticket<?>>> tickets = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas - synchronized
+    private final Map<Long, Long2IntOpenHashMap> sectionToChunkToExpireCount = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas - synchronized
     final ChunkUnloadQueue unloadQueue;
 
-    private final ConcurrentLong2ReferenceChainedHashTable<NewChunkHolder> chunkHolders = ConcurrentLong2ReferenceChainedHashTable.createWithCapacity(16384, 0.25f);
+    private final Map<Long, NewChunkHolder> chunkHolders = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas - synchronized
     private final ServerLevel world;
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
-        }
-
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
-
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
-        }
-
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
-
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
-        }
-
-        return Long.compare(coord1, coord2);
-    });
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas - concurrent
+    private final ConcurrentLinkedDequeTree<NewChunkHolder> autoSaveQueue = new ConcurrentLinkedDequeTree<>(); // Canvas - replace ObjectRBTreeSet with DequeTree
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -145,7 +_,7 @@
 
     public List<ChunkHolder> getOldChunkHolders() {
         final List<ChunkHolder> ret = new ArrayList<>(this.chunkHolders.size() + 1);
-        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.valueIterator(); iterator.hasNext();) {
+        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.values().iterator(); iterator.hasNext();) { // Canvas
             ret.add(iterator.next().vanillaChunkHolder);
         }
         return ret;
@@ -153,7 +_,7 @@
 
     public List<NewChunkHolder> getChunkHolders() {
         final List<NewChunkHolder> ret = new ArrayList<>(this.chunkHolders.size() + 1);
-        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.valueIterator(); iterator.hasNext();) {
+        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.values().iterator(); iterator.hasNext();) { // Canvas
             ret.add(iterator.next());
         }
         return ret;
@@ -168,7 +_,7 @@
         return new Iterable<ChunkHolder>() {
             @Override
             public Iterator<ChunkHolder> iterator() {
-                final Iterator<NewChunkHolder> iterator = ChunkHolderManager.this.chunkHolders.valueIterator();
+                final Iterator<NewChunkHolder> iterator = ChunkHolderManager.this.chunkHolders.values().iterator(); // Canvas
                 return new Iterator<ChunkHolder>() {
                     @Override
                     public boolean hasNext() {
@@ -317,7 +_,7 @@
             }
             if (logProgress) {
                 final long currTime = System.nanoTime();
-                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
+                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(5L)) { // Canvas - log progress a bit more
                     lastLog = currTime;
                     LOGGER.info(
                             "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
@@ -425,8 +_,10 @@
         final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> ret = new Long2ObjectOpenHashMap<>();
         final Long2ObjectOpenHashMap<LongArrayList> sections = new Long2ObjectOpenHashMap<>();
         final int sectionShift = this.taskScheduler.getChunkSystemLockShift();
-        for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
-            final long coord = iterator.nextLong();
+        // Canvas start
+        for (final Iterator<Long> iterator = this.tickets.keySet().iterator(); iterator.hasNext();) {
+            final long coord = iterator.next();
+        // Canvas end
             sections.computeIfAbsent(
                 CoordinateUtils.getChunkKey(
                     CoordinateUtils.getChunkX(coord) >> sectionShift,
@@ -523,7 +_,7 @@
             chunkZ >> sectionShift
         );
 
-        this.sectionToChunkToExpireCount.computeIfAbsent(sectionKey, (final long keyInMap) -> {
+        this.sectionToChunkToExpireCount.computeIfAbsent(sectionKey, (keyInMap) -> { // Canvas
             return new Long2IntOpenHashMap();
         }).addTo(chunkKey, 1);
     }
@@ -567,7 +_,7 @@
 
         final ReentrantAreaLock.Node ticketLock = lock ? this.ticketLockArea.lock(chunkX, chunkZ) : null;
         try {
-            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (final long keyInMap) -> {
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (keyInMap) -> { // Canvas
                 return SortedArraySet.create(4);
             });
 
@@ -697,8 +_,10 @@
 
         final Long2ObjectOpenHashMap<LongArrayList> sections = new Long2ObjectOpenHashMap<>();
         final int sectionShift = this.taskScheduler.getChunkSystemLockShift();
-        for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
-            final long coord = iterator.nextLong();
+        // Canvas start
+        for (final Iterator<Long> iterator = this.tickets.keySet().iterator(); iterator.hasNext();) {
+            final long coord = iterator.next();
+        // Canvas end
             sections.computeIfAbsent(
                     CoordinateUtils.getChunkKey(
                             CoordinateUtils.getChunkX(coord) >> sectionShift,
@@ -746,8 +_,8 @@
             return removeDelay <= 0L;
         };
 
-        for (final PrimitiveIterator.OfLong iterator = this.sectionToChunkToExpireCount.keyIterator(); iterator.hasNext();) {
-            final long sectionKey = iterator.nextLong();
+        for (final Iterator<Long> iterator = this.sectionToChunkToExpireCount.keySet().iterator(); iterator.hasNext();) { // Canvas
+            final long sectionKey = iterator.next(); // Canvas
 
             if (!this.sectionToChunkToExpireCount.containsKey(sectionKey)) {
                 // removed concurrently
@@ -1033,7 +_,7 @@
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final Deque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1041,7 +_,7 @@
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1207,6 +_,26 @@
             }
         }
     }
+    // Canvas start - if theres lots of chunks loaded, we don't want to search through that map to find block ticking holders or entity ticking holders, so we cache the ones that are valid to limit the search
+    public final Set<Long> blockTickingChunkHolders = Collections.synchronizedSet(new ObjectHashSet<>(1384, 0.75f));
+    public final Set<Long> entityTickingChunkHolders = Collections.synchronizedSet(new ObjectHashSet<>(1384, 0.75f));
+
+    public void markBlockTicking(@NotNull NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonBlockTickingIfPossible(@NotNull NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markEntityTicking(@NotNull NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonEntityTickingIfPossible(@NotNull NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+    // Canvas end
 
     public enum TicketOperationType {
         ADD, REMOVE, ADD_IF_REMOVED, ADD_AND_REMOVE
@@ -1381,7 +_,7 @@
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
@@ -1417,9 +_,10 @@
         final JsonArray allTicketsJson = new JsonArray();
         ret.add("tickets", allTicketsJson);
 
-        for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.entryIterator();
-            iterator.hasNext();) {
-            final ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>> coordinateTickets = iterator.next();
+        // Canvas start
+        for (final Iterator<Map.Entry<Long, SortedArraySet<Ticket<?>>>> iterator = this.tickets.entrySet().iterator(); iterator.hasNext();) {
+            final Map.Entry<Long, SortedArraySet<Ticket<?>>> coordinateTickets = iterator.next();
+        // Canvas end
             final long coordinate = coordinateTickets.getKey();
             final SortedArraySet<Ticket<?>> tickets = coordinateTickets.getValue();
 
