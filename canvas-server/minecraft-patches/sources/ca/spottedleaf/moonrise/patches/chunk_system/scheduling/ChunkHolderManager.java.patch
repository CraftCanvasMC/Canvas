--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -20,6 +_,8 @@
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.server.chunk.DynamicChunkPosLongSet;
+import io.canvasmc.canvas.util.ConcurrentLinkedDequeTree;
 import it.unimi.dsi.fastutil.longs.Long2ByteLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -40,16 +_,26 @@
 import net.minecraft.util.Unit;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import org.agrona.collections.Long2ObjectHashMap;
+import org.agrona.collections.Object2ObjectHashMap;
+import org.agrona.collections.ObjectHashSet;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.PrimitiveIterator;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -71,36 +_,17 @@
     private static final long PROBE_MARKER = Long.MIN_VALUE + 1;
     public final ReentrantAreaLock ticketLockArea;
 
-    private final ConcurrentLong2ReferenceChainedHashTable<SortedArraySet<Ticket<?>>> tickets = new ConcurrentLong2ReferenceChainedHashTable<>();
-    private final ConcurrentLong2ReferenceChainedHashTable<Long2IntOpenHashMap> sectionToChunkToExpireCount = new ConcurrentLong2ReferenceChainedHashTable<>();
+    private final Map<Long, SortedArraySet<Ticket<?>>> tickets = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas
+    private final Map<Long, Long2IntOpenHashMap> sectionToChunkToExpireCount = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas
     final ChunkUnloadQueue unloadQueue;
 
-    private final ConcurrentLong2ReferenceChainedHashTable<NewChunkHolder> chunkHolders = ConcurrentLong2ReferenceChainedHashTable.createWithCapacity(16384, 0.25f);
+    private final Map<Long, NewChunkHolder> chunkHolders = Collections.synchronizedMap(new Long2ObjectHashMap<>(20, 0.9F)); // Canvas
     private final ServerLevel world;
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
-        }
-
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
-
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
-        }
-
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
-
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
-        }
-
-        return Long.compare(coord1, coord2);
-    });
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+    private final ConcurrentLinkedDequeTree<NewChunkHolder> autoSaveQueue = new ConcurrentLinkedDequeTree<>(); // Canvas - use our version
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -145,7 +_,7 @@
 
     public List<ChunkHolder> getOldChunkHolders() {
         final List<ChunkHolder> ret = new ArrayList<>(this.chunkHolders.size() + 1);
-        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.valueIterator(); iterator.hasNext();) {
+        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.values().iterator(); iterator.hasNext();) { // Canvas
             ret.add(iterator.next().vanillaChunkHolder);
         }
         return ret;
@@ -153,7 +_,7 @@
 
     public List<NewChunkHolder> getChunkHolders() {
         final List<NewChunkHolder> ret = new ArrayList<>(this.chunkHolders.size() + 1);
-        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.valueIterator(); iterator.hasNext();) {
+        for (final Iterator<NewChunkHolder> iterator = this.chunkHolders.values().iterator(); iterator.hasNext();) { // Canvas
             ret.add(iterator.next());
         }
         return ret;
@@ -168,7 +_,7 @@
         return new Iterable<ChunkHolder>() {
             @Override
             public Iterator<ChunkHolder> iterator() {
-                final Iterator<NewChunkHolder> iterator = ChunkHolderManager.this.chunkHolders.valueIterator();
+                final Iterator<NewChunkHolder> iterator = ChunkHolderManager.this.chunkHolders.values().iterator(); // Canvas
                 return new Iterator<ChunkHolder>() {
                     @Override
                     public boolean hasNext() {
@@ -317,7 +_,7 @@
             }
             if (logProgress) {
                 final long currTime = System.nanoTime();
-                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
+                if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(4L)) { // Canvas - Threaded Dimensions
                     lastLog = currTime;
                     LOGGER.info(
                             "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
@@ -425,8 +_,10 @@
         final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> ret = new Long2ObjectOpenHashMap<>();
         final Long2ObjectOpenHashMap<LongArrayList> sections = new Long2ObjectOpenHashMap<>();
         final int sectionShift = this.taskScheduler.getChunkSystemLockShift();
-        for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
-            final long coord = iterator.nextLong();
+        // Canvas start
+        for (final Iterator<Long> iterator = this.tickets.keySet().iterator(); iterator.hasNext();) {
+            final long coord = iterator.next();
+        // Canvas end
             sections.computeIfAbsent(
                 CoordinateUtils.getChunkKey(
                     CoordinateUtils.getChunkX(coord) >> sectionShift,
@@ -523,7 +_,7 @@
             chunkZ >> sectionShift
         );
 
-        this.sectionToChunkToExpireCount.computeIfAbsent(sectionKey, (final long keyInMap) -> {
+        this.sectionToChunkToExpireCount.computeIfAbsent(sectionKey, (keyInMap) -> { // Canvas
             return new Long2IntOpenHashMap();
         }).addTo(chunkKey, 1);
     }
@@ -567,7 +_,7 @@
 
         final ReentrantAreaLock.Node ticketLock = lock ? this.ticketLockArea.lock(chunkX, chunkZ) : null;
         try {
-            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (final long keyInMap) -> {
+            final SortedArraySet<Ticket<?>> ticketsAtChunk = this.tickets.computeIfAbsent(chunk, (keyInMap) -> { // Canvas
                 return SortedArraySet.create(4);
             });
 
@@ -697,8 +_,10 @@
 
         final Long2ObjectOpenHashMap<LongArrayList> sections = new Long2ObjectOpenHashMap<>();
         final int sectionShift = this.taskScheduler.getChunkSystemLockShift();
-        for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
-            final long coord = iterator.nextLong();
+        // Canvas start
+        for (final Iterator<Long> iterator = this.tickets.keySet().iterator(); iterator.hasNext();) {
+            final long coord = iterator.next();
+        // Canvas end
             sections.computeIfAbsent(
                     CoordinateUtils.getChunkKey(
                             CoordinateUtils.getChunkX(coord) >> sectionShift,
@@ -746,8 +_,8 @@
             return removeDelay <= 0L;
         };
 
-        for (final PrimitiveIterator.OfLong iterator = this.sectionToChunkToExpireCount.keyIterator(); iterator.hasNext();) {
-            final long sectionKey = iterator.nextLong();
+        for (final Iterator<Long> iterator = this.sectionToChunkToExpireCount.keySet().iterator(); iterator.hasNext();) { // Canvas
+            final long sectionKey = iterator.next(); // Canvas
 
             if (!this.sectionToChunkToExpireCount.containsKey(sectionKey)) {
                 // removed concurrently
@@ -1033,7 +_,7 @@
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final Deque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1041,7 +_,7 @@
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1207,6 +_,26 @@
             }
         }
     }
+    // Canvas start
+    public final Set<Long> blockTickingChunkHolders = Collections.synchronizedSet(new ObjectHashSet<>(1384, 0.75f));
+    public final Set<Long> entityTickingChunkHolders = Collections.synchronizedSet(new ObjectHashSet<>(1384, 0.75f));
+
+    public void markBlockTicking(@NotNull NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonBlockTickingIfPossible(@NotNull NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markEntityTicking(@NotNull NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonEntityTickingIfPossible(@NotNull NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+    // Canvas end
 
     public enum TicketOperationType {
         ADD, REMOVE, ADD_IF_REMOVED, ADD_AND_REMOVE
@@ -1381,7 +_,7 @@
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
@@ -1417,9 +_,10 @@
         final JsonArray allTicketsJson = new JsonArray();
         ret.add("tickets", allTicketsJson);
 
-        for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.entryIterator();
-            iterator.hasNext();) {
-            final ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>> coordinateTickets = iterator.next();
+        // Canvas start
+        for (final Iterator<Map.Entry<Long, SortedArraySet<Ticket<?>>>> iterator = this.tickets.entrySet().iterator(); iterator.hasNext();) {
+            final Map.Entry<Long, SortedArraySet<Ticket<?>>> coordinateTickets = iterator.next();
+        // Canvas end
             final long coordinate = coordinateTickets.getKey();
             final SortedArraySet<Ticket<?>> tickets = coordinateTickets.getValue();
 
