From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Wed, 15 Jan 2025 02:24:36 -0800
Subject: [PATCH] Threaded Dimensions


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index d21ce54ebb5724c04eadf56a2cde701d5eeb5db2..d9fad142bded299cb185ddb58adf2438459e65d2 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -28,6 +28,10 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 
 public final class ChunkEntitySlices {
@@ -40,9 +44,11 @@ public final class ChunkEntitySlices {
 
     private final EntityCollectionBySection allEntities;
     private final EntityCollectionBySection hardCollidingEntities;
-    private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
-    private final EntityList entities = new EntityList();
+    // Canvas start - use concurrent equivalent
+    private final ConcurrentHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+    private final ConcurrentHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
+    private final List<Entity> entities = new CopyOnWriteArrayList<>();
+    // Canvas end
 
     public FullChunkStatus status;
     public final ChunkData chunkData;
@@ -67,8 +73,10 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
-        this.entitiesByType = new Reference2ObjectOpenHashMap<>();
+        // Canvas start - use concurrent equivalent
+        this.entitiesByClass = new ConcurrentHashMap<>();
+        this.entitiesByType = new ConcurrentHashMap<>();
+        // Canvas end
 
         this.status = status;
         this.chunkData = chunkData;
@@ -134,7 +142,7 @@ public final class ChunkEntitySlices {
             return null;
         }
 
-        final Entity[] rawData = this.entities.getRawData();
+        final Entity[] rawData = this.entities.toArray(new Entity[0]);
         final List<Entity> collectedEntities = new ArrayList<>(len);
         for (int i = 0; i < len; ++i) {
             final Entity entity = rawData[i];
@@ -153,7 +161,7 @@ public final class ChunkEntitySlices {
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
         final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+        final Entity[] collectedEntities = Arrays.copyOf(this.entities.toArray(new Entity[0]), len);
 
         for (int i = 0; i < len; ++i) {
             final Entity entity = collectedEntities[i];
@@ -182,7 +190,7 @@ public final class ChunkEntitySlices {
             return new ArrayList<>();
         }
 
-        final Entity[] rawData = this.entities.getRawData();
+        final Entity[] rawData = this.entities.toArray(new Entity[0]);
         final List<Entity> collectedEntities = new ArrayList<>(len);
         for (int i = 0; i < len; ++i) {
             collectedEntities.add(rawData[i]);
@@ -196,7 +204,7 @@ public final class ChunkEntitySlices {
     }
 
     public void mergeInto(final ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
+        final Entity[] entities = this.entities.toArray(new Entity[0]);
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
             final Entity entity = entities[i];
             slices.addEntity(entity, ((ChunkSystemEntity)entity).moonrise$getSectionY());
@@ -221,7 +229,7 @@ public final class ChunkEntitySlices {
     public void updateStatus(final FullChunkStatus status, final EntityLookup lookup) {
         this.status = status;
 
-        final Entity[] entities = this.entities.getRawData();
+        final Entity[] entities = this.entities.toArray(new Entity[0]);
 
         for (int i = 0, size = this.entities.size(); i < size; ++i) {
             final Entity entity = entities[i];
@@ -248,10 +256,7 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().addEntity(entity, sectionIndex);
             }
@@ -282,10 +287,7 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().removeEntity(entity, sectionIndex);
             }
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index 7554c109c35397bc1a43dd80e87764fd78645bbf..ce56130201025457d7aad64740b9e5d59adb1dea 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -8,6 +8,7 @@ import ca.spottedleaf.moonrise.common.util.WorldUtil;
 import ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -30,6 +31,7 @@ import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -190,6 +192,12 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             return Arrays.copyOf(this.accessibleEntities.getRawData(), this.accessibleEntities.size(), Entity[].class);
         }
     }
+    // Canvas start
+
+    public int entityCount() {
+        return this.accessibleEntities.size();
+    }
+    // Canvas end
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AbortableIterationConsumer<U> action) {
@@ -226,6 +234,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             }
         }
     }
+    private ConcurrentLinkedQueue<Runnable> statusChangesQue = new ConcurrentLinkedQueue<>(); // Canvas
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
@@ -233,14 +242,15 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
         if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
             // recursive status update
-            LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
+            // LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable()); // Canvas - silence.
             return;
         }
 
         final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
 
         if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            // LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable()); // Canvas
+            statusChangesQue.add(() -> entityStatusChange(entity, slices, oldVisibility, newVisibility, moved, created, destroyed)); // Canvas
             return;
         }
 
@@ -322,6 +332,11 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         } finally {
             if (slices != null) {
                 slices.stopPreventingStatusUpdates(false);
+                // Canvas start
+                ConcurrentLinkedQueue<Runnable> clone = new ConcurrentLinkedQueue<>(statusChangesQue);
+                statusChangesQue.clear();
+                clone.forEach(Runnable::run);
+                // Canvas end
             }
         }
     }
@@ -474,7 +489,13 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
         } else {
             if (slices.isPreventingStatusUpdates()) {
-                throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas start
+               ((ServerLevel)entity.level()).taskScheduler.schedule(() -> {
+                    removeEntity(entity);
+                });
+                return;
+                // throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas end
             }
             if (!slices.removeEntity(entity, sectionY)) {
                 LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
@@ -510,7 +531,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         }
     }
 
-    protected ChunkEntitySlices moveEntity(final Entity entity) {
+    protected synchronized ChunkEntitySlices moveEntity(final Entity entity) { // Canvas
         // ensure we own the entity
         this.checkThread(entity, "Cannot move entity off-main");
 
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index dd2509996bfd08e8c3f9f2be042229eac6d7692d..02f2e84e8de17365169a2535a7d36d6b741d4e57 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -16,6 +16,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManage
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonObject;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
@@ -39,6 +40,7 @@ import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -301,7 +303,7 @@ public final class RegionizedPlayerChunkLoader {
         return false;
     }
 
-    public void tick() {
+    public synchronized void tick() { // Canvas
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
@@ -341,8 +343,8 @@ public final class RegionizedPlayerChunkLoader {
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+        private final ConcurrentSet<Long> sentChunks = new ConcurrentSet<>(); // Canvas - use concurrent equivalent
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -486,7 +488,7 @@ public final class RegionizedPlayerChunkLoader {
             }
 
             @Override
-            protected void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) {
+            protected synchronized void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) { // Canvas
                 final long chunk = CoordinateUtils.getChunkKey(chunkX, chunkZ);
                 // note: by the time this is called, the tick cleanup should have ran - so, if the chunk is at
                 // the tick stage it was deemed in range for loading. Thus, we need to move it to generated
@@ -620,7 +622,7 @@ public final class RegionizedPlayerChunkLoader {
             return Math.max(Math.abs(dx), Math.abs(dz)) <= this.lastTickDistance;
         }
 
-        private boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) {
+        private synchronized boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) { // Canvas
             for (int dz = -radius; dz <= radius; ++dz) {
                 for (int dx = -radius; dx <= radius; ++dx) {
                     if ((dx | dz) == 0) {
@@ -639,7 +641,7 @@ public final class RegionizedPlayerChunkLoader {
             return true;
         }
 
-        void updateQueues(final long time) {
+        synchronized void updateQueues(final long time) { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
@@ -906,7 +908,7 @@ public final class RegionizedPlayerChunkLoader {
             );
         }
 
-        void update() {
+        synchronized void update() { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
@@ -1086,7 +1088,7 @@ public final class RegionizedPlayerChunkLoader {
         }
 
         public LongOpenHashSet getSentChunksRaw() {
-            return this.sentChunks;
+            return new LongOpenHashSet(this.sentChunks); // Canvas
         }
     }
 }
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index b5817aa8f537593f6d9fc6b612c82ccccb250ac7..40c3bb30f86c3103206201bbd4ec5be2969637f0 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -20,6 +20,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.util.ChunkSystemSortedArrayS
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.util.ConcurrentLinkedDequeTree;
 import it.unimi.dsi.fastutil.longs.Long2ByteLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -46,10 +47,12 @@ import java.text.DecimalFormat;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.PrimitiveIterator;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -80,27 +83,8 @@ public final class ChunkHolderManager {
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
-        }
-
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
-
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
-        }
-
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
-
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
-        }
-
-        return Long.compare(coord1, coord2);
-    });
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+    private final ConcurrentLinkedDequeTree<NewChunkHolder> autoSaveQueue = new ConcurrentLinkedDequeTree<>(); // Canvas - use our version
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -1033,7 +1017,7 @@ public final class ChunkHolderManager {
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final Deque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1041,7 +1025,7 @@ public final class ChunkHolderManager {
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1381,7 +1365,7 @@ public final class ChunkHolderManager {
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
diff --git a/net/minecraft/core/BlockPos.java b/net/minecraft/core/BlockPos.java
index 6518d3fff6daf331b24a7bf5b39fa1920b73711d..2c5251fab0d4ef9ea85f07178f8aae7349c932b5 100644
--- a/net/minecraft/core/BlockPos.java
+++ b/net/minecraft/core/BlockPos.java
@@ -28,6 +28,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.Validate;
 import org.apache.commons.lang3.tuple.Pair;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 @Immutable
@@ -223,7 +224,7 @@ public class BlockPos extends Vec3i {
     }
 
     @Override
-    public BlockPos relative(Direction direction) {
+    public synchronized @NotNull BlockPos relative(Direction direction) { // Canvas
         // Paper start - Perf: Optimize BlockPosition
         switch(direction) {
             case UP:
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 3baf29818d82aa7ba1cc565aaeb26288e5a23a33..9d975d8b20f558c3ed6894b14f8d0fb67c67c4da 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -38,6 +38,7 @@ import java.nio.channels.ClosedChannelException;
 import java.util.Objects;
 import java.util.Queue;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -59,6 +60,7 @@ import net.minecraft.network.protocol.login.LoginProtocols;
 import net.minecraft.network.protocol.status.ClientStatusPacketListener;
 import net.minecraft.network.protocol.status.StatusProtocols;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
 import net.minecraft.util.debugchart.LocalSampleLogger;
 import org.apache.commons.lang3.Validate;
@@ -231,6 +233,23 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         if (net.minecraft.server.MinecraftServer.getServer().isDebugging()) io.papermc.paper.util.TraceUtil.printStackTrace(exception); // Spigot // Paper
     }
+    // Canvas start - threaded connections
+    private AtomicReference<ServerLevel> holdingLevel = new AtomicReference<>(null);
+
+    public void transferToLevel(ServerLevel level) {
+        if (holdingLevel.get() != null) {
+            // Player was on a diff world before, remove from previous context
+            level.removeConnection(this);
+        }
+        holdingLevel.set(level);
+        level.notifyNewConnection(this);
+    }
+
+    @Nullable
+    public ServerLevel getHoldingLevel() {
+        return holdingLevel.get();
+    }
+    // Canvas end
 
     @Override
     protected void channelRead0(ChannelHandlerContext context, Packet<?> packet) {
diff --git a/net/minecraft/network/protocol/PacketUtils.java b/net/minecraft/network/protocol/PacketUtils.java
index 4535858701b2bb232b9d2feb2af6551526232ddc..16eaea6fb1df4f70afbc82b37d994e898d960327 100644
--- a/net/minecraft/network/protocol/PacketUtils.java
+++ b/net/minecraft/network/protocol/PacketUtils.java
@@ -14,12 +14,10 @@ import org.slf4j.Logger;
 public class PacketUtils {
     private static final Logger LOGGER = LogUtils.getLogger();
 
-    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T processor, ServerLevel level) throws RunningOnDifferentThreadException {
-        ensureRunningOnSameThread(packet, processor, level.getServer());
-    }
-
-    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T processor, BlockableEventLoop<?> executor) throws RunningOnDifferentThreadException {
-        if (!executor.isSameThread()) {
+    // Canvas start
+    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T processor, ServerLevel executor) throws RunningOnDifferentThreadException {
+        if (!executor.getServer().isSameThread()) { // Run on main
+    // Canvas end
             executor.executeIfPossible(() -> {
                 packetProcessing.push(processor); // Paper - detailed watchdog information
                 try { // Paper - detailed watchdog information
diff --git a/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 10b46c59d83d1274cf491f217df2355d13b594c1..6d51ecbb83379e1ef46e41f2eae07bfbeab8f5d5 100644
--- a/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -1,6 +1,7 @@
 package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+import java.util.Set;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -18,13 +19,13 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     );
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
-    private final short[] positions;
+    private final Short[] positions; // Canvas
     private final BlockState[] states;
 
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section) {
         this.sectionPos = sectionPos;
         int size = positions.size();
-        this.positions = new short[size];
+        this.positions = new Short[size]; // Canvas
         this.states = new BlockState[size];
         int i = 0;
 
@@ -37,14 +38,14 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     // CraftBukkit start - Add constructor
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ShortSet shortset, BlockState[] states) {
         this.sectionPos = sectionposition;
-        this.positions = shortset.toShortArray();
+        this.positions = shortset.toArray(new Short[0]); // Canvas
         this.states = states;
     }
     // CraftBukkit end
     // Paper start - Multi Block Change API
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<BlockState> blockChanges) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, java.util.Map<Short, BlockState> blockChanges) { // Canvas
         this.sectionPos = sectionPos;
-        this.positions = blockChanges.keySet().toShortArray();
+        this.positions = blockChanges.keySet().toArray(new Short[0]); // Canvas
         this.states = blockChanges.values().toArray(new BlockState[0]);
     }
     // Paper end - Multi Block Change API
@@ -53,7 +54,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     private ClientboundSectionBlocksUpdatePacket(FriendlyByteBuf buffer) {
         this.sectionPos = SectionPos.of(buffer.readLong());
         int varInt = buffer.readVarInt();
-        this.positions = new short[varInt];
+        this.positions = new Short[varInt]; // Canvas
         this.states = new BlockState[varInt];
 
         for (int i = 0; i < varInt; i++) {
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index d04c06fafd133f773f311e7c2708fa8b049da67c..989b61fd183711a1969ac4658108b14182fff5d2 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -13,6 +13,11 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.jtracy.DiscontinuousFrame;
 import com.mojang.jtracy.TracyClient;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.server.ThreadedServer;
+import io.canvasmc.canvas.server.level.TickRateManagerInstance;
+import io.canvasmc.canvas.server.level.WatchdogWatcher;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -41,8 +46,11 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
@@ -73,6 +81,7 @@ import net.minecraft.gametest.framework.GameTestTicker;
 import net.minecraft.network.chat.ChatDecorator;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketType;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
@@ -173,16 +182,17 @@ import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer, WatchdogWatcher, TickRateManagerInstance { // Paper - rewrite chunk system // Canvas - Threaded Dimensions
     private static MinecraftServer SERVER; // Paper
+    private static ThreadedServer THREADED_SERVER; // Canvas
     public static final Logger LOGGER = LogUtils.getLogger();
     public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
-    private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
+    public static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit // Canvas - private -> public
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND; // Canvas - private -> public
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
     private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
@@ -209,19 +219,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private ServerConnectionListener connection;
     public final ChunkProgressListenerFactory progressListenerFactory;
     @Nullable
-    private ServerStatus status;
+    public ServerStatus status; // Canvas - private -> public
     @Nullable
-    private ServerStatus.Favicon statusIcon;
+    public ServerStatus.Favicon statusIcon; // Canvas - private -> public
     private final RandomSource random = RandomSource.create();
     public final DataFixer fixerUpper;
     private String localIp;
     private int port = -1;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
+    public Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap(); // Canvas - private -> public
     private PlayerList playerList;
     private volatile boolean running = true;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
-    private boolean stopped;
+    public boolean stopped; // Canvas - private -> public
     private int tickCount;
     private int ticksUntilAutosave = 6000;
     protected final Proxy proxy;
@@ -245,14 +255,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean isDemo;
     private volatile boolean isReady;
     private long lastOverloadWarningNanos;
-    protected final Services services;
+    public final Services services; // Canvas - protected -> public
     private long lastServerStatus;
     public final Thread serverThread;
     private long lastTickNanos = Util.getNanos();
     private long taskExecutionStartNanos = Util.getNanos();
     private long idleTimeNanos;
-    private long nextTickTimeNanos = Util.getNanos();
-    private boolean waitingForNextTick = false;
+    public long nextTickTimeNanos; // Canvas - private -> public
+    public boolean waitingForNextTick; // Canvas - private -> public
     private long delayedTasksMaxNextTickTimeNanos;
     private boolean mayHaveDelayedTasks;
     private final PackRepository packRepository;
@@ -293,8 +303,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Spigot start
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
-    private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
-    @Deprecated(forRemoval = true) // Paper
+    public static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop // Canvas - private -> public
+    // @Deprecated(forRemoval = true) // Paper // Canvas - nah
     public final double[] recentTps = new double[4]; // Purpur - Add 5 second tps average in /tps
     // Spigot end
     public volatile boolean hasFullyShutdown; // Paper - Improved watchdog support
@@ -302,15 +312,34 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile Thread shutdownThread; // Paper - Improved watchdog support
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
-    private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
+    public final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping // Canvas - private -> public
     public boolean lagging = false; // Purpur - Lagging threshold
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
     protected boolean upnp = false; // Purpur - UPnP Port Forwarding
 
+    // Canvas start - Multithreaded Dimension Ticking
+    private volatile boolean isTicking = false;
+
+    public boolean isTicking() {
+        return isTicking;
+    }
+
+    @Override
+    public void broadcastPacketsToPlayers(final Packet<?> packet) {
+        this.playerList.broadcastAll(packet);
+    }
+
+    // Canvas end
     public static <S extends MinecraftServer> S spin(Function<Thread, S> threadFunction) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
         AtomicReference<S> atomicReference = new AtomicReference<>();
-        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> atomicReference.get().runServer(), "Server thread");
+        // Canvas start - Threaded Dimensions
+        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> {
+            ((MinecraftServer) atomicReference.get()).runServer();
+            THREADED_SERVER = new ThreadedServer(atomicReference.get());
+            THREADED_SERVER.spin();
+        }, "Server thread");
+        // Canvas end
         thread.setUncaughtExceptionHandler((thread1, exception) -> LOGGER.error("Uncaught exception in server thread", exception));
         thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
         if (Runtime.getRuntime().availableProcessors() > 4) {
@@ -324,16 +353,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Paper start - rewrite chunk system
-    private volatile Throwable chunkSystemCrash;
+    private volatile @Nullable Throwable chunkSystemCrash; // Canvas - nullable
 
     @Override
     public final void moonrise$setChunkSystemCrash(final Throwable throwable) {
         this.chunkSystemCrash = throwable;
     }
 
-    private static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us
-    private static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
-    private static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
+    public static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us // Canvas - private -> public
+    public static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us // Canvas - private -> public
+    public static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us // Canvas - private -> public
 
     private long lastMidTickExecute;
     private long lastMidTickExecuteFailure;
@@ -480,7 +509,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         dataStorage.computeIfAbsent(this.getScoreboard().dataFactory(), "scoreboard");
     }
 
-    protected abstract boolean initServer() throws IOException;
+    public abstract boolean initServer() throws IOException; // Canvas - protected -> public
 
     protected void loadLevel(String levelId) { // CraftBukkit
         if (!JvmProfiler.INSTANCE.isRunning()) {
@@ -876,6 +905,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // CraftBukkit start
             // this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
             this.executeModerately();
+            break; // Canvas
         }
 
         // this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
@@ -978,7 +1008,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // CraftBukkit start
-    private boolean hasStopped = false;
+    public boolean hasStopped = false; // Canvas - private -> public
     private boolean hasLoggedStop = false; // Paper - Debugging
     private final Object stopLock = new Object();
     public final boolean hasStopped() {
@@ -1002,7 +1032,36 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.cancelRecordingMetrics();
         }
 
-        LOGGER.info("Stopping server");
+        // Canvas start
+        ThreadedServer.LOGGER.info("Halting level-threads");
+        long startNanos = Util.getNanos();
+        Thread currentThread = Thread.currentThread();
+        for (final ServerLevel level : this.getAllLevels()) {
+            if (level.running) {
+                level.stopSpin();
+                if (currentThread.equals(level.getRunningThread())) {
+                    continue;
+                }
+                try {
+                    CompletableFuture<Void> killThreadFuture = CompletableFuture.runAsync(() -> {
+                        try {
+                            level.getRunningThread().join();
+                        } catch (Throwable e) {
+                            throw new RuntimeException("Server encountered an unexpected exception when waiting for level thread to terminate!", e);
+                        }
+                    });
+                    killThreadFuture.get(30, TimeUnit.SECONDS);
+                } catch (TimeoutException timeoutException) {
+                    LOGGER.error("Timed out waiting for level {} to terminate, force-killing.", level.dimension().location());
+                    level.getRunningThread().interrupt();
+                } catch (InterruptedException | ExecutionException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        long nanoTickTime = Util.getNanos() - startNanos;
+        ThreadedServer.LOGGER.info("Successfully halted levels in {}ms", (nanoTickTime / 1_000_000));
+        // Canvas end
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
         // Purpur start - UPnP Port Forwarding
         if (upnp) {
@@ -1139,7 +1198,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private final java.math.BigDecimal[] samples;
         private final long[] times;
 
-        RollingAverage(int size) {
+        public RollingAverage(int size) { // Canvas - public
             this.size = size;
             this.time = size * SEC_IN_NANO;
             this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
@@ -1170,10 +1229,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
         }
     }
-    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    public static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL)); // Canvas - private -> public
     // Paper end
 
+    @Deprecated(forRemoval = true) // Canvas - Multithreaded Dimension Ticking - mark deprecated because we dont even use this anymore
     protected void runServer() {
+        if (true) return; // Canvas - nope!
         try {
             if (!this.initServer()) {
                 throw new IllegalStateException("Failed to initialize server");
@@ -1349,6 +1410,121 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
     }
+    // Canvas start - Multithreaded Dimension Ticking
+
+    public long tick(long tickSection) {
+        if (!isTicking) {
+            // Mark ticking to unlock level threads, to allow them to begin runtime.
+            isTicking = true;
+        }
+        long currentTime;
+        long i;
+
+        if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+            i = 0L;
+            this.nextTickTimeNanos = Util.getNanos();
+            this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+        } else {
+            i = this.tickRateManager.nanosecondsPerTick();
+            long j = Util.getNanos() - this.nextTickTimeNanos;
+
+            if (j > MinecraftServer.OVERLOADED_THRESHOLD_NANOS + 20L * i && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * i) {
+                long k = j / i;
+
+                if (this.server.getWarnOnOverload()) {
+                    MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k);
+                }
+                this.nextTickTimeNanos += k * i;
+                this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+            }
+        }
+
+        currentTime = Util.getNanos();
+        if (++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+            final long diff = currentTime - tickSection;
+            final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+            tps5s.add(currentTps, diff);
+            tps1.add(currentTps, diff);
+            tps5.add(currentTps, diff);
+            tps15.add(currentTps, diff);
+
+            this.recentTps[0] = tps5s.getAverage();
+            this.recentTps[1] = tps1.getAverage();
+            this.recentTps[2] = tps5.getAverage();
+            this.recentTps[3] = tps15.getAverage();
+            lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+            tickSection = currentTime;
+        }
+
+        boolean flag = i == 0L;
+
+        if (this.debugCommandProfilerDelayStart) {
+            this.debugCommandProfilerDelayStart = false;
+            this.debugCommandProfiler = new TimeProfiler(Util.getNanos(), this.tickCount);
+        }
+
+        lastTick = currentTime;
+        this.nextTickTimeNanos += i;
+
+        try {
+            Profiler.Scope profiler_a = Profiler.use(this.createProfiler());
+
+            try {
+                ProfilerFiller gameprofilerfiller = Profiler.get();
+
+                gameprofilerfiller.push("tick");
+                this.tickFrame.start();
+                // We update it through here so that we can easily access this var throughout the lifecycle
+                ThreadedServer.SHOULD_KEEP_TICKING = flag ? () -> false : this::haveTime;
+                this.tickServer(ThreadedServer.SHOULD_KEEP_TICKING);
+
+                final Throwable crash = this.chunkSystemCrash;
+                if (crash != null) {
+                    this.chunkSystemCrash = null;
+                    throw new RuntimeException("Chunk system crash propagated to tick()", crash);
+                }
+
+                this.tickFrame.end();
+                gameprofilerfiller.popPush("nextTickWait");
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + i, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+                    this.nextTickTimeNanos = currentTime + i;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+                if (flag) {
+                    this.tickRateManager.endTickWork();
+                }
+
+                gameprofilerfiller.pop();
+                this.logFullTickTime();
+            } catch (Throwable throwable) {
+                if (profiler_a != null) {
+                    try {
+                        profiler_a.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
+                    }
+                }
+
+                throw throwable;
+            }
+
+            if (profiler_a != null) {
+                profiler_a.close();
+            }
+        } finally {
+            this.endMetricsRecordingTick();
+        }
+
+        this.isReady = true;
+        JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
+        return tickSection;
+    }
+    // Canvas end
 
     private void logFullTickTime() {
         long nanos = Util.getNanos();
@@ -1374,7 +1550,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    private static CrashReport constructOrExtractCrashReport(Throwable cause) {
+    public static CrashReport constructOrExtractCrashReport(Throwable cause) { // Canvas - private -> public
         ReportedException reportedException = null;
 
         for (Throwable throwable = cause; throwable != null; throwable = throwable.getCause()) {
@@ -1474,7 +1650,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (super.pollTask()) {
             this.moonrise$executeMidTickTasks(); // Paper - rewrite chunk system
             return true;
-        } else {
+        } else if (!getThreadedServer().hasStarted()) { // Canvas
             boolean ret = false; // Paper - force execution of all worlds, do not just bias the first
             if (this.tickRateManager.isSprinting() || this.haveTime()) {
                 for (ServerLevel serverLevel : this.getAllLevels()) {
@@ -1486,6 +1662,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             return ret; // Paper - force execution of all worlds, do not just bias the first
         }
+        return false; // Canvas
     }
 
     @Override
@@ -1494,7 +1671,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         super.doRunTask(task);
     }
 
-    private Optional<ServerStatus.Favicon> loadStatusIcon() {
+    public Optional<ServerStatus.Favicon> loadStatusIcon() { // Canvas - private -> public
         Optional<Path> optional = Optional.of(this.getFile("server-icon.png"))
             .filter(path -> Files.isRegularFile(path))
             .or(() -> this.storageSource.getIconFile().filter(path -> Files.isRegularFile(path)));
@@ -1531,6 +1708,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
+    // Canvas start
+    private boolean emptyTickSleeping = false;
+
+    public boolean isEmptyTickSkipping() {
+        return emptyTickSleeping;
+    }
+
+    // Canvas end
     public void tickServer(BooleanSupplier hasTimeLeft) {
         org.spigotmc.WatchdogThread.tick(); // Spigot
         long nanos = Util.getNanos();
@@ -1556,18 +1741,22 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 while ((task = this.processQueue.poll()) != null) {
                     task.run();
                 }
-                for (final ServerLevel level : this.levels.values()) {
+                // Canvas start - Multithreaded Dimension Ticking
+                // We tick the chunk source on the levels respective thread
+                /* for (final ServerLevel level : this.levels.values()) {
                     // process unloads
                     level.getChunkSource().tick(() -> true, false);
-                }
+                } */ // Canvas end
                 // Paper end - avoid issues with certain tasks not processing during sleep
                 this.server.spark.executeMainThreadTasks(); // Paper - spark
                 this.tickConnection();
                 this.server.spark.tickEnd(((double)(System.nanoTime() - lastTick) / 1000000D)); // Paper - spark
+                emptyTickSleeping = true; // Canvas
                 return;
             }
         }
 
+        emptyTickSleeping = false; // Canvas
         this.server.spark.tickStart(); // Paper - spark
         new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper - Server Tick Events
         this.tickCount++;
@@ -1664,11 +1853,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    protected abstract SampleLogger getTickTimeLogger();
+    public abstract SampleLogger getTickTimeLogger(); // Canvas - protected -> public
 
     public abstract boolean isTickTimeLoggingEnabled();
 
-    private ServerStatus buildServerStatus() {
+    public ServerStatus buildServerStatus() { // Canvas - private -> public
         ServerStatus.Players players = this.buildPlayerStatus();
         return new ServerStatus(
             io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), // Paper - Adventure
@@ -1701,11 +1890,21 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     protected void tickChildren(BooleanSupplier hasTimeLeft) {
         ProfilerFiller profilerFiller = Profiler.get();
-        this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
+        // Canvas start
+        // this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
+        for (final ServerPlayer player : this.playerList.players) {
+            if (player.connection.connection.getHoldingLevel() == null
+                /*holding level is null, meaning they havent been moved
+                    to a level thread yet, so we handle on main*/) {
+                player.connection.suspendFlushing();
+            }
+        }
+// Canvas end
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
+        // Canvas start - move to level threads
+        /* getAllLevels().forEach(level -> {
             for (final net.minecraft.world.entity.Entity entity : level.getEntities().getAll()) {
                 if (entity.isRemoved()) {
                     continue;
@@ -1715,7 +1914,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     bukkit.taskScheduler.executeTick();
                 }
             }
-        });
+        }); */
+        // Canvas end
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         profilerFiller.push("commandFunctions");
@@ -1730,7 +1930,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        // Canvas start - Multithreaded Dimension Ticking - moved to ServerLevel
+        /* for (final ServerLevel level : this.getAllLevels()) {
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1747,9 +1948,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 entityplayer.connection.send(packet); // Add support for per player time
                 // Paper end - Perf: Optimize time updates
             }
-        }
+        } */ // Canvas end
 
-        this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
+        /* this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked // Canvas start - Multithreaded Dimension Ticking
         for (ServerLevel serverLevel : this.getAllLevels()) {
             serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
             serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
@@ -1763,7 +1964,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.synchronizeTime(serverLevel);
                 profilerFiller.pop();
             }
-            // CraftBukkit end */
+            // CraftBukkit end // Canvas - compile error with craftbukkit comment
 
             profilerFiller.push("tick");
 
@@ -1779,7 +1980,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             profilerFiller.pop();
             serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
-        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked */ // Canvas end
 
         profilerFiller.popPush("connection");
         this.tickConnection();
@@ -1797,9 +1998,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         profilerFiller.popPush("send chunks");
 
-        for (ServerPlayer serverPlayer : this.playerList.getPlayers()) {
-            serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
-            serverPlayer.connection.resumeFlushing();
+        for (final ServerPlayer serverPlayer : this.playerList.players) {
+            // Canvas start
+            if (serverPlayer.connection.connection.getHoldingLevel() == null
+                /*holding level is null, meaning they havent been moved
+                    to a level thread yet, so we handle on main*/) {
+                serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
+                serverPlayer.connection.resumeFlushing();
+            }
+            // Canvas end
         }
 
         profilerFiller.pop();
@@ -1810,6 +2017,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private void synchronizeTime(ServerLevel level) {
+        // Canvas start - not all worlds have the same time anymore due to tick isolation
+        if (true) {
+            level.syncTimeToPlayers();
+            return;
+        }
+        // Canvas end
         this.playerList
             .broadcastAll(
                 new ClientboundSetTimePacket(level.getGameTime(), level.getDayTime(), level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)),
@@ -1822,7 +2035,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         profilerFiller.push("timeSync");
 
         for (ServerLevel serverLevel : this.getAllLevels()) {
-            this.synchronizeTime(serverLevel);
+            serverLevel.syncTimeToPlayers(); // Canvas
         }
 
         profilerFiller.pop();
@@ -1863,6 +2076,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        getThreadedServer().loadLevel(level); // Canvas - add level to threaded context
     }
 
     public void removeLevel(ServerLevel level) {
@@ -1870,6 +2084,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        getThreadedServer().stopLevel(level); // Canvas - remove level from threaded context
     }
     // CraftBukkit end
 
@@ -2200,6 +2415,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public Thread getRunningThread() {
         return this.serverThread;
     }
+    // Canvas start - Threaded Dimensions - Improve Watchdog
+
+    @Override
+    public String getName() {
+        return "server";
+    }
+    // Canvas end
 
     public int getCompressionThreshold() {
         return 256;
@@ -2303,6 +2525,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (this.isSameThread()) {
             this.managedBlock(completableFuture::isDone);
         }
+        // Canvas end
 
         return completableFuture;
     }
@@ -2497,7 +2720,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.smoothedTickTimeMillis;
     }
 
+    // Canvas start
+
+    @Override
+    public void skipTickWait() {
+        this.delayedTasksMaxNextTickTimeNanos = Util.getNanos();
+        this.nextTickTimeNanos = Util.getNanos();
+    }
+
+    @Override
     public ServerTickRateManager tickRateManager() {
+    // Canvas end
         return this.tickRateManager;
     }
 
@@ -2638,6 +2871,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static MinecraftServer getServer() {
         return SERVER; // Paper
     }
+    // Canvas start
+
+    public static ThreadedServer getThreadedServer() {
+        return THREADED_SERVER;
+    }
+    // Canvas end
 
     @Deprecated
     public static RegistryAccess getDefaultRegistryAccess() {
@@ -2852,7 +3091,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return ServerLinks.EMPTY;
     }
 
-    protected int pauseWhileEmptySeconds() {
+    public int pauseWhileEmptySeconds() { // Canvas - protected -> public
         return 0;
     }
 
diff --git a/net/minecraft/server/ServerTickRateManager.java b/net/minecraft/server/ServerTickRateManager.java
index 45c37663c2c23b960b00e5c7fa729a1e4ab39e1d..f72ac59c906ae4897a15ea95ea1ccbed89abc808 100644
--- a/net/minecraft/server/ServerTickRateManager.java
+++ b/net/minecraft/server/ServerTickRateManager.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import io.canvasmc.canvas.server.level.TickRateManagerInstance;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.game.ClientboundTickingStatePacket;
 import net.minecraft.network.protocol.game.ClientboundTickingStepPacket;
@@ -13,9 +14,9 @@ public class ServerTickRateManager extends TickRateManager {
     private long sprintTimeSpend = 0L;
     private long scheduledCurrentSprintTicks = 0L;
     private boolean previousIsFrozen = false;
-    private final MinecraftServer server;
+    private final TickRateManagerInstance server; // Canvas
 
-    public ServerTickRateManager(MinecraftServer server) {
+    public ServerTickRateManager(TickRateManagerInstance server) { // Canvas
         this.server = server;
     }
 
@@ -30,11 +31,11 @@ public class ServerTickRateManager extends TickRateManager {
     }
 
     private void updateStateToClients() {
-        this.server.getPlayerList().broadcastAll(ClientboundTickingStatePacket.from(this));
+        this.server.broadcastPacketsToPlayers(ClientboundTickingStatePacket.from(this)); // Canvas
     }
 
     private void updateStepTicks() {
-        this.server.getPlayerList().broadcastAll(ClientboundTickingStepPacket.from(this));
+        this.server.broadcastPacketsToPlayers(ClientboundTickingStepPacket.from(this)); // Canvas
     }
 
     public boolean stepGameIfPaused(int ticks) {
@@ -117,4 +118,16 @@ public class ServerTickRateManager extends TickRateManager {
         player.connection.send(ClientboundTickingStatePacket.from(this));
         player.connection.send(ClientboundTickingStepPacket.from(this));
     }
+    // Canvas start
+
+    private boolean unlocked = false;
+
+    public void toggleUnlockTickRate(boolean unlocked) {
+        this.unlocked = unlocked;
+    }
+
+    public boolean isUnlockedTickRate() {
+        return unlocked;
+    }
+    // Canvas end
 }
diff --git a/net/minecraft/server/commands/FillCommand.java b/net/minecraft/server/commands/FillCommand.java
index a224f8cc122fc6d79b4abd08815f58f0e6aa340b..2a230a0719fd105e5083c10d98362f32012629d1 100644
--- a/net/minecraft/server/commands/FillCommand.java
+++ b/net/minecraft/server/commands/FillCommand.java
@@ -161,6 +161,8 @@ public class FillCommand {
         } else {
             List<BlockPos> list = Lists.newArrayList();
             ServerLevel level = source.getLevel();
+            // Canvas start - move to level-main
+            level.schedule(level.wrapRunnable(() -> {
             int i1 = 0;
 
             for (BlockPos blockPos : BlockPos.betweenClosed(area.minX(), area.minY(), area.minZ(), area.maxX(), area.maxY(), area.maxZ())) {
@@ -183,12 +185,19 @@ public class FillCommand {
             }
 
             if (i1 == 0) {
-                throw ERROR_FAILED.create();
+                try {
+                    throw ERROR_FAILED.create();
+                } catch (CommandSyntaxException e) {
+                    source.sendFailure(Component.literal(ERROR_FAILED.create().getMessage()));
+                    throw new RuntimeException("Unable to execute command", e);
+                }
             } else {
                 int i2 = i1;
                 source.sendSuccess(() -> Component.translatable("commands.fill.success", i2), true);
-                return i1;
             }
+            }));
+            return 0;
+            // Canvas end
         }
     }
 
diff --git a/net/minecraft/server/commands/TickCommand.java b/net/minecraft/server/commands/TickCommand.java
index 6b6c8ce49eda6806c8288d70848dd143ba2c4703..0520ea7c6085da9342a859e02befd1aa9c187740 100644
--- a/net/minecraft/server/commands/TickCommand.java
+++ b/net/minecraft/server/commands/TickCommand.java
@@ -1,23 +1,161 @@
 package net.minecraft.server.commands;
 
 import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.Message;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.command.ThreadedTickDiagnosis;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.commands.SharedSuggestionProvider;
 import net.minecraft.commands.arguments.TimeArgument;
+import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.TimeUtil;
+import org.jetbrains.annotations.NotNull;
 
 public class TickCommand {
     private static final float MAX_TICKRATE = 10000.0F;
     private static final String DEFAULT_TICKRATE = String.valueOf(20);
+    // Canvas start
+    private static final String UNCAPPED_TICKRATE = String.valueOf(-1);
+    private static final String[] RATE_SUGGESTIONS = new String[]{DEFAULT_TICKRATE, UNCAPPED_TICKRATE};
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        if (Config.INSTANCE.enableCanvasTickCommand) {
+            dispatcher.register(
+                Commands.literal("threadedtick")
+                    .requires(source -> source.hasPermission(3))
+                    .then(Commands.literal("diagnosis").executes(context -> {
+                        CommandSourceStack commandSourceStack = context.getSource();
+                        ThreadedTickDiagnosis.execute(commandSourceStack.getBukkitSender());
+                        return 1;
+                    }))
+                    .then(
+                        Commands.argument("threadstate", StringArgumentType.word())
+                            .suggests((_, builder) -> SharedSuggestionProvider.suggest(getThreadStates(), builder))
+                            .then(Commands.literal("rate")
+                                .then(Commands.argument("rate", FloatArgumentType.floatArg(-1.0F, 10000.0F))
+                                    .suggests((_, suggestionsBuilder) -> SharedSuggestionProvider.suggest(RATE_SUGGESTIONS, suggestionsBuilder)).executes(context -> {
+                                        float rate = FloatArgumentType.getFloat(context, "rate");
+                                        execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                            if (rate == -1) {
+                                                serverTickRateManager.toggleUnlockTickRate(true);
+                                            } else if (rate > 0) {
+                                                serverTickRateManager.setTickRate(rate);
+                                            }
+                                        });
+                                        if (rate == -1) {
+                                            context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate."), true);
+                                        } else if (rate > 0) {
+                                            String string = String.format(Locale.ROOT, "%.1f", rate);
+                                            context.getSource().sendSuccess(() -> Component.translatable("commands.tick.rate.success", string), true);
+                                        }
+                                        return 1;
+                                    })
+                                )
+                            )
+                            .then(Commands.literal("unbind").executes(context -> {
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.toggleUnlockTickRate(true);
+                                });
+                                context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate on thread(s)."), true);
+                                return 1;
+                            }))
+                            .then(Commands.literal("rebind").executes(context -> {
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.toggleUnlockTickRate(false);
+                                });
+                                context.getSource().sendSuccess(() -> Component.literal("Rebound tickrate to thread(s)."), true);
+                                return 1;
+                            }))
+                            .then(Commands.literal("unfreeze").executes(context -> {
+                                boolean frozen = false;
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.setFrozen(frozen);
+                                    context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.running"), true);
+                                });
+                                return 1;
+                            }))
+                            .then(Commands.literal("freeze").executes(context -> {
+                                boolean frozen = true;
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    if (serverTickRateManager.isSprinting()) {
+                                        serverTickRateManager.stopSprinting();
+                                    }
+
+                                    if (serverTickRateManager.isSteppingForward()) {
+                                        serverTickRateManager.stopStepping();
+                                    }
+
+                                    serverTickRateManager.setFrozen(frozen);
+                                    context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.frozen"), true);
+                                });
+                                return 1;
+                            }))
+                    )
+            );
+        }
+        tickCommand(dispatcher);
+    }
+
+    public static void execute(@NotNull String state, Consumer<ServerTickRateManager> action) throws CommandSyntaxException {
+        if (state.equalsIgnoreCase("global")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+            for (final ServerLevel level : MinecraftServer.getThreadedServer().getAllLevels()) {
+                action.accept((ServerTickRateManager) level.tickRateManager());
+            }
+        } else if (state.equalsIgnoreCase("main")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+        } else {
+            if (!state.contains(":")) {
+                Message message = Component.literal("State isn't valid or known: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            ResourceLocation location = ResourceLocation.parse(state);
+            ServerLevel level = MinecraftServer.getServer().getLevel(ResourceKey.create(Registries.DIMENSION, location));
+            if (level == null) {
+                Message message = Component.literal("Couldn't build level: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            action.accept((ServerTickRateManager) level.tickRateManager());
+        }
+    }
+
+    private static String[] getThreadStates() {
+        List<String> states = new ArrayList<>();
+        states.add("global");
+        states.add("main");
+        states.addAll(MinecraftServer.getThreadedServer().getAllLevels()
+            .stream()
+            .map(ServerLevel::dimension)
+            .map(ResourceKey::location)
+            .map(ResourceLocation::toString).collect(Collectors.toSet()));
+        return states.toArray(new String[0]);
+    }
+
+    /**
+     * @deprecated Use threadedtick command instead of this. This runs on a global
+     * state, while threadedtick can be more powerful for specific contexts.
+     */
+    @Deprecated(forRemoval = true)
+    private static void tickCommand(CommandDispatcher<CommandSourceStack> dispatcher) {
+        // Canvas end
         dispatcher.register(
             Commands.literal("tick")
                 .requires(commandSourceStack -> commandSourceStack.hasPermission(3))
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index 4c81c4172d2e077ec7d627c2db8e7294c5b90a64..8baa1fb62c294f59a799b62c4760a0c4a3cf84b1 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -1,6 +1,5 @@
 package net.minecraft.server.dedicated;
 
-import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
@@ -11,14 +10,16 @@ import java.io.Writer;
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.locks.LockSupport;
 import javax.annotation.Nullable;
+
+import io.canvasmc.canvas.server.ThreadedServer;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
@@ -45,6 +46,7 @@ import net.minecraft.server.rcon.RconConsoleSource;
 import net.minecraft.server.rcon.thread.QueryThreadGs4;
 import net.minecraft.server.rcon.thread.RconThread;
 import net.minecraft.util.Mth;
+import net.minecraft.util.TimeUtil;
 import net.minecraft.util.debugchart.DebugSampleSubscriptionTracker;
 import net.minecraft.util.debugchart.RemoteDebugSampleType;
 import net.minecraft.util.debugchart.RemoteSampleLogger;
@@ -232,6 +234,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash); // Paper - start watchdog thread
         thread.start(); // Paper - Enhance console tab completions for brigadier commands; start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
+        io.canvasmc.canvas.command.CanvasCommands.registerCommands(this); // Canvas - register commands
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         // Purpur start - Purpur config files
@@ -363,6 +366,28 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             GameProfileCache.setUsesAuthentication(this.usesAuthentication());
             LOGGER.info("Preparing level \"{}\"", this.getLevelIdName());
             this.loadLevel(this.storageSource.getLevelId()); // CraftBukkit
+            // Canvas start - prepare the level for threaded context
+            for (final ServerLevel level : this.levels.values()) {
+                ThreadedServer.SPINNER.apply(level);
+            }
+
+            CompletableFuture<Void> preparedContextFuture = CompletableFuture.allOf(
+                this.levels.values().stream()
+                    .map(value -> CompletableFuture.runAsync(() -> {
+                        while (!value.prepared) {
+                            // Park for 1 millisecond to wait for prepared level threaded context
+                            LockSupport.parkNanos("waiting for prepared context", TimeUtil.NANOSECONDS_PER_MILLISECOND);
+                        }
+                    }))
+                    .toArray(CompletableFuture[]::new)
+            );
+
+            try {
+                preparedContextFuture.get();
+            } catch (Throwable e) {
+                throw new RuntimeException("An unexpected error occurred when waiting for levels to prepare threaded context", e);
+            }
+            // Canvas end
             long l = Util.getNanos() - nanos;
             String string = String.format(Locale.ROOT, "%.3fs", l / 1.0E9);
             LOGGER.info("Done preparing level \"{}\" ({})", this.getLevelIdName(), string); // Paper - Improve startup message, add total time
diff --git a/net/minecraft/server/level/ChunkHolder.java b/net/minecraft/server/level/ChunkHolder.java
index 656041c9539b6834b4d37b353eb6b810a7763ff4..30b598d6da876f1092d504637fd3f6cb3ee5c216 100644
--- a/net/minecraft/server/level/ChunkHolder.java
+++ b/net/minecraft/server/level/ChunkHolder.java
@@ -10,6 +10,7 @@ import java.util.concurrent.Executor;
 import java.util.function.IntConsumer;
 import java.util.function.IntSupplier;
 import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.shorts.ShortSets;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -306,7 +307,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
                             } else {
                                 LevelChunkSection section = chunk.getSection(i);
                                 ClientboundSectionBlocksUpdatePacket clientboundSectionBlocksUpdatePacket = new ClientboundSectionBlocksUpdatePacket(
-                                    sectionPos, set, section
+                                    sectionPos, ShortSets.synchronize(set), section // Canvas
                                 );
                                 this.broadcast(players, clientboundSectionBlocksUpdatePacket);
                                 clientboundSectionBlocksUpdatePacket.runUpdates(
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index b3f498558614243cf633dcd71e3c49c2c55e6e0f..397dc758695386c9bd3c943ed6ffa04937b8380d 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -7,6 +7,9 @@ import com.google.common.collect.Queues;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.canvasmc.canvas.util.fastutil.Long2ByteConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -33,6 +36,7 @@ import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -120,7 +124,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final ChunkGeneratorStructureState chunkGeneratorState;
     private final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop = new LongOpenHashSet();
+    public final ConcurrentSet<Long> toDrop = new ConcurrentSet<>(); // Canvas
     private boolean modified;
     // Paper - rewrite chunk system
     public final ChunkProgressListener progressListener;
@@ -129,8 +133,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final AtomicInteger tickingGenerated = new AtomicInteger();  // Paper - public
     private final String storageName;
     private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
+    // Canvas start
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectConcurrentHashMap<>();
+    private final Long2ByteMap chunkTypeCache = new Long2ByteConcurrentHashMap();
+    // Canvas end
     // Paper - rewrite chunk system
     public int serverViewDistance;
     public final WorldGenContext worldGenContext; // Paper - public
@@ -944,13 +950,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) continue; // Canvas - NPE
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkData().nearbyPlayers);
+            ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity cse =  ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity); ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(cse.moonrise$getChunkData() == null ? null : cse.moonrise$getChunkData().nearbyPlayers);
+            @Nullable FullChunkStatus chunkStatus = ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus(); // Canvas
             if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$hasPlayers()
-                || ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus().isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                || (chunkStatus != null && chunkStatus.isOrAfter(FullChunkStatus.ENTITY_TICKING))) { // Canvas
                 tracker.serverEntity.sendChanges();
             }
         }
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 6540b2d6a1062d883811ce240c49d30d1925b291..8b0543417384182482fcf6282340d7e7f559ba5a 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -3,6 +3,7 @@ package net.minecraft.server.level;
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import java.io.IOException;
 import java.nio.file.Path;
@@ -56,7 +57,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private static final Logger LOGGER = LogUtils.getLogger();
     private final DistanceManager distanceManager;
     private final ServerLevel level;
-    public final Thread mainThread;
+    public Thread mainThread; // Canvas - mutable
     final ThreadedLevelLightEngine lightEngine;
     public final ServerChunkCache.MainThreadExecutor mainThreadProcessor;
     public final ChunkMap chunkMap;
@@ -69,7 +70,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
     private final List<LevelChunk> tickingChunks = new ArrayList<>();
-    private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet<>();
+    private final Set<ChunkHolder> chunkHoldersToBroadcast = new ConcurrentSet<>(); // Canvas
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
@@ -435,7 +436,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return this.mainThreadProcessor.pollTask();
     }
 
-    public boolean runDistanceManagerUpdates() { // Paper - public
+    public synchronized boolean runDistanceManagerUpdates() { // Paper - public
         return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
@@ -490,9 +491,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         this.runDistanceManagerUpdates();
         profilerFiller.popPush("chunks");
         if (tickChunks) {
+            synchronized (this) { // Canvas - Multithreaded Dimension Ticking - only 1 thread can tick this instance at a time
             ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
             this.tickChunks();
             this.chunkMap.tick();
+            } // Canvas
         }
 
         profilerFiller.popPush("unload");
@@ -557,6 +560,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         for (int i = 0; i < size; ++i) {
             final ServerChunkCache.ChunkAndHolder chunkAndHolder = raw[i];
+            if (chunkAndHolder == null) continue; // Canvas - NPE
             final LevelChunk levelChunk = chunkAndHolder.chunk();
 
             if (!this.isChunkNearPlayer(chunkMap, levelChunk.getPos(), levelChunk)) {
@@ -818,6 +822,18 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             super.doRunTask(task);
         }
 
+        // Canvas start
+        @Override
+        public void execute(final Runnable runnable) {
+            ServerLevel level = ServerChunkCache.this.level;
+            if (level.isTicking()) {
+                level.execute(runnable);
+            } else {
+                super.execute(runnable);
+            }
+        }
+
+        // Canvas end
         @Override
         public boolean pollTask() {
             // Paper start - rewrite chunk system
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 3770dc90d9412c6378c0bd57a651b9c3e62b9a72..898d151f14f6fbf9f21d3b999ca2c550a8c95c5c 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -5,6 +5,11 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.canvasmc.canvas.server.ThreadedServer;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.util.QueuedTaskScheduler;
+import io.canvasmc.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -18,15 +23,24 @@ import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.io.File;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -38,6 +52,7 @@ import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -47,8 +62,12 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
@@ -57,7 +76,9 @@ import net.minecraft.network.protocol.game.ClientboundExplodePacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -65,7 +86,10 @@ import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.network.ServerConnectionListener;
 import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
@@ -79,6 +103,7 @@ import net.minecraft.util.Unit;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -179,7 +204,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = Lists.newCopyOnWriteArrayList(); // Canvas
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -194,22 +219,23 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet<>();
+    final Set<Mob> navigatingMobs = new ConcurrentSet<>(); // Canvas
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet<>();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList<>(64);
+    private final List<BlockEventData> blockEvents = new CopyOnWriteArrayList<>(); // Canvas
+    private final Queue<BlockEventData> blockEventsToReschedule = new ConcurrentLinkedQueue<>(); // Canvas
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectConcurrentHashMap<>(); // Canvas
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private double preciseTime; // Purpur - Configurable daylight cycle
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
+    public final QueuedTaskScheduler taskScheduler = new QueuedTaskScheduler(); // Canvas
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess levelStorageAccess;
@@ -218,6 +244,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
+    // Canvas start - Threaded Dimensions
+    private int emptyTicks;
+    private int sendAllPlayerInfoIn;
+    // Canvas end
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -733,8 +763,136 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public StructureManager structureManager() {
         return this.structureManager;
     }
+    // Canvas start - Multithreaded Dimension Ticking
+    private final List<Connection> activeConnections = new ObjectArrayList<>();
+    private final Object lock = new Object();
 
-    public void tick(BooleanSupplier hasTimeLeft) {
+    public void notifyNewConnection(Connection connection) {
+        synchronized (lock) {
+            activeConnections.add(connection);
+        }
+    }
+    public void removeConnection(Connection connection) {
+        synchronized (lock)  {
+            activeConnections.remove(connection);
+        }
+    }
+
+    private boolean tickEmptyLevel() {
+        if (this.server.isEmptyTickSkipping()) {
+            return true;
+        }
+        int serverEmptySecondsLimit = this.server.pauseWhileEmptySeconds() * 20;
+        if (serverEmptySecondsLimit > 0 && Config.INSTANCE.emptySleepPerWorlds) {
+            if (this.players.isEmpty() && !this.tickRateManager.isSprinting() && this.server.pluginsBlockingSleep.isEmpty()) {
+                ++this.emptyTicks;
+            } else {
+                this.emptyTicks = 0;
+            }
+
+            if (this.emptyTicks >= serverEmptySecondsLimit) {
+                if (this.emptyTicks == serverEmptySecondsLimit) {
+                    MinecraftServer.LOGGER.info("Level empty for {} seconds, pausing", this.server.pauseWhileEmptySeconds());
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    protected void tickConnection() {
+        for (ServerPlayer player : this.players) {
+            player.connection.suspendFlushing();
+        }
+        Iterator<Connection> iterator = this.activeConnections.iterator();
+        while (iterator.hasNext()) {
+            Connection networkmanager = iterator.next();
+
+            if (!networkmanager.isConnecting()) {
+                if (networkmanager.isConnected()) {
+                    try {
+                        networkmanager.tick();
+                    } catch (Exception exception) {
+                        if (networkmanager.isMemoryConnection()) {
+                            throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                        }
+
+                        LOGGER.warn("Failed to handle packet for {}", networkmanager.getLoggableAddress(this.server.logIPs()), exception);
+                        MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
+
+                        networkmanager.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                            networkmanager.disconnect(ichatmutablecomponent);
+                        }));
+                        networkmanager.setReadOnly();
+                    }
+                } else {
+                    if (networkmanager.preparing) continue;
+                    iterator.remove();
+                    networkmanager.handleDisconnection();
+                }
+            }
+        }
+    }
+
+    public void syncTimeToPlayers() {
+        ClientboundSetTimePacket timePacket = new ClientboundSetTimePacket(getGameTime(), getDayTime(), getGameRules().getBoolean(GameRules.RULE_DAYLIGHT));
+        for (final ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.connection.send(timePacket);
+            }
+        }
+    }
+
+    public void squeezeTasks() {
+        // this.runAllTasks();
+    }
+
+    public void tickPlayerList() {
+        if (!Config.INSTANCE.runPlayerListTickOnIndependentLevel) return;
+        if (++this.sendAllPlayerInfoIn > 600) {
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = this.players.get(i);
+
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.getServer().getPlayerList().
+                    players.stream().filter(input -> target.getBukkitEntity().canSee(input.getBukkitEntity())).collect(Collectors.toList())));
+            }
+            this.sendAllPlayerInfoIn = 0;
+        }
+
+    }
+
+    public void tick(BooleanSupplier hasTimeLeft, int tickCount) {
+        this.tickRateManager.tick();
+        this.tickConnection();
+
+        if (this.tickEmptyLevel()) {
+            return;
+        }
+        // Mark handling tick AFTER ticking empty level check
+        this.handlingTick = true;
+
+        for (final Entity entity : this.getEntities().getAll()) {
+            if (entity.isRemoved()) {
+                continue;
+            }
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        chunkSource.tick(() -> true, false);
+
+        if (this.tickCount % Config.INSTANCE.timeResyncInterval == 0) {
+            // Resync time every configurable amount of ticks
+            syncTimeToPlayers();
+        }
+
+        hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+        hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+        updateLagCompensationTick();
+        hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+    // Canvas end
         ProfilerFiller profilerFiller = Profiler.get();
         this.handlingTick = true;
         TickRateManager tickRateManager = this.tickRateManager();
@@ -778,6 +936,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.tickTime();
         }
 
+        this.squeezeTasks(); // Canvas
         profilerFiller.push("tickPending");
         if (!this.isDebug() && runsNormally) {
             long l = this.getGameTime();
@@ -795,6 +954,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
         profilerFiller.popPush("chunkSource");
         this.getChunkSource().tick(hasTimeLeft, true);
+        this.squeezeTasks(); // Canvas
         profilerFiller.popPush("blockEvents");
         if (runsNormally) {
             this.runBlockEvents();
@@ -849,6 +1009,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         profilerFiller.push("entityManagement");
         // Paper - rewrite chunk system
         profilerFiller.pop();
+        // Canvas start - Threaded Dimensions
+        tickPlayerList();
+        for (ServerPlayer player : this.players) {
+            player.connection.chunkSender.sendNextChunks(player);
+            player.connection.resumeFlushing();
+        }
+        explosionDensityCache.clear();
+        this.runAllTasks();
+        // Canvas end
     }
 
     @Override
@@ -1254,6 +1423,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 player.updateWeather(this.oRainLevel, this.rainLevel, this.oThunderLevel, this.thunderLevel);
             }
         }
+        // Canvas end
         // CraftBukkit end
     }
 
@@ -1483,6 +1653,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
             return AbortableIterationConsumer.Continuation.CONTINUE;
         });
+        this.syncTimeToPlayers(); // Canvas - ensure time resync
     }
 
     public List<? extends EnderDragon> getDragons() {
@@ -2157,8 +2328,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     @Override
-    public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+    public ServerTickRateManager tickRateManager() { // Canvas
+        return this.tickRateManager; // Canvas
     }
 
     @Override
@@ -2538,7 +2709,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
+        ((BlockableEventLoop<?>) (MinecraftServer.getThreadedServer().hasStarted() ? this : this.server)).execute(() -> this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts()));
     }
 
     public PathTypeCache getPathTypeCache() {
@@ -2546,7 +2717,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     @Override
-    public void close() throws IOException {
+    public void close() { // Canvas
         super.close();
         // Paper - rewrite chunk system
     }
diff --git a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 398c1733824b689520170de0be94006731afa5cd..c887978027371385adea3139865fec30853412fe 100644
--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -3,6 +3,7 @@ package net.minecraft.server.network;
 import com.mojang.authlib.GameProfile;
 import com.mojang.logging.LogUtils;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.Config;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -216,7 +217,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
     @Override
     public void handleResourcePackResponse(ServerboundResourcePackPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (packet.action() == ServerboundResourcePackPacket.Action.DECLINED && this.server.isResourcePackRequired()) {
             LOGGER.info("Disconnecting {} due to resource pack {} rejection", this.playerProfile().getName(), packet.id());
             this.disconnect(Component.translatable("multiplayer.requiredTexturePrompt.disconnect"), org.bukkit.event.player.PlayerKickEvent.Cause.RESOURCE_PACK_REJECTION); // Paper - kick event cause
@@ -243,7 +244,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     @Override
     public void handleCookieResponse(ServerboundCookieResponsePacket packet) {
         // CraftBukkit start
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.player.getBukkitEntity().handleCookieResponse(packet)) {
             return;
         }
diff --git a/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java b/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
index 2e9eb04c7c4342393c05339906c267bca9ff29b1..7f40872995057f661bfb0eeee139aca2ff9aad75 100644
--- a/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
@@ -131,7 +131,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
 
     @Override
     public void handleSelectKnownPacks(ServerboundSelectKnownPacks packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.synchronizeRegistriesTask == null) {
             throw new IllegalStateException("Unexpected response from client: received pack selection, but no negotiation ongoing");
         } else {
@@ -142,7 +142,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
 
     @Override
     public void handleConfigurationFinished(ServerboundFinishConfigurationPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         this.finishCurrentTask(JoinWorldTask.TYPE);
         this.connection.setupOutboundProtocol(GameProtocols.CLIENTBOUND_TEMPLATE.bind(RegistryFriendlyByteBuf.decorator(this.server.registryAccess())));
 
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index ee002c2cef9d4810fdacac71de77e948f5b0e89d..8111d3ad0457122e34415716256da7e4bd7a4686 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -130,6 +130,7 @@ import net.minecraft.network.protocol.ping.ServerboundPingRequestPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.FutureChain;
@@ -1849,7 +1850,16 @@ public class ServerGamePacketListenerImpl
 
     @Override
     public void handlePlayerAction(ServerboundPlayerActionPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        // Canvas start - rubberbanding fix
+        try {
+            PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        } catch (RunningOnDifferentThreadException e) {
+            if (packet.getAction() == ServerboundPlayerActionPacket.Action.STOP_DESTROY_BLOCK) {
+                this.player.connection.send(new ClientboundBlockUpdatePacket(packet.getPos(), Blocks.AIR.defaultBlockState()));
+            }
+            throw e;
+        }
+        // Canvas end
         if (this.player.isImmobile()) return; // CraftBukkit
         if (this.player.hasClientLoaded()) {
             BlockPos pos = packet.getPos();
diff --git a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 45ea5fa0ef57724acce46008c53f7fa216cf78ee..723ab0112b840cea8292e46827d86270e107cad8 100644
--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -439,7 +439,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     @Override
     public void handleLoginAcknowledgement(ServerboundLoginAcknowledgedPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server); // CraftBukkit
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // CraftBukkit // Canvas
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.PROTOCOL_SWITCHING, "Unexpected login acknowledgement packet");
         this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
         CommonListenerCookie commonListenerCookie = CommonListenerCookie.createInitial(Objects.requireNonNull(this.authenticatedProfile), this.transferred);
@@ -460,7 +460,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     @Override
     public void handleCookieResponse(ServerboundCookieResponsePacket packet) {
         // CraftBukkit start
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.player != null && this.player.getBukkitEntity().handleCookieResponse(packet)) {
             return;
         }
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 94abb9d8f6381aee000dbd0720477db8b7ca279c..1374c9f1e06dd676c54cf505a6d7e987831195b8 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -11,6 +11,7 @@ import java.net.SocketAddress;
 import java.nio.file.Path;
 import java.text.SimpleDateFormat;
 import java.time.Instant;
+import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -20,6 +21,7 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.Config;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -341,7 +343,7 @@ public abstract class PlayerList {
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
 
-        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
+        final List<ServerPlayer> onlinePlayers = new ArrayList<>(); // Paper - Use single player info update packet on join // Canvas - don't use expected size
         for (int i = 0; i < this.players.size(); ++i) {
             ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
 
@@ -481,7 +483,7 @@ public abstract class PlayerList {
         return optional;
     }
 
-    protected void save(ServerPlayer player) {
+    public void save(ServerPlayer player) { // Canvas - protected -> public
         if (!player.getBukkitEntity().isPersistent()) return; // CraftBukkit
         player.lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
         this.playerIo.save(player);
@@ -884,6 +886,7 @@ public abstract class PlayerList {
     }
 
     public void tick() {
+        if (Config.INSTANCE.runPlayerListTickOnIndependentLevel) return; // Canvas - moved to level threads
         if (++this.sendAllPlayerInfoIn > 600) {
             // CraftBukkit start
             for (int i = 0; i < this.players.size(); ++i) {
diff --git a/net/minecraft/util/debugchart/DebugSampleSubscriptionTracker.java b/net/minecraft/util/debugchart/DebugSampleSubscriptionTracker.java
index 15de39fa82c7aea18298509fe9587d027c30cc15..f23f477d02556f02e4326ab360274bdc96de8fe7 100644
--- a/net/minecraft/util/debugchart/DebugSampleSubscriptionTracker.java
+++ b/net/minecraft/util/debugchart/DebugSampleSubscriptionTracker.java
@@ -1,8 +1,10 @@
 package net.minecraft.util.debugchart;
 
 import com.google.common.collect.Maps;
+import java.util.Collections;
 import java.util.EnumMap;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import net.minecraft.Util;
@@ -15,7 +17,7 @@ public class DebugSampleSubscriptionTracker {
     public static final int STOP_SENDING_AFTER_MS = 10000;
     private final PlayerList playerList;
     private final EnumMap<RemoteDebugSampleType, Map<ServerPlayer, DebugSampleSubscriptionTracker.SubscriptionStartedAt>> subscriptions;
-    private final Queue<DebugSampleSubscriptionTracker.SubscriptionRequest> subscriptionRequestQueue = new LinkedList<>();
+    private final List<SubscriptionRequest> subscriptionRequestQueue = Collections.synchronizedList(new LinkedList<>()); // Canvas
 
     public DebugSampleSubscriptionTracker(PlayerList playerList) {
         this.playerList = playerList;
diff --git a/net/minecraft/util/thread/BlockableEventLoop.java b/net/minecraft/util/thread/BlockableEventLoop.java
index 186c1b2e3599770385150eb7acdcd890aa5835eb..bd48888cc3f8ac1443de522564b4f9fb1f9ec542 100644
--- a/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/net/minecraft/util/thread/BlockableEventLoop.java
@@ -6,6 +6,7 @@ import com.mojang.jtracy.TracyClient;
 import com.mojang.jtracy.Zone;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -13,8 +14,11 @@ import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import javax.annotation.CheckReturnValue;
+import io.canvasmc.canvas.server.level.MinecraftServerWorld;
+import io.canvasmc.canvas.server.level.TickRateManagerInstance;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.util.profiling.metrics.MetricSampler;
 import net.minecraft.util.profiling.metrics.MetricsRegistry;
@@ -126,18 +130,42 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            // Canvas start - Multithreaded Dimension Ticking
+            // This can technically throw a NSE now, so we catch and ignore
+            try {
+                R a = this.pendingRunnables.remove();
+                this.doRunTask(a);
+            } catch (NoSuchElementException ignored) {
+                return false;
+            }
+            // Canvas end
             return true;
         }
     }
 
     public void managedBlock(BooleanSupplier isDone) {
         this.blockingCount++;
+        /* // Canvas start
+        if (this instanceof MinecraftServer && !Thread.currentThread().equals(getRunningThread())) {
+            throw new RuntimeException("Unable to block main thread from off-main");
+        }
+        if (this instanceof MinecraftServerWorld && !Thread.currentThread().equals(getRunningThread())) {
+            throw new RuntimeException("Unable to block level thread from off-level");
+        }
+        */ // Canvas end
 
         try {
             while (!isDone.getAsBoolean()) {
                 if (!this.pollTask()) {
+                    // Canvas start
+                    if (this instanceof TickRateManagerInstance tickRateManagerInstance && !tickRateManagerInstance.tickRateManager().isUnlockedTickRate()) {
                     this.waitForTasks();
+                    } else if (this instanceof TickRateManagerInstance tickRateManagerInstance) {
+                        // Skipping because unlocked
+                        tickRateManagerInstance.skipTickWait();
+                        break;
+                    }
+                    // Canvas end
                 }
             }
         } finally {
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index f61c29abf75443b206f37b90950d6c0e14ea59ff..a0fa0f62357f8f04122622e7b6721c1d9e386446 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.floats.FloatArraySet;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.floats.FloatSet;
@@ -23,6 +24,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -307,9 +309,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean hasVisualFire;
     @Nullable
     private BlockState inBlockState = null;
-    private final List<Entity.Movement> movementThisTick = new ArrayList<>();
-    private final Set<BlockState> blocksInside = new ReferenceArraySet<>();
-    private final LongSet visitedBlocks = new LongOpenHashSet();
+    // Canvas start
+    private final List<Entity.Movement> movementThisTick = new CopyOnWriteArrayList<>();
+    private final Set<BlockState> blocksInside = new ConcurrentSet<>();
+    private final Set<Long> visitedBlocks = new ConcurrentSet<>();
+    // Canvas end
     // CraftBukkit start
     public boolean forceDrops;
     public boolean persist = true;
@@ -1392,8 +1396,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     protected BlockPos getOnPos(float yOffset) {
+        // Canvas start
+        int i = Mth.floor(this.position.x);
+        int j = Mth.floor(this.position.y - (double) yOffset);
+        int k = Mth.floor(this.position.z);
+        BlockPos fallback = new BlockPos(i, j, k);
+        // Canvas end
         if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
-            BlockPos blockPos = this.mainSupportingBlockPos.get();
+            BlockPos blockPos = this.mainSupportingBlockPos.orElse(fallback); // Canvas - fallback
             if (!(yOffset > 1.0E-5F)) {
                 return blockPos;
             } else {
@@ -1405,10 +1415,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                     : blockPos;
             }
         } else {
-            int floor = Mth.floor(this.position.x);
-            int floor1 = Mth.floor(this.position.y - yOffset);
-            int floor2 = Mth.floor(this.position.z);
-            return new BlockPos(floor, floor1, floor2);
+            return fallback; // Canvas - fallback
         }
     }
 
@@ -1653,7 +1660,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     private void checkInsideBlocks(List<Entity.Movement> movements, Set<BlockState> blocksInside) {
         if (this.isAffectedByBlocks()) {
-            LongSet set = this.visitedBlocks;
+            Set<Long> set = this.visitedBlocks; // Canvas
 
             for (Entity.Movement movement : movements) {
                 Vec3 vec3 = movement.from();
@@ -3873,6 +3880,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     private Entity teleportCrossDimension(ServerLevel level, TeleportTransition teleportTransition) {
+        // Canvas start
+        if (this instanceof ServerPlayer player) {
+            player.serverLevel().notifyNewConnection(player.connection.connection);
+        }
+        // Canvas end
         List<Entity> passengers = this.getPassengers();
         List<Entity> list = new ArrayList<>(passengers.size());
         this.ejectPassengers();
@@ -4741,6 +4753,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         if (this.inBlockState == null) {
             this.inBlockState = this.level().getBlockState(this.blockPosition());
         }
+        // Canvas start -- why is it still null... - iirc this only happens when the player is in an ungenerated/generating chunk, fallback to air
+
+        if (this.inBlockState == null) {
+            this.inBlockState = Blocks.AIR.defaultBlockState();
+        }
+        // Canvas end
 
         return this.inBlockState;
     }
@@ -4838,6 +4856,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.setPosRaw(x, y, z, false);
     }
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
+        // Canvas start - ensure section status is caught
+        if (this.updatingSectionStatus) {
+            final double fx = x;
+            final double fy = y;
+            final double fz = z;
+            ((ServerLevel)this.level()).chunkSource.mainThreadProcessor.execute(() -> {
+                this.setPosRaw(fx, fy, fz, forceBoundingBoxUpdate);
+            });
+            return;
+        }
+        // Canvas end
+        // Paper end - Block invalid positions and bounding box
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
@@ -4979,7 +5009,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public final void setRemoved(Entity.RemovalReason removalReason, org.bukkit.event.entity.EntityRemoveEvent.Cause cause) {
         // Paper start - rewrite chunk system
         if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
-            LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
+            // LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable()); // Canvas
             return;
         }
         // Paper end - rewrite chunk system
diff --git a/net/minecraft/world/entity/ai/goal/GoalSelector.java b/net/minecraft/world/entity/ai/goal/GoalSelector.java
index a927c2790c8ab9ccaa7161b970e10b0b44817dd8..0ed26e4866b36c67ff8628ce2fe421ae69467231 100644
--- a/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -99,6 +99,7 @@ public class GoalSelector {
 
         for (WrappedGoal wrappedGoalx : this.availableGoals) {
             // Paper start
+            if (wrappedGoalx == null) continue; // Canvas - NPE
             if (!wrappedGoalx.isRunning() && !goalContainsAnyFlags(wrappedGoalx, this.goalTypes) && goalCanBeReplacedForAllFlags(wrappedGoalx, this.lockedFlags) && wrappedGoalx.canUse()) {
                 long flagIterator = wrappedGoalx.getFlags().getBackingSet();
                 int wrappedGoalSize = wrappedGoalx.getFlags().size();
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 0fe8f4601eedfa68c38ebadc7847ba7a07ff6fb6..19067587d4dc6a752769d5733735b09eb3eeb4db 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -9,9 +9,9 @@ import java.util.List;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.server.level.MinecraftServerWorld;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -24,14 +24,13 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.StringRepresentable;
@@ -103,7 +102,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions
+public abstract class Level extends MinecraftServerWorld implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions // Canvas - Multithreaded Dimension Ticking
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_nether"));
@@ -886,6 +885,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, // Paper - create paper world config
         java.util.concurrent.Executor executor // Paper - Anti-Xray
     ) {
+        super(dimension.location().toString()); // Canvas
         // Paper start - getblock optimisations - cache world height/sections
         final DimensionType dimType = dimensionTypeRegistration.value();
         this.minY = dimType.minY();
@@ -1783,8 +1783,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     @Override
-    public void close() throws IOException {
-        this.getChunkSource().close();
+    // Canvas start - Multithreaded Dimension Ticking
+    public void close() {
+        try {
+            this.getChunkSource().close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    // Canvas end
     }
 
     @Nullable
@@ -1950,7 +1956,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.levelData;
     }
 
-    public abstract TickRateManager tickRateManager();
+    public abstract ServerTickRateManager tickRateManager(); // Canvas
 
     public float getThunderLevel(float partialTick) {
         return Mth.lerp(partialTick, this.oThunderLevel, this.thunderLevel) * this.getRainLevel(partialTick);
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index 761fdcd4a4e18f45547afd8edff44f61c6eeacb4..9722b079cb71e219cf78b1325253db3a449a450c 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -620,7 +620,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
 
     // CraftBukkit start
     public void loadCallback() {
-        if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
+        if (this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         // Paper start
         this.loadedTicketLevel = true;
         // Paper end
@@ -661,7 +661,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
     }
 
     public void unloadCallback() {
-        if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
+        if (!this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         org.bukkit.Server server = this.level.getCraftServer();
         org.bukkit.craftbukkit.event.CraftEventFactory.callEntitiesUnloadEvent(this.level, this.chunkPos, ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(this.locX, this.locZ).getEntityChunk().getAllEntities()); // Paper - rewrite chunk system
         org.bukkit.Chunk bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..c04734f349558b4adae4d6b4b4713fe89d3447e6 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -4,12 +4,14 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    public final ConcurrentLinkedQueue<Entity> entities = new ConcurrentLinkedQueue<>(); // Paper - rewrite chunk system // Canvas
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
@@ -33,13 +35,13 @@ public class EntityTickList {
         // Paper start - rewrite chunk system
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
-        final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+        final Iterator<Entity> iterator = this.entities.iterator(); // Canvas
         try {
             while (iterator.hasNext()) {
                 entity.accept(iterator.next());
             }
         } finally {
-            iterator.finishedIterating();
+            // iterator.finishedIterating(); // Canvas
         }
         // Paper end - rewrite chunk system
     }
diff --git a/net/minecraft/world/level/levelgen/LegacyRandomSource.java b/net/minecraft/world/level/levelgen/LegacyRandomSource.java
index c67168517774a0ad9ca43422a79ef14a8ea0c2e8..39c043ab66ec1434f4bafec642637ac7bb07b8fb 100644
--- a/net/minecraft/world/level/levelgen/LegacyRandomSource.java
+++ b/net/minecraft/world/level/levelgen/LegacyRandomSource.java
@@ -30,22 +30,21 @@ public class LegacyRandomSource implements BitRandomSource {
 
     @Override
     public void setSeed(long seed) {
-        if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", null);
-        } else {
-            this.gaussianSource.reset();
-        }
+        this.seed.set((seed ^ 25214903917L) & 281474976710655L); // Canvas - Multithreaded Dimension Ticking
     }
 
     @Override
     public int next(int size) {
-        long l = this.seed.get();
-        long l1 = l * 25214903917L + 11L & 281474976710655L;
-        if (!this.seed.compareAndSet(l, l1)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", null);
-        } else {
-            return (int)(l1 >> 48 - size);
-        }
+        // Canvas start - Threaded Dimensions
+        long l;
+        long m;
+        do {
+            l = this.seed.get();
+            m = l * 25214903917L + 11L & 281474976710655L;
+        } while (!this.seed.compareAndSet(l, m));
+
+        return (int)(m >>> 48 - size);
+        // Canvas end
     }
 
     @Override
diff --git a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 028eae2f9a459b60e92f3344091083aa93b54485..5471be967493eeae5524354363498bb199e38360 100644
--- a/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -3,7 +3,9 @@ package net.minecraft.world.level.redstone;
 import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -17,7 +19,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
+    private final Deque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>(); // Canvas - fix CME/NPE
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
     private int count = 0;
 
@@ -67,8 +69,10 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
 
     private void runUpdates() {
         try {
+            synchronized (this.stack) { // Canvas
             while (!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
                 for (int i = this.addedThisLayer.size() - 1; i >= 0; i--) {
+                    if (this.addedThisLayer.get(i) == null) continue; // Canvas
                     this.stack.push(this.addedThisLayer.get(i));
                 }
 
@@ -81,7 +85,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
                         break;
                     }
                 }
-            }
+            }} // Canvas
         } finally {
             this.stack.clear();
             this.addedThisLayer.clear();
