From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Wed, 25 Dec 2024 16:48:27 -0800
Subject: [PATCH] Optimize Brain


diff --git a/src/main/java/io/canvasmc/canvas/entity/SensorHelper.java b/src/main/java/io/canvasmc/canvas/entity/SensorHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..38c61ccbd2548bee877a6f0ff3a7582f874e397a
--- /dev/null
+++ b/src/main/java/io/canvasmc/canvas/entity/SensorHelper.java
@@ -0,0 +1,60 @@
+package io.canvasmc.canvas.entity;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.sensing.Sensor;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+
+public class SensorHelper {
+
+    public static void disableSensor(LivingEntity brainedEntity, SensorType<?> sensorType) {
+        if (brainedEntity.level().isClientSide()) {
+            return;
+        }
+        Brain<?> brain = brainedEntity.getBrain();
+        Sensor<?> sensor = (brain).sensors.get(sensorType);
+        if (sensor != null) {
+            //Disable the sensor by setting the maximum last sense time, which will make it count down almost forever
+            // Removing the whole sensor could be an issue, since it may be serialized and used in a future version.
+
+            //Instead of setting to Long.MAX_VALUE, we want to be able to recover the random offset of the sensor:
+            long lastSenseTime = sensor.timeToTick;
+            int senseInterval = sensor.scanRate; //Usual values: 20,40,80,200
+
+            long maxMultipleOfSenseInterval = Long.MAX_VALUE - (Long.MAX_VALUE % senseInterval);
+            maxMultipleOfSenseInterval -= senseInterval;
+            maxMultipleOfSenseInterval += lastSenseTime;
+
+            sensor.timeToTick = (maxMultipleOfSenseInterval);
+        }
+    }
+
+    public static <T extends LivingEntity, U extends Sensor<T>> void enableSensor(T brainedEntity, SensorType<U> sensorType) {
+        enableSensor(brainedEntity, sensorType, false);
+    }
+
+    public static <T extends LivingEntity, U extends Sensor<T>> void enableSensor(T brainedEntity, SensorType<U> sensorType, boolean extraTick) {
+        if (brainedEntity.level().isClientSide()) {
+            return;
+        }
+
+        Brain<?> brain = brainedEntity.getBrain();
+        //noinspection unchecked
+        U sensor = (U) (brain).sensors.get(sensorType);
+        if (sensor != null) {
+            long lastSenseTime = sensor.timeToTick;
+            int senseInterval = sensor.scanRate;
+
+            //Recover the random offset of the sensor:
+            if (lastSenseTime > senseInterval) {
+                lastSenseTime = lastSenseTime % senseInterval;
+                if (extraTick) {
+                    (sensor).timeToTick = (0L);
+                    sensor.tick((ServerLevel) brainedEntity.level(), brainedEntity);
+                }
+            }
+            sensor.timeToTick = (lastSenseTime);
+        }
+    }
+}
diff --git a/src/main/java/io/canvasmc/canvas/util/collections/LongJumpChoiceList.java b/src/main/java/io/canvasmc/canvas/util/collections/LongJumpChoiceList.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d0f0ae21d29230fb3d1daad5ac80c835236f0e4
--- /dev/null
+++ b/src/main/java/io/canvasmc/canvas/util/collections/LongJumpChoiceList.java
@@ -0,0 +1,218 @@
+package io.canvasmc.canvas.util.collections;
+
+import it.unimi.dsi.fastutil.bytes.ByteBytePair;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.ai.behavior.LongJumpToRandomPos;
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class LongJumpChoiceList extends AbstractList<LongJumpToRandomPos.PossibleJump> {
+
+    /**
+     * A cache of choice lists for different ranges. The elements must not be mutated, but copied instead.
+     * In vanilla minecraft there should be two elements, one for frog jumps and one for goat jumps.
+     */
+    private static final ConcurrentHashMap<ByteBytePair, LongJumpChoiceList> CHOICE_LISTS = new ConcurrentHashMap<>();
+    /**
+     * The choice list for frog jumps. Skipping the hash map access. Must not be mutated, but copied instead.
+     */
+    private static final LongJumpChoiceList FROG_JUMP = new LongJumpChoiceList((byte) 4, (byte) 2);
+    /**
+     * The choice list for goat jumps. Skipping the hash map access. Must not be mutated, but copied instead.
+     */
+    private static final LongJumpChoiceList GOAT_JUMP = new LongJumpChoiceList((byte) 5, (byte) 5);
+
+
+    private final BlockPos origin;
+    private final IntArrayList[] packedOffsetsByDistanceSq;
+    private final int[] weightByDistanceSq;
+    private int totalWeight;
+
+    /**
+     * Constructs a new LongJumpChoiceList with the given horizontal and vertical range.
+     * We avoid creating too many objects here, e.g. LongJumpTask.Target is not created yet.
+     * @param horizontalRange the horizontal range
+     * @param verticalRange the vertical range
+     */
+    public LongJumpChoiceList(byte horizontalRange, byte verticalRange) {
+        if (horizontalRange < 0 || verticalRange < 0) {
+            throw new IllegalArgumentException("The ranges must be within 0..127!");
+        }
+
+        this.origin = BlockPos.ZERO;
+        int maxSqDistance = horizontalRange*horizontalRange * 2 + verticalRange*verticalRange;
+        this.packedOffsetsByDistanceSq = new IntArrayList[maxSqDistance];
+        this.weightByDistanceSq = new int[maxSqDistance];
+
+        for (int x = -horizontalRange; x <= horizontalRange; x++) {
+            for (int y = -verticalRange; y <= verticalRange; y++) {
+                for (int z = -horizontalRange; z <= horizontalRange; z++) {
+                    int squaredDistance = x * x + y * y + z * z;
+                    int index = squaredDistance - 1;
+                    if (index >= 0) { //exclude origin (distance 0)
+                        int packedOffset = this.packOffset(x, y, z);
+                        IntArrayList offsets = this.packedOffsetsByDistanceSq[index];
+                        if (offsets == null) {
+                            this.packedOffsetsByDistanceSq[index] = offsets = new IntArrayList();
+                        }
+                        offsets.add(packedOffset);
+                        this.weightByDistanceSq[index] += squaredDistance;
+                        this.totalWeight += squaredDistance;
+                    }
+                }
+            }
+        }
+    }
+
+    public LongJumpChoiceList(BlockPos origin, IntArrayList[] packedOffsetsByDistanceSq, int[] weightByDistanceSq, int totalWeight) {
+        this.origin = origin;
+        this.packedOffsetsByDistanceSq = packedOffsetsByDistanceSq;
+        this.weightByDistanceSq = weightByDistanceSq;
+        this.totalWeight = totalWeight;
+    }
+
+    private int packOffset(int x, int y, int z) {
+        return (x + 128) | ((y + 128) << 8) | ((z + 128) << 16);
+    }
+
+    private int unpackX(int packedOffset) {
+        return (packedOffset & 0xFF) - 128;
+    }
+
+    private int unpackY(int packedOffset) {
+        return ((packedOffset >>> 8) & 0xFF) - 128;
+    }
+
+    private int unpackZ(int packedOffset) {
+        return ((packedOffset >>> 16) & 0xFF) - 128;
+    }
+
+    /**
+     * Returns a LongJumpChoiceList for the given center position and ranges.
+     * Quickly creates the list by copying an existing, memoized list.
+     * @param centerPos the center position
+     * @param horizontalRange the horizontal range
+     * @param verticalRange the vertical range
+     * @return a LongJumpChoiceList for the given parameters
+     */
+    public static LongJumpChoiceList forCenter(BlockPos centerPos, byte horizontalRange, byte verticalRange) {
+        if (horizontalRange < 0 || verticalRange < 0) {
+            throw new IllegalArgumentException("The ranges must be within 0..127!");
+        }
+
+        LongJumpChoiceList jumpDestinationsList;
+        short range = (short) ((horizontalRange << 8) | verticalRange);
+        if (range == ((4 << 8) | 2)) {
+            //Frog jump
+            jumpDestinationsList = LongJumpChoiceList.FROG_JUMP;
+        } else if (range == ((5 << 8) | 5)) {
+            //Goat jump
+            jumpDestinationsList = LongJumpChoiceList.GOAT_JUMP;
+        } else {
+            jumpDestinationsList = LongJumpChoiceList.CHOICE_LISTS.computeIfAbsent(
+                ByteBytePair.of(horizontalRange, verticalRange),
+                key -> new LongJumpChoiceList(key.leftByte(), key.rightByte())
+            );
+        }
+
+        return jumpDestinationsList.offsetCopy(centerPos);
+    }
+
+    private LongJumpChoiceList offsetCopy(BlockPos offset) {
+        IntArrayList[] packedOffsetsByDistanceSq = new IntArrayList[this.packedOffsetsByDistanceSq.length];
+        for (int i = 0; i < packedOffsetsByDistanceSq.length; i++) {
+            IntArrayList packedOffsets = this.packedOffsetsByDistanceSq[i];
+            if (packedOffsets != null) {
+                packedOffsetsByDistanceSq[i] = packedOffsets.clone();
+            }
+        }
+
+        return new LongJumpChoiceList(
+            this.origin.offset(offset),
+            packedOffsetsByDistanceSq,
+            Arrays.copyOf(this.weightByDistanceSq, this.weightByDistanceSq.length), this.totalWeight);
+    }
+
+    /**
+     * Removes and returns a random target from the list, weighted by squared distance.
+     * @param random the random number generator
+     * @return a random target
+     */
+    public LongJumpToRandomPos.PossibleJump removeRandomWeightedByDistanceSq(RandomSource random) {
+        int targetWeight = random.nextInt(this.totalWeight);
+        for (int index = 0; targetWeight >= 0 && index < this.weightByDistanceSq.length; index++) {
+            targetWeight -= this.weightByDistanceSq[index];
+            if (targetWeight < 0) {
+                int distanceSq = index + 1;
+                IntArrayList elementsOfDistance = this.packedOffsetsByDistanceSq[index];
+                int elementIndex = random.nextInt(elementsOfDistance.size());
+
+                //fast remove by swapping to end and removing, order does not matter
+                elementsOfDistance.set(elementIndex, elementsOfDistance.set(elementsOfDistance.size() - 1, elementsOfDistance.getInt(elementIndex)));
+                int packedOffset = elementsOfDistance.removeInt(elementsOfDistance.size() - 1);
+                this.weightByDistanceSq[index] -= distanceSq;
+                this.totalWeight -= distanceSq;
+
+                return new LongJumpToRandomPos.PossibleJump(this.origin.offset(this.unpackX(packedOffset), this.unpackY(packedOffset), this.unpackZ(packedOffset)), distanceSq);
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public LongJumpToRandomPos.PossibleJump get(int index) {
+        int elementIndex = index;
+        IntArrayList[] offsetsByDistanceSq = this.packedOffsetsByDistanceSq;
+        for (int distanceSq = 0; distanceSq < offsetsByDistanceSq.length; distanceSq++) {
+            IntArrayList packedOffsets = offsetsByDistanceSq[distanceSq];
+            if (packedOffsets != null) {
+                if (elementIndex < packedOffsets.size()) {
+                    int packedOffset = packedOffsets.getInt(elementIndex);
+                    return new LongJumpToRandomPos.PossibleJump(this.origin.offset(this.unpackX(packedOffset), this.unpackY(packedOffset), this.unpackZ(packedOffset)), distanceSq);
+                }
+                elementIndex -= packedOffsets.size();
+            }
+        }
+        throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.totalWeight == 0;
+    }
+
+    @Override
+    public int size() {
+        int size = 0;
+        for (IntArrayList packedOffsets : this.packedOffsetsByDistanceSq) {
+            if (packedOffsets != null) {
+                size += packedOffsets.size();
+            }
+        }
+        return size;
+    }
+
+    @Override
+    public LongJumpToRandomPos.PossibleJump remove(int index) {
+        int elementIndex = index;
+        IntArrayList[] offsetsByDistanceSq = this.packedOffsetsByDistanceSq;
+        for (int distanceSq = 0; distanceSq < offsetsByDistanceSq.length; distanceSq++) {
+            IntArrayList packedOffsets = offsetsByDistanceSq[distanceSq];
+            if (packedOffsets != null) {
+                if (elementIndex < packedOffsets.size()) {
+                    int packedOffset = packedOffsets.getInt(elementIndex);
+                    packedOffsets.set(elementIndex, packedOffsets.set(packedOffsets.size() - 1, packedOffsets.getInt(elementIndex)));
+                    packedOffsets.removeInt(packedOffsets.size() - 1);
+                    this.weightByDistanceSq[distanceSq] -= distanceSq;
+                    this.totalWeight -= distanceSq;
+                    return new LongJumpToRandomPos.PossibleJump(this.origin.offset(this.unpackX(packedOffset), this.unpackY(packedOffset), this.unpackZ(packedOffset)), distanceSq);
+                }
+                elementIndex -= packedOffsets.size();
+            }
+        }
+        throw new IndexOutOfBoundsException();
+    }
+}
diff --git a/src/main/java/io/canvasmc/canvas/util/collections/MaskedList.java b/src/main/java/io/canvasmc/canvas/util/collections/MaskedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df9a2a0406b89d5f63bf1874216a14da88262d2
--- /dev/null
+++ b/src/main/java/io/canvasmc/canvas/util/collections/MaskedList.java
@@ -0,0 +1,152 @@
+package io.canvasmc.canvas.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import java.util.AbstractList;
+import java.util.BitSet;
+import java.util.Iterator;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.function.Consumer;
+
+public class MaskedList<E> extends AbstractList<E> {
+    private final ObjectArrayList<E> allElements;
+    private final BitSet visibleMask;
+    private final Object2IntOpenHashMap<E> element2Index;
+    private final boolean defaultVisibility;
+    private int numCleared;
+
+    public MaskedList(ObjectArrayList<E> allElements, boolean defaultVisibility) {
+        this.allElements = new ObjectArrayList<>();
+        this.visibleMask = new BitSet();
+        this.defaultVisibility = defaultVisibility;
+        this.element2Index = new Object2IntOpenHashMap<>();
+        this.element2Index.defaultReturnValue(-1);
+
+        this.addAll(allElements);
+    }
+
+    public MaskedList() {
+        this(new ObjectArrayList<>(), true);
+    }
+
+    public int totalSize() {
+        return this.allElements.size();
+    }
+
+
+    public void addOrSet(E element, boolean visible) {
+        int index = this.element2Index.getInt(element);
+        if (index != -1) {
+            this.visibleMask.set(index, visible);
+        } else {
+            this.add(element);
+            this.setVisible(element, visible);
+        }
+    }
+
+    public void setVisible(E element, final boolean visible) {
+        int index = this.element2Index.getInt(element);
+        if (index != -1) {
+            this.visibleMask.set(index, visible);
+        }
+        //ignore when the element is not in the collection
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new Iterator<>() {
+            int nextIndex = 0;
+            int cachedNext = -1;
+
+            @Override
+            public boolean hasNext() {
+                return (this.cachedNext = MaskedList.this.visibleMask.nextSetBit(this.nextIndex)) != -1;
+            }
+
+            @Override
+            public E next() {
+                int index = this.cachedNext;
+                this.cachedNext = -1;
+                this.nextIndex = index + 1;
+                return MaskedList.this.allElements.get(index);
+            }
+        };
+    }
+
+    @Override
+    public Spliterator<E> spliterator() {
+        return new Spliterators.AbstractSpliterator<E>(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.NONNULL) {
+            int nextIndex = 0;
+
+            @Override
+            public boolean tryAdvance(Consumer<? super E> action) {
+                int index = MaskedList.this.visibleMask.nextSetBit(this.nextIndex);
+                if (index == -1) {
+                    return false;
+                }
+                this.nextIndex = index + 1;
+                action.accept(MaskedList.this.allElements.get(index));
+                return true;
+            }
+        };
+    }
+
+    @Override
+    public boolean add(E e) {
+        int oldIndex = this.element2Index.put(e, this.allElements.size());
+        if (oldIndex != -1) {
+            throw new IllegalStateException("MaskedList must not contain duplicates! Trying to add " + e + " but it is already present at index " + oldIndex + ". Current size: " + this.allElements.size());
+        }
+        this.visibleMask.set(this.allElements.size(), this.defaultVisibility);
+        return this.allElements.add(e);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        int index = this.element2Index.removeInt(o);
+        if (index == -1) {
+            return false;
+        }
+        this.visibleMask.clear(index);
+        this.allElements.set(index, null);
+        this.numCleared++;
+
+
+        if (this.numCleared * 2 > this.allElements.size()) {
+            ObjectArrayList<E> clonedElements = this.allElements.clone();
+            BitSet clonedVisibleMask = (BitSet) this.visibleMask.clone();
+            this.allElements.clear();
+            this.visibleMask.clear();
+            this.element2Index.clear();
+            for (int i = 0; i < clonedElements.size(); i++) {
+                E element = clonedElements.get(i);
+                int newIndex = this.allElements.size();
+                this.allElements.add(element);
+                this.visibleMask.set(newIndex, clonedVisibleMask.get(i));
+                this.element2Index.put(element, newIndex);
+            }
+            this.numCleared = 0;
+        }
+        return true;
+    }
+
+    @Override
+    public E get(int index) {
+        if (index < 0 || index >= this.size()) {
+            throw new IndexOutOfBoundsException(index);
+        }
+
+        int i = 0;
+        while (index >= 0) {
+            index--;
+            i = this.visibleMask.nextSetBit(i + 1);
+        }
+        return this.allElements.get(i);
+    }
+
+    @Override
+    public int size() {
+        return this.visibleMask.cardinality();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/AgeableMob.java b/src/main/java/net/minecraft/world/entity/AgeableMob.java
index 119856b22df5bbcd4e5bf5f95645156f774c6168..bf1dfe6fd96ef5f46f573bc10842da4c83d34f3c 100644
--- a/src/main/java/net/minecraft/world/entity/AgeableMob.java
+++ b/src/main/java/net/minecraft/world/entity/AgeableMob.java
@@ -2,6 +2,7 @@ package net.minecraft.world.entity;
 
 import com.google.common.annotations.VisibleForTesting;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.entity.SensorHelper;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.syncher.EntityDataAccessor;
@@ -9,9 +10,12 @@ import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.DifficultyInstance;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.sensing.SensorType;
 import net.minecraft.world.entity.vehicle.AbstractBoat;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
+import java.util.Optional;
 
 public abstract class AgeableMob extends PathfinderMob {
 
@@ -146,6 +150,16 @@ public abstract class AgeableMob extends PathfinderMob {
     public void onSyncedDataUpdated(EntityDataAccessor<?> data) {
         if (AgeableMob.DATA_BABY_ID.equals(data)) {
             this.refreshDimensions();
+            // Canvas start
+            if (isBaby()) {
+                SensorHelper.enableSensor(this, SensorType.NEAREST_ADULT, true);
+            } else {
+                SensorHelper.disableSensor(this, SensorType.NEAREST_ADULT);
+                if (this.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_VISIBLE_ADULT)) {
+                    this.getBrain().setMemory(MemoryModuleType.NEAREST_VISIBLE_ADULT, Optional.empty());
+                }
+            }
+            // Canvas end
         }
 
         super.onSyncedDataUpdated(data);
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index 4525483dbada9555cac8d8bd2fe9df476f836661..f3209d6e577992668b4a1685ae6da540cb2eecbb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -15,7 +15,10 @@ import com.mojang.serialization.DynamicOps;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.MapLike;
 import com.mojang.serialization.RecordBuilder;
+import io.canvasmc.canvas.util.collections.MaskedList;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
@@ -25,6 +28,8 @@ import java.util.Map.Entry;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.VisibleForDebug;
@@ -45,16 +50,73 @@ public class Brain<E extends LivingEntity> {
     static final Logger LOGGER = LogUtils.getLogger();
     private final Supplier<Codec<Brain<E>>> codec;
     private static final int SCHEDULE_UPDATE_DELAY = 20;
-    private final Map<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> memories = Maps.newHashMap();
-    private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
-    private final Map<Integer, Map<Activity, Set<BehaviorControl<? super E>>>> availableBehaviorsByPriority = Maps.newTreeMap();
+    private Map<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> memories = Maps.newHashMap();
+    public Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap(); // Canvas - mutable / private -> public
+    private final Map<Integer, Map<Activity, Set<BehaviorControl<? super E>>>> availableBehaviorsByPriority = Maps.newTreeMap(); // Canvas - mutable
     private Schedule schedule = Schedule.EMPTY;
-    private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> activityRequirements = Maps.newHashMap();
+    private Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> activityRequirements = Maps.newHashMap(); // Canvas - mutable
     private final Map<Activity, Set<MemoryModuleType<?>>> activityMemoriesToEraseWhenStopped = Maps.newHashMap();
     private Set<Activity> coreActivities = Sets.newHashSet();
     private final Set<Activity> activeActivities = Sets.newHashSet();
     private Activity defaultActivity = Activity.IDLE;
     private long lastScheduleUpdate = -9999L;
+    // Canvas start - optimize brain
+    private ArrayList<BehaviorControl<? super E>> possibleTasks;
+    private MaskedList<BehaviorControl<? super E>> runningTasks;
+
+    private void onTasksChanged() {
+        this.runningTasks = null;
+        this.onPossibleActivitiesChanged();
+    }
+
+    private void onPossibleActivitiesChanged() {
+        this.possibleTasks = null;
+    }
+
+    private void initPossibleTasks() {
+        this.possibleTasks = new ArrayList<>();
+        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
+            for (Map.Entry<Activity, Set<BehaviorControl<? super E>>> entry : map.entrySet()) {
+                Activity activity = entry.getKey();
+                if (!this.activeActivities.contains(activity)) {
+                    continue;
+                }
+                Set<BehaviorControl<? super E>> set = entry.getValue();
+                for (BehaviorControl<? super E> task : set) {
+                    //noinspection UseBulkOperation
+                    this.possibleTasks.add(task);
+                }
+            }
+        }
+    }
+
+    private ArrayList<BehaviorControl<? super E>> getPossibleTasks() {
+        if (this.possibleTasks == null) {
+            this.initPossibleTasks();
+        }
+        return this.possibleTasks;
+    }
+
+    private MaskedList<BehaviorControl<? super E>> getCurrentlyRunningTasks() {
+        if (this.runningTasks == null) {
+            this.initCurrentlyRunningTasks();
+        }
+        return this.runningTasks;
+    }
+
+    private void initCurrentlyRunningTasks() {
+        MaskedList<BehaviorControl<? super E>> list = new MaskedList<>(new ObjectArrayList<>(), false);
+
+        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
+            for (Set<BehaviorControl<? super E>> set : map.values()) {
+                for (BehaviorControl<? super E> task : set) {
+                    list.addOrSet(task, task.getStatus() == Behavior.Status.RUNNING);
+                }
+            }
+        }
+        this.runningTasks = list;
+    }
+    // Canvas end
 
     public static <E extends LivingEntity> Brain.Provider<E> provider(
         Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors
@@ -145,6 +207,12 @@ public class Brain<E extends LivingEntity> {
         for (Brain.MemoryValue<?> memoryValue : memoryEntries) {
             memoryValue.setMemoryInternal(this);
         }
+        this.onTasksChanged(); // Canvas - optimize brain
+        // Canvas start - use fastutil
+        this.memories = new Reference2ReferenceOpenHashMap<>(this.memories);
+        this.sensors = new Reference2ReferenceLinkedOpenHashMap<>(this.sensors);
+        this.activityRequirements = new Object2ObjectOpenHashMap<>(this.activityRequirements);
+        // Canvas end
     }
 
     public <T> DataResult<T> serializeStart(DynamicOps<T> ops) {
@@ -184,10 +252,26 @@ public class Brain<E extends LivingEntity> {
             if (memory.isPresent() && this.isEmptyCollection(memory.get().getValue())) {
                 this.eraseMemory(type);
             } else {
-                this.memories.put(type, memory);
+                this.increaseMemoryModificationCount(this.memories, type, memory); // Canvas
             }
         }
     }
+    // Canvas start - optimize brain
+
+    private long memoryModCount = 1;
+
+    public long getMemoryModCount() {
+        return memoryModCount;
+    }
+
+    private <T, A> Object increaseMemoryModificationCount(Map<T, A> map, T key, A newValue) {
+        Object oldValue = map.put(key, newValue);
+        if (oldValue == null || ((Optional<?>) oldValue).isPresent() != ((Optional<?>) newValue).isPresent()) {
+            this.memoryModCount++;
+        }
+        return oldValue;
+    }
+    // Canvas end
 
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
         Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
@@ -252,19 +336,7 @@ public class Brain<E extends LivingEntity> {
     @Deprecated
     @VisibleForDebug
     public List<BehaviorControl<? super E>> getRunningBehaviors() {
-        List<BehaviorControl<? super E>> list = new ObjectArrayList<>();
-
-        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
-            for (Set<BehaviorControl<? super E>> set : map.values()) {
-                for (BehaviorControl<? super E> behaviorControl : set) {
-                    if (behaviorControl.getStatus() == Behavior.Status.RUNNING) {
-                        list.add(behaviorControl);
-                    }
-                }
-            }
-        }
-
-        return list;
+        return this.getCurrentlyRunningTasks(); // Canvas - optimize brain
     }
 
     public void useDefaultActivity() {
@@ -295,6 +367,7 @@ public class Brain<E extends LivingEntity> {
             this.activeActivities.clear();
             this.activeActivities.addAll(this.coreActivities);
             this.activeActivities.add(except);
+            this.onPossibleActivitiesChanged(); // Canvas - optimize brain
         }
     }
 
@@ -375,11 +448,13 @@ public class Brain<E extends LivingEntity> {
                 .computeIfAbsent(activity, activity2 -> Sets.newLinkedHashSet())
                 .add((BehaviorControl<? super E>)pair.getSecond());
         }
+        this.onTasksChanged(); // Canvas - optimize brain
     }
 
     @VisibleForTesting
     public void removeAllBehaviors() {
         this.availableBehaviorsByPriority.clear();
+        this.onTasksChanged(); // Canvas - optimize brain
     }
 
     public boolean isActive(Activity activity) {
@@ -396,6 +471,7 @@ public class Brain<E extends LivingEntity> {
             }
         }
 
+        brain.memoryModCount = this.memoryModCount + 1; // Canvas - optimize brain
         return brain;
     }
 
@@ -430,22 +506,24 @@ public class Brain<E extends LivingEntity> {
 
         for (BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
             behaviorControl.doStop(world, entity, l);
+            // Canvas start - optimize brain
+            if (this.runningTasks != null) {
+                this.runningTasks.setVisible(behaviorControl, false);
+            }
+            // Canvas end
         }
     }
 
     private void startEachNonRunningBehavior(ServerLevel world, E entity) {
-        long l = world.getGameTime();
-
-        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
-            for (Entry<Activity, Set<BehaviorControl<? super E>>> entry : map.entrySet()) {
-                Activity activity = entry.getKey();
-                if (this.activeActivities.contains(activity)) {
-                    for (BehaviorControl<? super E> behaviorControl : entry.getValue()) {
-                        if (behaviorControl.getStatus() == Behavior.Status.STOPPED) {
-                            behaviorControl.tryStart(world, entity, l);
-                        }
-                    }
+        // Canvas start - optimize brain
+        long startTime = world.getGameTime();
+        for (BehaviorControl<? super E> task : this.getPossibleTasks()) {
+            if (task.getStatus() == Behavior.Status.STOPPED) {
+                task.tryStart(world, entity, startTime);
+                if (this.runningTasks != null && task.getStatus() == Behavior.Status.RUNNING) {
+                    this.runningTasks.setVisible(task, true);
                 }
+        // Canvas end
             }
         }
     }
@@ -455,6 +533,11 @@ public class Brain<E extends LivingEntity> {
 
         for (BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
             behaviorControl.tickOrStop(world, entity, l);
+            // Canvas start - optimize brain
+            if (this.runningTasks != null && behaviorControl.getStatus() != Behavior.Status.RUNNING) {
+                this.runningTasks.setVisible(behaviorControl, false);
+            }
+            // Canvas end
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
index ba951cc1aaa94b58ee7985f197d41cc8be747fc8..3a085a9678dfcc94207fc6026bccac519a1f04b5 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
@@ -2,8 +2,12 @@ package net.minecraft.world.entity.ai.behavior;
 
 import java.util.Map;
 import java.util.Map.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.memory.MemoryStatus;
 
@@ -14,6 +18,10 @@ public abstract class Behavior<E extends LivingEntity> implements BehaviorContro
     private long endTimestamp;
     private final int minDuration;
     private final int maxDuration;
+    // Canvas start
+    private long cachedMemoryModCount = -1;
+    private boolean cachedHasRequiredMemoryState;
+    // Canvas end
     // Paper start - configurable behavior tick rate and timings
     private final String configKey;
     // Paper end - configurable behavior tick rate and timings
@@ -29,7 +37,7 @@ public abstract class Behavior<E extends LivingEntity> implements BehaviorContro
     public Behavior(Map<MemoryModuleType<?>, MemoryStatus> requiredMemoryState, int minRunTime, int maxRunTime) {
         this.minDuration = minRunTime;
         this.maxDuration = maxRunTime;
-        this.entryCondition = requiredMemoryState;
+        this.entryCondition = new Reference2ObjectOpenHashMap<>(requiredMemoryState); // Canvas - use fastutil
         // Paper start - configurable behavior tick rate and timings
         String key = io.papermc.paper.util.MappingEnvironment.reobf() ? io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(this.getClass().getName()) : this.getClass().getName();
         int lastSeparator = key.lastIndexOf('.');
@@ -105,16 +113,25 @@ public abstract class Behavior<E extends LivingEntity> implements BehaviorContro
         return this.getClass().getSimpleName();
     }
 
-    protected boolean hasRequiredMemories(E entity) {
-        for (Entry<MemoryModuleType<?>, MemoryStatus> entry : this.entryCondition.entrySet()) {
-            MemoryModuleType<?> memoryModuleType = entry.getKey();
-            MemoryStatus memoryStatus = entry.getValue();
-            if (!entity.getBrain().checkMemory(memoryModuleType, memoryStatus)) {
-                return false;
+    // Canvas start - optimize brain
+    public boolean hasRequiredMemories(E entity) {
+        Brain<?> brain = entity.getBrain();
+        long modCount = brain.getMemoryModCount();
+        if (this.cachedMemoryModCount == modCount) {
+            return this.cachedHasRequiredMemoryState;
+        }
+        this.cachedMemoryModCount = modCount;
+
+        ObjectIterator<Reference2ObjectMap.Entry<MemoryModuleType<?>, MemoryStatus>> fastIterator = ((Reference2ObjectOpenHashMap<MemoryModuleType<?>, MemoryStatus>) this.entryCondition).reference2ObjectEntrySet().fastIterator();
+        while (fastIterator.hasNext()) {
+            Reference2ObjectMap.Entry<MemoryModuleType<?>, MemoryStatus> entry = fastIterator.next();
+            if (!brain.checkMemory(entry.getKey(), entry.getValue())) {
+                return this.cachedHasRequiredMemoryState = false;
             }
         }
 
-        return true;
+        return this.cachedHasRequiredMemoryState = true;
+    // Canvas end
     }
 
     public static enum Status {
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/LongJumpToRandomPos.java b/src/main/java/net/minecraft/world/entity/ai/behavior/LongJumpToRandomPos.java
index c1c3bca7123a6360d5e8fd69bf3819b0b7e2da8a..3d5a8ace8fb07ad23f15891771fdbe47db7ca835 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/LongJumpToRandomPos.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/LongJumpToRandomPos.java
@@ -6,14 +6,17 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import java.util.function.BiPredicate;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.util.collections.LongJumpChoiceList;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.util.Mth;
+import net.minecraft.util.RandomSource;
 import net.minecraft.util.random.WeightedEntry;
 import net.minecraft.util.random.WeightedRandom;
 import net.minecraft.util.valueproviders.UniformInt;
@@ -118,6 +121,12 @@ public class LongJumpToRandomPos<E extends Mob> extends Behavior<E> {
         int i = blockPos.getX();
         int j = blockPos.getY();
         int k = blockPos.getZ();
+        // Canvas start
+        if (this.maxLongJumpWidth < 128 && this.maxLongJumpHeight < 128) {
+            this.jumpCandidates = LongJumpChoiceList.forCenter(blockPos, (byte) this.maxLongJumpWidth, (byte) this.maxLongJumpHeight);
+            return;
+        }
+        // Canvas end
         this.jumpCandidates = BlockPos.betweenClosedStream(
                 i - this.maxLongJumpWidth,
                 j - this.maxLongJumpHeight,
@@ -174,10 +183,26 @@ public class LongJumpToRandomPos<E extends Mob> extends Behavior<E> {
     }
 
     protected Optional<LongJumpToRandomPos.PossibleJump> getJumpCandidate(ServerLevel world) {
-        Optional<LongJumpToRandomPos.PossibleJump> optional = WeightedRandom.getRandomItem(world.random, this.jumpCandidates);
-        optional.ifPresent(this.jumpCandidates::remove);
+        Optional<LongJumpToRandomPos.PossibleJump> optional = getRandomFast(world.random, this.jumpCandidates); // Canvas - use fast
+        skipRemoveIfAlreadyRemoved(optional, this.jumpCandidates::remove); // Canvas - skip if already removed
         return optional;
     }
+    // Canvas start - optimize impl
+
+    private Optional<LongJumpToRandomPos.PossibleJump> getRandomFast(RandomSource random, List<LongJumpToRandomPos.PossibleJump> pool) {
+        if (pool instanceof LongJumpChoiceList longJumpChoiceList) {
+            return Optional.ofNullable(longJumpChoiceList.removeRandomWeightedByDistanceSq(random));
+        } else {
+            return WeightedRandom.getRandomItem(random, pool);
+        }
+    }
+
+    private void skipRemoveIfAlreadyRemoved(Optional<LongJumpToRandomPos.PossibleJump> result, Consumer<? super PossibleJump> removeAction) {
+        if (!(this.jumpCandidates instanceof LongJumpChoiceList)) {
+            result.ifPresent(removeAction);
+        }
+    }
+    // Canvas end
 
     private boolean isAcceptableLandingPosition(ServerLevel world, E entity, BlockPos pos) {
         BlockPos blockPos = entity.blockPosition();
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
index fb1f5375eafb030ae08c735a80e9c8149726cda4..e965ab98967f5f9c2425cd959342511177ea9153 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
@@ -27,8 +27,8 @@ public abstract class Sensor<E extends LivingEntity> {
         .range(16.0)
         .ignoreLineOfSight()
         .ignoreInvisibilityTesting();
-    private final int scanRate;
-    private long timeToTick;
+    public final int scanRate; // Canvas - private -> public
+    public long timeToTick; // Canvas - private -> public
     // Paper start - configurable sensor tick rate and timings
     private final String configKey;
     // Paper end
diff --git a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
index 54485641271a0570a4c6229eb1c5cb8ddff534b4..acd314e3ca6cf089a4a495dca90071579a54c780 100644
--- a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
+++ b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
@@ -3,6 +3,8 @@ package net.minecraft.world.entity.animal.goat;
 import com.google.common.collect.ImmutableList;
 import com.mojang.serialization.Dynamic;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.entity.SensorHelper;
+import net.minecraft.SharedConstants;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
@@ -80,6 +82,13 @@ public class Goat extends Animal {
         this.getNavigation().setCanFloat(true);
         this.setPathfindingMalus(PathType.POWDER_SNOW, -1.0F);
         this.setPathfindingMalus(PathType.DANGER_POWDER_SNOW, -1.0F);
+        // Canvas start - disable useless sensor
+        if (!this.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM)) {
+            SensorHelper.disableSensor(this, SensorType.NEAREST_ITEMS);
+        } else if (SharedConstants.IS_RUNNING_IN_IDE) {
+            throw new IllegalStateException("Goat Entity has a nearest visible wanted item memory module! This patch(Optimize-Brain, Goat.java changes) should probably be removed permanently!");
+        }
+        // Canvas end
     }
 
     public ItemStack createHorn() {
