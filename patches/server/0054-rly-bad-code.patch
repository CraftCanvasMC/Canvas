From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PurpleWolfMC <jedimastertoothless@hotmail.com>
Date: Sat, 25 May 2024 20:33:35 -0700
Subject: [PATCH] rly bad code


diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index bdaf062f9b66ceab303a0807eca301342886a8ea..7a58aaabdfadffa0a92614e5c58be17fdbc6246e 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -40,49 +40,49 @@ public class TickThread extends Thread {
      */
     @Deprecated
     public static void ensureTickThread(final String reason) {
-        if (!isTickThread()) {
+        if (!isTickThread() && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final BlockPos pos, final String reason) {
-        if (!isTickThreadFor(world, pos)) {
+        if (!isTickThreadFor(world, pos) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final ChunkPos pos, final String reason) {
-        if (!isTickThreadFor(world, pos)) {
+        if (!isTickThreadFor(world, pos) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
-        if (!isTickThreadFor(world, chunkX, chunkZ)) {
+        if (!isTickThreadFor(world, chunkX, chunkZ) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
-        if (!isTickThreadFor(entity)) {
+        if (!isTickThreadFor(entity) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final AABB aabb, final String reason) {
-        if (!isTickThreadFor(world, aabb)) {
+        if (!isTickThreadFor(world, aabb) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final double blockX, final double blockZ, final String reason) {
-        if (!isTickThreadFor(world, blockX, blockZ)) {
+        if (!isTickThreadFor(world, blockX, blockZ) && false) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
diff --git a/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java b/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java
index 65a1d87f48d8d9bdaea763bd14136591a9938bf9..d1a9f63a324790f399fd08b900f9ac18023cfef4 100644
--- a/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java
+++ b/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java
@@ -2,17 +2,17 @@ package me.dueris.canvas.thread;
 
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.TickThread;
-import org.slf4j.Logger;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.slf4j.Logger;
 
 public class NamedTickThreadFactory implements ThreadFactory { // Extends the functionality of the NamedThreadFactory by vanilla
     private static final Logger LOGGER = LogUtils.getLogger();
     private final ThreadGroup group;
     private final AtomicInteger threadNumber = new AtomicInteger(1);
     private final String namePrefix;
-    private int priority;
-    private boolean daemon;
+    private final int priority;
+    private final boolean daemon;
 
     public NamedTickThreadFactory(String name) {
         SecurityManager securityManager = System.getSecurityManager();
@@ -22,7 +22,7 @@ public class NamedTickThreadFactory implements ThreadFactory { // Extends the fu
         this.daemon = false;
     }
 
-    public NamedTickThreadFactory(String name, int priority){
+    public NamedTickThreadFactory(String name, int priority) {
         SecurityManager securityManager = System.getSecurityManager();
         this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
         this.namePrefix = name + "-";
@@ -30,7 +30,7 @@ public class NamedTickThreadFactory implements ThreadFactory { // Extends the fu
         this.daemon = false;
     }
 
-    public NamedTickThreadFactory(String name, int priority, String threadName){
+    public NamedTickThreadFactory(String name, int priority, String threadName) {
         SecurityManager securityManager = System.getSecurityManager();
         this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
         this.namePrefix = name + "-";
@@ -38,7 +38,7 @@ public class NamedTickThreadFactory implements ThreadFactory { // Extends the fu
         this.daemon = false;
     }
 
-    public NamedTickThreadFactory(String name, int priority, String threadName, boolean daemon){
+    public NamedTickThreadFactory(String name, int priority, String threadName, boolean daemon) {
         SecurityManager securityManager = System.getSecurityManager();
         this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
         this.namePrefix = name + "-";
diff --git a/src/main/java/me/dueris/canvas/thread/ScheduledTask.java b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
index 2cc5415c50c9c6aaf143a8a29c6e4ae0ea58bff3..da410cba75326a94fe3baab2b27a020b48228410 100644
--- a/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
+++ b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
@@ -4,7 +4,7 @@ public class ScheduledTask {
     Runnable runnable;
     boolean onMain;
     TickTaskHolder.Timing timing;
-    
+
     public ScheduledTask(Runnable runnable, boolean onMain, TickTaskHolder.Timing timing) {
         this.runnable = runnable;
         this.onMain = onMain;
diff --git a/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
index 0bc048f7096429440685bcd6309f34c0ea7a609c..d71f51ef19531c6bb0f9d9e5a5b439afe0ec96e3 100644
--- a/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
+++ b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
@@ -1,13 +1,13 @@
 package me.dueris.canvas.thread;
 
 public interface TickTaskHolder {
-    public void scheduleTickTask(Runnable runnable, Timing timing, State state);
+    void scheduleTickTask(Runnable runnable, Timing timing, State state);
 
-    public static enum Timing {
-        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY;
+    enum Timing {
+        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY
     }
 
-    public static enum State {
-        SERVER_LEVEL, MAIN;
+    enum State {
+        SERVER_LEVEL, MAIN
     }
 }
diff --git a/src/main/java/me/dueris/canvas/thread/WorldTickThread.java b/src/main/java/me/dueris/canvas/thread/WorldTickThread.java
index 0dbd245466f965a80c1736a49d574c6827f2fdea..0afbf6b3efef51be0923089aaec658042bae4dc1 100644
--- a/src/main/java/me/dueris/canvas/thread/WorldTickThread.java
+++ b/src/main/java/me/dueris/canvas/thread/WorldTickThread.java
@@ -2,7 +2,7 @@ package me.dueris.canvas.thread;
 
 import io.papermc.paper.util.TickThread;
 
-public abstract class WorldTickThread extends TickThread implements TickTaskHolder{
+public abstract class WorldTickThread extends TickThread implements TickTaskHolder {
 
     public WorldTickThread(final String name) {
         super(name);
diff --git a/src/main/java/me/dueris/canvas/thread/region/ChunkMapPanel.java b/src/main/java/me/dueris/canvas/thread/region/ChunkMapVM.java
similarity index 74%
rename from src/main/java/me/dueris/canvas/thread/region/ChunkMapPanel.java
rename to src/main/java/me/dueris/canvas/thread/region/ChunkMapVM.java
index 54cad74f598b4e34b04b4856d6b65a4dd831f812..246c22795f0312caa8ae6eb366991b512790b373 100644
--- a/src/main/java/me/dueris/canvas/thread/region/ChunkMapPanel.java
+++ b/src/main/java/me/dueris/canvas/thread/region/ChunkMapVM.java
@@ -1,31 +1,56 @@
 package me.dueris.canvas.thread.region;
 
-import io.papermc.paper.chunk.system.ChunkSystem;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ChunkHolder;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.Level;
-import org.jetbrains.annotations.NotNull;
-import javax.swing.*;
 import java.awt.*;
-import java.awt.event.ActionEvent;
-import java.awt.event.ActionListener;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Random;
+import javax.swing.*;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.jetbrains.annotations.NotNull;
 
-public class ChunkMapPanel extends JPanel {
-    private RegionSystem levelSystem;
-    private Map<ChunkPos, Color> colorMap;
+public class ChunkMapVM extends JPanel {
     static ServerLevel level = MinecraftServer.getServer().overworld();
+    static boolean updating = false;
+    static volatile boolean running = true;
+    private final RegionSystem levelSystem;
+    private final Map<ChunkPos, Color> colorMap;
 
-    public ChunkMapPanel(RegionSystem system) {
+    public ChunkMapVM(RegionSystem system) {
         this.levelSystem = system;
         this.colorMap = new HashMap<>();
     }
 
+    public static void main(String[] args) {
+        JFrame frame = new JFrame("Chunk Map");
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.setSize(1000, 1000);
+
+        ChunkMapVM mapPanel = new ChunkMapVM(level.regionSystem);
+        mapPanel.assignRandomColorsToGroups();
+        mapPanel.updateChunkMap();
+
+        JButton updateButton = getjButton(mapPanel);
+
+        frame.add(mapPanel, BorderLayout.CENTER);
+        frame.add(updateButton, BorderLayout.SOUTH);
+        frame.setVisible(true);
+        while (running) {
+            if (updating) mapPanel.updateChunkMap();
+        }
+    }
+
+    private static @NotNull JButton getjButton(ChunkMapVM mapPanel) {
+        JButton updateButton = new JButton("Update Map");
+        updateButton.addActionListener(e -> {
+            updating = !updating;
+        });
+        return updateButton;
+    }
+
     public void updateChunkMap() {
         assignRandomColorsToGroups();
         repaint();
@@ -33,11 +58,9 @@ public class ChunkMapPanel extends JPanel {
 
     private void assignRandomColorsToGroups() {
         colorMap.clear();
-        ObjectArrayList<BubbleRegion> groups = levelSystem.getBubbleRegions();
-        Random rand = new Random();
-
-        for (final BubbleRegion group : groups) {
-            Color randomColor = new Color(rand.nextInt(256), rand.nextInt(256), rand.nextInt(256));
+        Collection<RegionHandle> groups = levelSystem.getBubbleRegions();
+        for (final RegionHandle group : groups) {
+            Color randomColor = group.randomColor();
             for (int j = 0; j < group.chunks().length; j++) {
                 for (int k = 0; k < group.chunks()[j].length; k++) {
                     if (group.chunks()[j][k] != null) {
@@ -61,13 +84,11 @@ public class ChunkMapPanel extends JPanel {
 
         for (int x = 0; x < levelSystem.chunkMap.length; x++) {
             for (int y = 0; y < levelSystem.chunkMap[x].length; y++) {
-                Color cellColor = null;
+                Color cellColor;
                 if (levelSystem.chunkMap[x][y] != null) {
                     // ChunkPos is real
                     cellColor = colorMap.get(levelSystem.chunkMap[x][y]);
                     if (cellColor == null) {
-                        // Debug output to identify missing color mappings
-                        System.err.println("Warning: No color mapping for value: " + levelSystem.chunkMap[x][y]);
                         cellColor = Color.BLACK; // Default to black if no mapping is found
                     }
                 } else {
@@ -82,35 +103,4 @@ public class ChunkMapPanel extends JPanel {
             }
         }
     }
-
-
-    static boolean updating = false;
-    static volatile boolean running = true;
-
-    public static void main(String[] args) {
-        JFrame frame = new JFrame("Chunk Map");
-        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-        frame.setSize(1000, 1000);
-
-        ChunkMapPanel mapPanel = new ChunkMapPanel(level.regionSystem);
-        mapPanel.assignRandomColorsToGroups();
-        mapPanel.updateChunkMap();
-
-        JButton updateButton = getjButton(mapPanel);
-
-        frame.add(mapPanel, BorderLayout.CENTER);
-        frame.add(updateButton, BorderLayout.SOUTH);
-        frame.setVisible(true);
-        while (running) {
-            if (updating) mapPanel.updateChunkMap();
-        }
-    }
-
-    private static @NotNull JButton getjButton(ChunkMapPanel mapPanel) {
-        JButton updateButton = new JButton("Update Map");
-        updateButton.addActionListener(e -> {
-            updating = !updating;
-        });
-        return updateButton;
-    }
 }
diff --git a/src/main/java/me/dueris/canvas/thread/region/BubbleRegion.java b/src/main/java/me/dueris/canvas/thread/region/RegionHandle.java
similarity index 55%
rename from src/main/java/me/dueris/canvas/thread/region/BubbleRegion.java
rename to src/main/java/me/dueris/canvas/thread/region/RegionHandle.java
index d62df668c09741beeeda0330f3102c405011aab4..4f56217940bded4214e964b32cff56d29d9f819d 100644
--- a/src/main/java/me/dueris/canvas/thread/region/BubbleRegion.java
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionHandle.java
@@ -1,8 +1,18 @@
 package me.dueris.canvas.thread.region;
 
 import net.minecraft.world.level.ChunkPos;
-
-public record BubbleRegion(ChunkPos[][] chunks, long id) {
+import java.awt.*;
+import java.util.Objects;
+import java.util.Random;
+
+public record RegionHandle(ChunkPos[][] chunks, long id, Color randomColor) {
+    public RegionHandle(ChunkPos[][] chunks, long id, Color randomColor) {
+        this.chunks = chunks;
+        this.id = id;
+        System.out.println("a");
+        Random rand = new Random();
+        this.randomColor = new Color(rand.nextInt(256), rand.nextInt(256), rand.nextInt(256));
+    }
 
     public int size() {
         return chunks.length * chunks[0].length;
@@ -32,4 +42,12 @@ public record BubbleRegion(ChunkPos[][] chunks, long id) {
 
         return new ChunkPos(centerX, centerZ);
     }
+
+    @Override
+    public String toString() {
+        return "RegionHandle[" +
+            "chunks=" + chunks + ", " +
+            "id=" + id + ']';
+    }
+
 }
diff --git a/src/main/java/me/dueris/canvas/thread/region/RegionSystem.java b/src/main/java/me/dueris/canvas/thread/region/RegionSystem.java
index b26097c10510451b46180a2d756dcc801855b74b..633ac29ee890fb96a7ff431b5f3087ad82ca63c7 100644
--- a/src/main/java/me/dueris/canvas/thread/region/RegionSystem.java
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionSystem.java
@@ -1,25 +1,31 @@
 package me.dueris.canvas.thread.region;
 
 import io.papermc.paper.chunk.system.ChunkSystem;
-import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import java.util.Stack;
+import java.util.concurrent.ConcurrentHashMap;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
 
 public class RegionSystem {
-    public static final long MAX_CHUNKS = 11;
-    public static final long OVERHEAD = 10;
-    private ObjectArrayList<BubbleRegion> bubbleRegions = new ObjectArrayList<>();
-    public ChunkPos[][] chunkMap = null;
+    public static final long MAX_CHUNKS = 35000;
+    public static final long OVERHEAD = 200;
+    private static final int[] dx = {-1, 1, 0, 0};
+    private static final int[] dz = {0, 0, -1, 1};
     private final ServerLevel level;
+    protected final ConcurrentHashMap<RegionHandle, List<ChunkPos>> regionCache = new ConcurrentHashMap<>();
+    protected ChunkPos[][] chunkMap = null;
 
     public RegionSystem(ServerLevel level) {
         this.level = level;
@@ -35,26 +41,47 @@ public class RegionSystem {
         return new ChunkPos(chunkX, chunkZ);
     }
 
-    public boolean chunkOwnedByRegion(ChunkPos pos, BubbleRegion region) {
-        return region.chunks()[pos.x()][pos.z()] != null;
+    public static <T> List<T> arrayToList(T[][] array) {
+        List<T> list = new ArrayList<>();
+        for (T[] row : array) {
+            Collections.addAll(list, row);
+        }
+        return list;
     }
 
     public void tick() {
         List<ChunkPos> loadedChunks = ChunkSystem.getUpdatingChunkHolders(level).stream().map(ChunkHolder::getPos).toList();
-        chunkMap = generateChunkMap(loadedChunks);
-        BubbleRegion[] regions = splitIntoRegions(chunkMap);
-        bubbleRegions = new ObjectArrayList<>(regions);
-        for (ChunkPos pos : loadedChunks) {
-            throwIfNoRegion(pos, this);
+        int minX = loadedChunks.stream().mapToInt(ChunkPos::x).min().orElse(0);
+        int maxX = loadedChunks.stream().mapToInt(ChunkPos::x).max().orElse(0);
+        int minZ = loadedChunks.stream().mapToInt(ChunkPos::z).min().orElse(0);
+        int maxZ = loadedChunks.stream().mapToInt(ChunkPos::z).max().orElse(0);
+
+        int offsetX = -minX;
+        int offsetZ = -minZ;
+
+        ChunkPos[][] array = new ChunkPos[maxX - minX + 1][maxZ - minZ + 1];
+
+        for (ChunkPos point : loadedChunks) {
+            int x = point.x() + offsetX;
+            int z = point.z() + offsetZ;
+
+            array[x][z] = point;
         }
+        chunkMap = array;
     }
 
+    // startup creates new groups and each tick will check for any missing chunks that arent loaded and then find if
+    // it can merge the new chunks with the other regions. if it can it will merge them, if not it will take half of
+    // its neighbor region and the new chunks to and create a new thread. when 90% of the region is removed and it has
+    // neighbors to merge into, it will delete that thread and merge its chunks with the closest neighbors. any new
+    // chunk groups without any neighboring regions will create its own new thread
     public void update() {
-        if (this.level.dimension.equals(MinecraftServer.getServer().overworld().dimension)) {
-            new Thread(() -> {
-                new ChunkMapPanel(this);
-                ChunkMapPanel.main(new String[0]);
-            }, "RenderThread").start();
+        if (this.level.dimension().equals(MinecraftServer.getServer().overworld().dimension())) {
+            Thread.ofVirtual().name("RenderThread").start(() -> {
+                System.out.println("sjdlkf");
+                new ChunkMapVM(this);
+                ChunkMapVM.main(new String[0]);
+            });
         }
     }
 
@@ -62,34 +89,28 @@ public class RegionSystem {
         return level;
     }
 
-    public ObjectArrayList<BubbleRegion> getBubbleRegions() {
-        return bubbleRegions;
+    public Collection<RegionHandle> getBubbleRegions() {
+        return regionCache.keySet();
     }
 
-    public ChunkPos[][] generateChunkMap(List<ChunkPos> points) {
-        int minX = points.stream().mapToInt(ChunkPos::x).min().orElse(0);
-        int maxX = points.stream().mapToInt(ChunkPos::x).max().orElse(0);
-        int minZ = points.stream().mapToInt(ChunkPos::z).min().orElse(0);
-        int maxZ = points.stream().mapToInt(ChunkPos::z).max().orElse(0);
-
-        int offsetX = -minX;
-        int offsetZ = -minZ;
-
-        ChunkPos[][] array = new ChunkPos[maxX - minX + 1][maxZ - minZ + 1];
-
-        for (ChunkPos point : points) {
-            int x = point.x() + offsetX;
-            int z = point.z() + offsetZ;
+    public void clearRegionCache() {
+        regionCache.clear();
+    }
 
-            array[x][z] = point;
+    public void processRegions() {
+        if (chunkMap == null) {
+            return;
         }
 
-        return array;
+        RegionHandle[] regions = splitIntoRegions(chunkMap);
+        for (RegionHandle region : regions) {
+            regionCache.put(region, arrayToList(region.chunks()));
+        }
     }
 
-    public BubbleRegion[] splitIntoRegions(ChunkPos[][] chunkMap) {
+    public RegionHandle[] splitIntoRegions(ChunkPos[][] chunkMap) {
         int curId = 0;
-        List<BubbleRegion> regions = new ArrayList<>();
+        List<RegionHandle> regions = new ArrayList<>();
         boolean[][] visited = new boolean[chunkMap.length][chunkMap[0].length];
 
         for (int i = 0; i < chunkMap.length; i++) {
@@ -97,15 +118,58 @@ public class RegionSystem {
                 if (!visited[i][j] && chunkMap[i][j] != null) {
                     List<ChunkPos> regionChunks = new ArrayList<>();
                     dfs(chunkMap, visited, i, j, regionChunks);
-                    List<List<ChunkPos>> translated = splitIntoGroups(regionChunks, MAX_CHUNKS + OVERHEAD);
+                    List<List<ChunkPos>> translated = new ArrayList<>();
+                    Set<ChunkPos> allChunks = new HashSet<>(regionChunks);
+                    Set<ChunkPos> visitedPositions = new HashSet<>();
+
+                    for (ChunkPos start : regionChunks) {
+                        if (!visitedPositions.contains(start)) {
+                            List<ChunkPos> group = new ArrayList<>();
+                            Queue<ChunkPos> queue = new LinkedList<>();
+                            queue.add(start);
+                            visitedPositions.add(start);
+
+                            while (!queue.isEmpty() && group.size() < MAX_CHUNKS + OVERHEAD) {
+                                ChunkPos current = queue.poll();
+                                group.add(current);
+
+                                for (ChunkPos neighbor : getNeighbors(current)) {
+                                    if (allChunks.contains(neighbor) && !visitedPositions.contains(neighbor)) {
+                                        queue.add(neighbor);
+                                        visitedPositions.add(neighbor);
+                                    }
+                                }
+                            }
+
+                            translated.add(group);
+                        }
+                    }
+
+                    // If there are any remaining unvisited chunks, group them as well
+                    List<ChunkPos> remainingChunks = new ArrayList<>();
+                    for (ChunkPos chunk : regionChunks) {
+                        if (!visitedPositions.contains(chunk)) {
+                            remainingChunks.add(chunk);
+                            visitedPositions.add(chunk);
+
+                            if (remainingChunks.size() == MAX_CHUNKS + OVERHEAD) {
+                                translated.add(new ArrayList<>(remainingChunks));
+                                remainingChunks.clear();
+                            }
+                        }
+                    }
+                    if (!remainingChunks.isEmpty()) {
+                        translated.add(remainingChunks);
+                    }
+
                     for (final List<ChunkPos> chunkPos : translated) {
-                        regions.add(new BubbleRegion(formatChunkPos(chunkPos), curId++));
+                        regions.add(new RegionHandle(formatChunkPos(chunkPos), curId++, null));
                     }
                 }
             }
         }
 
-        return regions.toArray(new BubbleRegion[0]);
+        return regions.toArray(new RegionHandle[0]);
     }
 
     private void dfs(ChunkPos[][] chunkMap, boolean[][] visited, int x, int z, List<ChunkPos> group) {
@@ -135,57 +199,6 @@ public class RegionSystem {
         }
     }
 
-    private static final int[] dx = {-1, 1, 0, 0};
-    private static final int[] dz = {0, 0, -1, 1};
-
-    public List<List<ChunkPos>> splitIntoGroups(List<ChunkPos> points, long maxChunksPerGroup) {
-        List<List<ChunkPos>> groups = new ArrayList<>();
-        Set<ChunkPos> allChunks = new HashSet<>(points);
-        Set<ChunkPos> visited = new HashSet<>();
-
-        for (ChunkPos start : points) {
-            if (!visited.contains(start)) {
-                List<ChunkPos> group = new ArrayList<>();
-                Queue<ChunkPos> queue = new LinkedList<>();
-                queue.add(start);
-                visited.add(start);
-
-                while (!queue.isEmpty() && group.size() < maxChunksPerGroup) {
-                    ChunkPos current = queue.poll();
-                    group.add(current);
-
-                    for (ChunkPos neighbor : getNeighbors(current)) {
-                        if (allChunks.contains(neighbor) && !visited.contains(neighbor)) {
-                            queue.add(neighbor);
-                            visited.add(neighbor);
-                        }
-                    }
-                }
-
-                groups.add(group);
-            }
-        }
-
-        // If there are any remaining unvisited chunks, group them as well
-        List<ChunkPos> remainingChunks = new ArrayList<>();
-        for (ChunkPos chunk : points) {
-            if (!visited.contains(chunk)) {
-                remainingChunks.add(chunk);
-                visited.add(chunk);
-
-                if (remainingChunks.size() == maxChunksPerGroup) {
-                    groups.add(new ArrayList<>(remainingChunks));
-                    remainingChunks.clear();
-                }
-            }
-        }
-        if (!remainingChunks.isEmpty()) {
-            groups.add(remainingChunks);
-        }
-
-        return groups;
-    }
-
     private List<ChunkPos> getNeighbors(ChunkPos chunk) {
         List<ChunkPos> neighbors = new ArrayList<>();
         for (int i = 0; i < 4; i++) {
@@ -203,14 +216,4 @@ public class RegionSystem {
         return array;
     }
 
-    public static void throwIfNoRegion(ChunkPos pos, RegionSystem system) {
-        boolean a = false;
-        for (final BubbleRegion bubbleRegion : system.bubbleRegions) {
-            if (system.chunkOwnedByRegion(pos, bubbleRegion)) {
-                a = true;
-            }
-        }
-        if (!a) throw new IllegalStateException("ITS NOT OWNED WHY IS THE DATA LOST AHHHHHHHHHHHH");
-    }
-
 }
diff --git a/src/main/java/me/dueris/canvas/thread/region/RegionThread.java b/src/main/java/me/dueris/canvas/thread/region/RegionThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..47edd8e1728b40997369e077c4d5f4f06c614150
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionThread.java
@@ -0,0 +1,14 @@
+package me.dueris.canvas.thread.region;
+
+import me.dueris.canvas.thread.TickTaskHolder;
+
+public interface RegionThread extends TickTaskHolder {
+
+    void startTicking();
+
+    void tickRegion();
+
+    void stopTicking();
+
+    void scheduleTickTask(Runnable runnable, TickTaskHolder.Timing timing, TickTaskHolder.State state);
+}
diff --git a/src/main/java/me/dueris/canvas/thread/region/RegionTickThread.java b/src/main/java/me/dueris/canvas/thread/region/RegionTickThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..2aa6f9e1af811d5f397821e90d10d1e481af0f8e
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionTickThread.java
@@ -0,0 +1,50 @@
+package me.dueris.canvas.thread.region;
+
+import io.papermc.paper.util.TickThread;
+import net.minecraft.server.TickTask;
+import net.minecraft.server.level.ServerLevel;
+import org.jetbrains.annotations.NotNull;
+
+public class RegionTickThread extends TickThread {
+
+    public RegionTickThread(final String name) {
+        super(name);
+    }
+
+    public RegionTickThread(final Runnable run, final String name) {
+        super(run, name);
+    }
+
+    protected static class EventLoop extends net.minecraft.util.thread.ReentrantBlockableEventLoop<net.minecraft.server.TickTask> {
+        private final ServerLevel level;
+
+        public EventLoop(ThreadedRegion region) {
+            super("ServerLevel_" + region.level().dimension().location());
+            this.level = region.level();
+        }
+
+        @Override
+        protected TickTask wrapRunnable(Runnable runnable) {
+            if (level.getServer().hasStopped && Thread.currentThread().equals(level.getServer().shutdownThread)) {
+                runnable.run();
+                runnable = () -> {};
+            }
+            return new TickTask(level.tickCount, runnable);
+        }
+
+        @Override
+        protected boolean shouldRun(TickTask ticktask) {
+            return ticktask.getTick() + 3 < level.tickCount || level.getServer().haveTime();
+        }
+
+        @Override
+        protected @NotNull Thread getRunningThread() {
+            return Thread.currentThread();
+        }
+
+        public boolean getRunningTask() {
+            return this.runningTask();
+        }
+
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java b/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java
new file mode 100644
index 0000000000000000000000000000000000000000..78c37f4a1e4b345d972c846259ed561be39287b6
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java
@@ -0,0 +1,262 @@
+package me.dueris.canvas.thread.region;
+
+import com.mojang.logging.LogUtils;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CountDownLatch;
+import me.dueris.canvas.thread.ScheduledTask;
+import me.dueris.canvas.thread.TickTaskHolder;
+import me.dueris.canvas.world.TickManagerHolder;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.command.defaults.ReloadCommand;
+import org.slf4j.Logger;
+
+public class ThreadedRegion extends RegionTickThread implements RegionThread, TickManagerHolder {
+    public static final Logger LOGGER = LogUtils.getLogger();
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal("1E9").multiply(new java.math.BigDecimal(MinecraftServer.SAMPLE_INTERVAL));
+    public final CountDownLatch latch = new CountDownLatch(1);
+    public final Double[] recentTps = new Double[4];
+    public final MinecraftServer.RollingAverage tps5s = new MinecraftServer.RollingAverage(5);
+    public final MinecraftServer.RollingAverage tps1 = new MinecraftServer.RollingAverage(60);
+    public final MinecraftServer.RollingAverage tps5 = new MinecraftServer.RollingAverage(60 * 5);
+    public final MinecraftServer.RollingAverage tps15 = new MinecraftServer.RollingAverage(60 * 15);
+    private final ConcurrentLinkedQueue<ScheduledTask> scheduledTasks;
+    private final RegionHandle handle;
+    private List<ChunkPos> chunkHolders = new ArrayList<>();
+    private final ServerLevel level;
+    private final int id1;
+    private final MinecraftServer server;
+    public volatile boolean running = false;
+    public int tickCount = 0;
+    public int currentTick;
+    public long currentTickLong;
+    public boolean lagging = false;
+    public Long lastNanoTickTime = 0L;
+    public long currentTime;
+    private long nextTickTimeNanos;
+    private long lastOverloadWarningNanos;
+    private long taskExecutionStartNanos;
+    private long idleTimeNanos;
+    private long delayedTasksMaxNextTickTimeNanos;
+    private boolean mayHaveDelayedTasks;
+    private final ServerTickRateManager tickRateManager;
+    private RegionTickThread.EventLoop eventLoop;
+    private net.minecraft.util.debugchart.SampleLogger tickTimeLogger;
+    private net.minecraft.util.debugchart.DebugSampleSubscriptionTracker debugSampleSubscriptionTracker;
+
+    public ThreadedRegion(RegionHandle handle, ServerLevel level, int id) {
+        super("ThreadedRegion");
+        this.handle = handle;
+        this.level = level;
+        id1 = id;
+        this.scheduledTasks = new ConcurrentLinkedQueue<>();
+        this.server = level.getServer();
+        this.tickRateManager = new ServerTickRateManager(this);
+    }
+
+    @Override
+    public PlayerList getPlayerList() {
+        return this.server.getPlayerList();
+    }
+
+    @Override
+    public CommandSourceStack createCommandSourceStack() {
+        return this.server.createCommandSourceStack();
+    }
+
+    @Override
+    public void onTickRateChanged() {
+        server.onTickRateChanged();
+    }
+
+    @Override
+    public ServerTickRateManager getManager() {
+        return tickRateManager;
+    }
+
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public String getHolderName() {
+        return getName() + " " + id1;
+    }
+
+    private void startMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            this.taskExecutionStartNanos = Util.getNanos();
+            this.idleTimeNanos = 0L;
+        }
+
+    }
+
+    private void finishMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            net.minecraft.util.debugchart.SampleLogger samplelogger = this.tickTimeLogger;
+
+            samplelogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            samplelogger.logPartialSample(this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.IDLE.ordinal());
+        }
+
+    }
+
+    @Override
+    public void stopTicking() {
+        this.running = false;
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void startTicking() {
+        long tickSection = Util.getNanos();
+        this.running = true;
+        this.eventLoop = new RegionTickThread.EventLoop(this);
+        this.debugSampleSubscriptionTracker = new net.minecraft.util.debugchart.DebugSampleSubscriptionTracker(this.getPlayerList());
+        this.tickTimeLogger = new net.minecraft.util.debugchart.RemoteSampleLogger(net.minecraft.util.debugchart.TpsDebugDimensions.values().length, this.debugSampleSubscriptionTracker, net.minecraft.util.debugchart.RemoteDebugSampleType.TICK_TIME);
+        while (this.running) {
+            try {
+                long tickDuration;
+                currentTime = Util.getNanos();
+                if (ReloadCommand.isReloading) continue;
+                if (!server.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+                    tickDuration = 0L;
+                    this.nextTickTimeNanos = Util.getNanos();
+                    this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                } else {
+                    tickDuration = this.tickRateManager.nanosecondsPerTick();
+                    long elapsedTime = Util.getNanos() - this.nextTickTimeNanos;
+
+                    if (elapsedTime > 20 + 20L * tickDuration && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * tickDuration) {
+                        long ticksBehind = elapsedTime / tickDuration;
+
+                        if (server.server.getWarnOnOverload() && tickCount > 300)
+                            LOGGER.warn("Can't keep up! Is the region overloaded? Running {}ms or {} ticks behind. ServerLevelIdentifier: {identifier}"
+                                .replace("{identifier}", this.level.getWorld().getKey().asString() + "_region_" + id1), elapsedTime / TimeUtil.NANOSECONDS_PER_MILLISECOND, ticksBehind);
+                        this.nextTickTimeNanos += ticksBehind * tickDuration;
+                        this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                    }
+                }
+                this.chunkHolders = this.level.regionSystem.regionCache.get(this.handle);
+                ++this.currentTickLong;
+                currentTime = Util.getNanos();
+                if (++this.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+                    final long diff = currentTime - tickSection;
+                    final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff);
+                    tps1.add(currentTps, diff);
+                    tps5.add(currentTps, diff);
+                    tps15.add(currentTps, diff);
+
+                    this.recentTps[0] = tps5s.getAverage();
+                    this.recentTps[1] = tps1.getAverage();
+                    this.recentTps[2] = tps5.getAverage();
+                    this.recentTps[3] = tps15.getAverage();
+                    lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+                    tickSection = currentTime;
+                }
+                this.nextTickTimeNanos += tickDuration;
+
+                long i = Util.getNanos();
+                this.tickRegion();
+                this.lastNanoTickTime = Util.getNanos() - i;
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + tickDuration, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+                    this.nextTickTimeNanos = currentTime + nextTickTimeNanos;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+        latch.countDown();
+    }
+
+    public void waitUntilNextTick() {
+        eventLoop.managedBlock(() -> !(server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < this.nextTickTimeNanos));
+    }
+
+    @Override
+    public void tickRegion() {
+        System.out.println(this.id1);
+    }
+
+    public boolean haveTime() {
+        if (server.forceTicks) {
+            return true;
+        }
+        if (server.isOversleep)
+            return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
+        return server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+    }
+
+    @Override
+    public void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(TickTaskHolder.State.MAIN), timing));
+    }
+
+    public void runAllScheduledTasks() {
+        List<ScheduledTask> tasksToRun = new java.util.ArrayList<>(this.scheduledTasks);
+        this.scheduledTasks.clear();
+
+        for (ScheduledTask task : tasksToRun) {
+            task.run();
+        }
+    }
+
+    public void runAllWithTiming(Timing timing) {
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (task.canRun(timing) && task.serverLevel()) {
+                iterator.remove();
+                task.run();
+            }
+        }
+    }
+
+    public void runMainThreadTasks() {
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (!task.serverLevel()) {
+                iterator.remove();
+                task.run();
+            }
+        }
+    }
+
+    public RegionHandle getHandle() {
+        return handle;
+    }
+
+    public ServerLevel level() {
+        return level;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 68b1b61f3032197b45f7224ebd00774ab4bb6ca7..bdc5456d8758a496b770dfdc9599ef1df99283b0 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -15,6 +15,7 @@ import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -1272,7 +1273,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             try {
                 for (ServerLevel level : this.getAllLevels()) {
                     this.currentWorldThreads.add(level);
-                    level.start();
+                    Thread virtual = Thread.ofVirtual().unstarted(level);
+                    virtual.setUncaughtExceptionHandler((thread1, throwable) -> {
+                        ServerLevel.LOGGER.error("Uncaught exception in WorldTicker thread", throwable);
+                    });
+                    virtual.setPriority(Thread.NORM_PRIORITY + 2);
+                    if (Runtime.getRuntime().availableProcessors() > 4) {
+                        virtual.setPriority(8);
+                    }
+                    virtual.setName(level.getName());
+                    virtual.start();
                 }
             } catch (Throwable throwable) {
                 throw new IllegalStateException("Failed to start WorldTickers");
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 1d0b73df34c271ccb2db83156ad07bc5c81ce4af..abf6287a5fce30bb3aa5248df9a41f02a875e349 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -267,10 +267,6 @@ public abstract class Level extends WorldTickThread implements LevelAccessor, Au
             }
         }
     }
-
-    public ScheduledTask[] getMainThreadTasks() {
-        return (ScheduledTask[]) this.scheduledTasks.stream().filter(s -> !s.serverLevel()).toArray().clone();
-    }
     // Canvas end
 
     // Paper start - Use getChunkIfLoadedImmediately
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 2e074c16dab1ead47914070329da0398c3274048..f9f1315663b661da51b6f52737b7b14c98bf4e07 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -9,7 +9,7 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if (!(io.papermc.paper.util.TickThread.isTickThread())) // Paper
+        if (!(io.papermc.paper.util.TickThread.isTickThread()) && !Thread.currentThread().isVirtual() && false) // Paper // Canvas
         {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
