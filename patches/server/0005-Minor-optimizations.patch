From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: satvrn <pastawho@gmail.com>
Date: Wed, 27 Sep 2023 01:50:11 -0700
Subject: [PATCH] Minor optimizations

This patch contains minor optimizations from patches from the following sources:
- Mirai -- contains patches from others aswell
- Graphene
- Canvas

diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
index 5408cbc21fc7577a6100b5a1ca0463e899d2df8b..033d30d0947048deb748366288f77cd77f706f97 100644
--- a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
@@ -16,7 +16,7 @@ import java.util.UUID;
 
 public class PaperLootableInventoryData {
 
-    private static final Random RANDOM = new Random();
+    private static final Random RANDOM = new me.satvrn.random.FastRandom(); // Graphene
 
     private long lastFill = -1;
     private long nextRefill = -1;
diff --git a/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java b/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1229bae2e74d22065c723c6d3eaf9a97d572b04
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/opts/allocs/common/ObjectCachingUtils.java
@@ -0,0 +1,23 @@
+package com.ishland.c2me.opts.allocs.common;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+
+import java.util.BitSet;
+import java.util.function.IntFunction;
+
+public class ObjectCachingUtils {
+
+    private static final IntFunction<BitSet> bitSetConstructor = BitSet::new;
+
+    public static ThreadLocal<Int2ObjectOpenHashMap<BitSet>> BITSETS = ThreadLocal.withInitial(Int2ObjectOpenHashMap::new);
+
+    private ObjectCachingUtils() {
+    }
+
+    public static BitSet getCachedOrNewBitSet(int bits) {
+        final BitSet bitSet = BITSETS.get().computeIfAbsent(bits, bitSetConstructor);
+        bitSet.clear();
+        return bitSet;
+    }
+
+}
diff --git a/src/main/java/com/ishland/c2me/opts/allocs/common/PooledFeatureContext.java b/src/main/java/com/ishland/c2me/opts/allocs/common/PooledFeatureContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c84006c90bda4849b27879d5218f98e6d98f1dc
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/opts/allocs/common/PooledFeatureContext.java
@@ -0,0 +1,68 @@
+package com.ishland.c2me.opts.allocs.common;
+
+import java.util.Optional;
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.feature.FeaturePlaceContext;
+import net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration;
+
+public class PooledFeatureContext<FC extends FeatureConfiguration> extends FeaturePlaceContext<FC> {
+
+    public static final ThreadLocal<SimpleObjectPool<PooledFeatureContext<?>>> POOL = ThreadLocal.withInitial(() -> new SimpleObjectPool<>(unused -> new PooledFeatureContext<>(), unused -> {}, 2048));
+
+    private Optional<ConfiguredFeature<?, ?>> feature;
+    private WorldGenLevel world;
+    private ChunkGenerator generator;
+    private RandomSource random;
+    private BlockPos origin;
+    private FC config;
+
+    public PooledFeatureContext() {
+        super(null, null, null, null, null, null);
+    }
+
+    public void reInit(Optional<ConfiguredFeature<?, ?>> feature, WorldGenLevel world, ChunkGenerator generator, RandomSource random, BlockPos origin, FC config) {
+        this.feature = feature;
+        this.world = world;
+        this.generator = generator;
+        this.random = random;
+        this.origin = origin;
+        this.config = config;
+    }
+
+    public void reInit() {
+        this.feature = null;
+        this.world = null;
+        this.generator = null;
+        this.random = null;
+        this.origin = null;
+        this.config = null;
+    }
+
+    public WorldGenLevel level() {
+        return this.world;
+    }
+
+    public ChunkGenerator chunkGenerator() {
+        return this.generator;
+    }
+
+    public RandomSource random() {
+        return this.random;
+    }
+
+    public BlockPos origin() {
+        return this.origin;
+    }
+
+    public FC config() {
+        return this.config;
+    }
+
+    public Optional<ConfiguredFeature<?, ?>> topFeature() {
+        return this.feature;
+    }
+}
diff --git a/src/main/java/com/ishland/c2me/opts/allocs/common/SimpleObjectPool.java b/src/main/java/com/ishland/c2me/opts/allocs/common/SimpleObjectPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..b989019847f73ba3af57f7428699c9c869d6332f
--- /dev/null
+++ b/src/main/java/com/ishland/c2me/opts/allocs/common/SimpleObjectPool.java
@@ -0,0 +1,57 @@
+package com.ishland.c2me.opts.allocs.common;
+
+import com.google.common.base.Preconditions;
+
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public class SimpleObjectPool<T> {
+
+    private final Function<SimpleObjectPool<T>, T> constructor;
+    private final Consumer<T> initializer;
+    private final int size;
+
+    private final Object[] cachedObjects;
+    private int allocatedCount = 0;
+
+    public SimpleObjectPool(Function<SimpleObjectPool<T>, T> constructor, Consumer<T> initializer, int size) {
+        this.constructor = Objects.requireNonNull(constructor);
+        this.initializer = Objects.requireNonNull(initializer);
+        Preconditions.checkArgument(size > 0);
+        this.cachedObjects = new Object[size];
+        this.size = size;
+
+        for (int i = 0; i < size; i++) {
+            final T object = constructor.apply(this);
+            this.cachedObjects[i] = object;
+        }
+    }
+
+    public T alloc() {
+        final T object;
+        synchronized (this) {
+            if (this.allocatedCount >= this.size) { // oversized, falling back to normal alloc
+                object = this.constructor.apply(this);
+                return object;
+            }
+
+            // get an object from the array
+            final int ordinal = this.allocatedCount++;
+            object = (T) this.cachedObjects[ordinal];
+            this.cachedObjects[ordinal] = null;
+        }
+
+        this.initializer.accept(object); // initialize the object
+
+        return object;
+    }
+
+    public void release(T object) {
+        synchronized (this) {
+            if (this.allocatedCount == 0) return; // pool is full
+            this.cachedObjects[--this.allocatedCount] = object; // store the object into the pool
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/util/table/ZeroCollidingReferenceStateTable.java b/src/main/java/io/papermc/paper/util/table/ZeroCollidingReferenceStateTable.java
index 57d0cd3ad6f972e986c72a57f1a6e36003f190c2..293d19ffd74c8162bfcc08d759a8a7fa56a75a74 100644
--- a/src/main/java/io/papermc/paper/util/table/ZeroCollidingReferenceStateTable.java
+++ b/src/main/java/io/papermc/paper/util/table/ZeroCollidingReferenceStateTable.java
@@ -15,6 +15,7 @@ public final class ZeroCollidingReferenceStateTable {
     protected final long[] this_index_table;
     protected final Comparable<?>[] this_table;
     protected final StateHolder<?, ?> this_state;
+    public long[] index_table() { return this.index_table; } // Canvas - getter
 
     protected long[] index_table;
     protected StateHolder<?, ?>[][] value_table;
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5d3aa309d3fdaab9e0fea2dfb91a080a3ac1193
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/IterateOutwardsCache.java
@@ -0,0 +1,71 @@
+package me.jellysquid.mods.lithium.common.cached_blockpos_iteration;
+
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
+import net.minecraft.core.BlockPos;
+
+/**
+ * @author 2No2Name, original implemenation by SuperCoder7979 and Gegy1000
+ */
+public class IterateOutwardsCache {
+    //POS_ZERO must not be replaced with BlockPos.ORIGIN, otherwise iterateOutwards at BlockPos.ORIGIN will not use the cache
+    public static final BlockPos POS_ZERO = new BlockPos(0,0,0);
+
+
+    private final ConcurrentHashMap<Long, LongArrayList> table;
+    private final int capacity;
+    private final Random random;
+
+    public IterateOutwardsCache(int capacity) {
+        this.capacity = capacity;
+        this.table = new ConcurrentHashMap<>(31);
+        this.random = new Random();
+    }
+
+    private void fillPositionsWithIterateOutwards(LongList entry, int xRange, int yRange, int zRange) {
+        // Add all positions to the cached list
+        for (BlockPos pos : BlockPos.withinManhattan(POS_ZERO, xRange, yRange, zRange)) {
+            entry.add(pos.asLong());
+        }
+    }
+
+    public LongList getOrCompute(int xRange, int yRange, int zRange) {
+        long key = BlockPos.asLong(xRange, yRange, zRange);
+
+        LongArrayList entry = this.table.get(key);
+        if (entry != null) {
+            return entry;
+        }
+
+        // Cache miss: compute and store
+        entry = new LongArrayList(128);
+
+        this.fillPositionsWithIterateOutwards(entry, xRange, yRange, zRange);
+
+        //decrease the array size, as of now it won't be modified anymore anyways
+        entry.trim();
+
+        //this might overwrite an entry as the same entry could have been computed and added during this thread's computation
+        //we do not use computeIfAbsent, as it can delay other threads for too long
+        Object previousEntry = this.table.put(key, entry);
+
+
+        if (previousEntry == null && this.table.size() > this.capacity) {
+            //prevent a memory leak by randomly removing about 1/8th of the elements when the exceed the desired capacity is exceeded
+            final Iterator<Long> iterator = this.table.keySet().iterator();
+            //prevent an unlikely infinite loop caused by another thread filling the table concurrently using counting
+            for (int i = -this.capacity; iterator.hasNext() && i < 5; i++) {
+                Long key2 = iterator.next();
+                //random is not threadsafe, but it doesn't matter here, because we don't need quality random numbers
+                if (this.random.nextInt(8) == 0 && key2 != key) {
+                    iterator.remove();
+                }
+            }
+        }
+
+        return entry;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java
new file mode 100644
index 0000000000000000000000000000000000000000..493661ff3ac7247b68b7b02784b09b0eaf88fc52
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/cached_blockpos_iteration/LongList2BlockPosMutableIterable.java
@@ -0,0 +1,46 @@
+package me.jellysquid.mods.lithium.common.cached_blockpos_iteration;
+
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongList;
+import java.util.Iterator;
+import net.minecraft.core.BlockPos;
+
+/**
+ * @author 2No2Name
+ */
+public class LongList2BlockPosMutableIterable implements Iterable<BlockPos> {
+
+    private final LongList positions;
+    private final int xOffset, yOffset, zOffset;
+
+    public LongList2BlockPosMutableIterable(BlockPos offset, LongList posList) {
+        this.xOffset = offset.getX();
+        this.yOffset = offset.getY();
+        this.zOffset = offset.getZ();
+        this.positions = posList;
+    }
+
+    @Override
+    public Iterator<BlockPos> iterator() {
+        return new Iterator<BlockPos>() {
+
+            private final LongIterator it = LongList2BlockPosMutableIterable.this.positions.iterator();
+            private final BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();
+
+            @Override
+            public boolean hasNext() {
+                return it.hasNext();
+            }
+
+            @Override
+            public net.minecraft.core.BlockPos next() {
+                long nextPos = this.it.nextLong();
+                return this.pos.set(
+                        LongList2BlockPosMutableIterable.this.xOffset + BlockPos.getX(nextPos),
+                        LongList2BlockPosMutableIterable.this.yOffset + BlockPos.getY(nextPos),
+                        LongList2BlockPosMutableIterable.this.zOffset + BlockPos.getZ(nextPos));
+            }
+        };
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8c9cb28876c2c1781cd72870076d528b9647916
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/math/CompactSineLUT.java
@@ -0,0 +1,90 @@
+package me.jellysquid.mods.lithium.common.util.math;
+
+import net.minecraft.util.Mth;
+
+/**
+ * A replacement for the sine angle lookup table used in {@link Mth}, both reducing the size of LUT and improving
+ * the access patterns for common paired sin/cos operations.
+ *
+ *  sin(-x) = -sin(x)
+ *    ... to eliminate negative angles from the LUT.
+ *
+ *  sin(x) = sin(pi/2 - x)
+ *    ... to eliminate supplementary angles from the LUT.
+ *
+ * Using these identities allows us to reduce the LUT from 64K entries (256 KB) to just 16K entries (64 KB), enabling
+ * it to better fit into the CPU's caches at the expense of some cycles on the fast path. The implementation has been
+ * tightly optimized to avoid branching where possible and to use very quick integer operations.
+ *
+ * Generally speaking, reducing the size of a lookup table is always a good optimization, but since we need to spend
+ * extra CPU cycles trying to maintain parity with vanilla, there is the potential risk that this implementation ends
+ * up being slower than vanilla when the lookup table is able to be kept in cache memory.
+ *
+ * Unlike other "fast math" implementations, the values returned by this class are *bit-for-bit identical* with those
+ * from {@link Mth}. Validation is performed during runtime to ensure that the table is correct.
+ *
+ * @author coderbot16   Author of the original (and very clever) implementation in Rust:
+ *  https://gitlab.com/coderbot16/i73/-/tree/master/i73-trig/src
+ * @author jellysquid3  Additional optimizations, port to Java
+ */
+public class CompactSineLUT {
+    private static final int[] SINE_TABLE_INT = new int[16384 + 1];
+    private static final float SINE_TABLE_MIDPOINT;
+
+    static {
+        final float[] SINE_TABLE = Mth.getSinTable();
+        // Copy the sine table, covering to raw int bits
+        for (int i = 0; i < SINE_TABLE_INT.length; i++) {
+            SINE_TABLE_INT[i] = Float.floatToRawIntBits(SINE_TABLE[i]);
+        }
+
+        SINE_TABLE_MIDPOINT = SINE_TABLE[SINE_TABLE.length / 2];
+
+        // Test that the lookup table is correct during runtime
+        for (int i = 0; i < SINE_TABLE.length; i++) {
+            float expected = SINE_TABLE[i];
+            float value = lookup(i);
+
+            if (expected != value) {
+                throw new IllegalArgumentException(String.format("LUT error at index %d (expected: %s, found: %s)", i, expected, value));
+            }
+        }
+    }
+
+    // [VanillaCopy] MathHelper#sin(float)
+    public static float sin(float f) {
+        return lookup((int) (f * 10430.378f) & 0xFFFF);
+    }
+
+    // [VanillaCopy] MathHelper#cos(float)
+    public static float cos(float f) {
+        return lookup((int) (f * 10430.378f + 16384.0f) & 0xFFFF);
+    }
+
+    private static float lookup(int index) {
+        // A special case... Is there some way to eliminate this?
+        if (index == 32768) {
+            return SINE_TABLE_MIDPOINT;
+        }
+
+        // Trigonometric identity: sin(-x) = -sin(x)
+        // Given a domain of 0 <= x <= 2*pi, just negate the value if x > pi.
+        // This allows the sin table size to be halved.
+        int neg = (index & 0x8000) << 16;
+
+        // All bits set if (pi/2 <= x), none set otherwise
+        // Extracts the 15th bit from 'half'
+        int mask = (index << 17) >> 31;
+
+        // Trigonometric identity: sin(x) = sin(pi/2 - x)
+        int pos = (0x8001 & mask) + (index ^ mask);
+
+        // Wrap the position in the table. Moving this down to immediately before the array access
+        // seems to help the Hotspot compiler optimize the bit math better.
+        pos &= 0x7fff;
+
+        // Fetch the corresponding value from the LUT and invert the sign bit as needed
+        // This directly manipulate the sign bit on the float bits to simplify logic
+        return Float.intBitsToFloat(SINE_TABLE_INT[pos] ^ neg);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/titaniumtown/ServerWorkerWrapper.java b/src/main/java/me/titaniumtown/ServerWorkerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bd88761137b2a68c04fbaa920a9ea9ce1f9e873
--- /dev/null
+++ b/src/main/java/me/titaniumtown/ServerWorkerWrapper.java
@@ -0,0 +1,24 @@
+package me.titaniumtown;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.Util;
+
+public final class ServerWorkerWrapper implements Runnable {
+    private final Runnable internalRunnable;
+
+    public ServerWorkerWrapper(Runnable runnable) {
+        this.internalRunnable = Preconditions.checkNotNull(runnable, "internalRunnable");
+    }
+
+    @Override
+    public final void run() {
+        try {
+            this.internalRunnable.run();
+            return;
+        }
+        catch (Throwable throwable) {
+            Util.onThreadException(Thread.currentThread(), throwable);
+            return;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index 5c1503f5b173138fc9e918d5562a981ca8b66d06..f554dd78962d907eb2f29c29a2dcb955080e2ea5 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -75,6 +75,12 @@ import net.minecraft.util.TimeSource;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.world.level.block.state.properties.Property;
 import org.slf4j.Logger;
+// JettPack start
+import java.util.concurrent.AbstractExecutorService;
+import me.titaniumtown.ServerWorkerWrapper;
+import io.papermc.paper.util.MCUtil;
+import java.util.Collections;
+// JettPack end
 
 public class Util {
     static final Logger LOGGER = LogUtils.getLogger();
@@ -167,7 +173,46 @@ public class Util {
         if (i <= 0) {
             executorService = MoreExecutors.newDirectExecutorService();
         } else {
-            executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new io.papermc.paper.util.ServerWorkerThread(target, s, priorityModifier));
+            //executorService = new java.util.concurrent.ThreadPoolExecutor(i, i,0L, TimeUnit.MILLISECONDS, new java.util.concurrent.LinkedBlockingQueue<Runnable>(), target -> new net.minecraft.server.ServerWorkerThread(target, s, priorityModifier)); // JettPack
+            // JettPack start
+            executorService = Integer.getInteger("Paper.WorkerThreadCount", i) <= 0 ? MoreExecutors.newDirectExecutorService() : new AbstractExecutorService() {
+                private volatile boolean shutdown = false;
+
+                @Override
+                public final List<Runnable> shutdownNow() {
+                    this.shutdown = true;
+                    return Collections.emptyList();
+                }
+
+                @Override
+                public final void shutdown() {
+                    this.shutdown = true;
+                }
+
+                @Override
+                public final boolean isShutdown() {
+                    return this.shutdown;
+                }
+
+                @Override
+                public final boolean isTerminated() {
+                    return this.shutdown;
+                }
+
+                @Override
+                public final boolean awaitTermination(long l2, TimeUnit timeUnit) throws InterruptedException {
+                    if (!this.shutdown) {
+                        throw new UnsupportedOperationException();
+                    }
+                    return true;
+                }
+
+                @Override
+                public final void execute(Runnable runnable) {
+                    MCUtil.asyncExecutor.execute(new ServerWorkerWrapper(runnable));
+                }
+            };
+            // JettPack end
         }
         /*
                     @Override
diff --git a/src/main/java/net/minecraft/advancements/Advancement.java b/src/main/java/net/minecraft/advancements/Advancement.java
index afa5ac5e3b045f8eeafd14b7db09e547fbd59f3a..5f5e0ce1ced3b5e4b52142dd840e21ec37afbfc5 100644
--- a/src/main/java/net/minecraft/advancements/Advancement.java
+++ b/src/main/java/net/minecraft/advancements/Advancement.java
@@ -22,7 +22,7 @@ import net.minecraft.world.level.ItemLike;
 
 public record Advancement(Optional<ResourceLocation> parent, Optional<DisplayInfo> display, AdvancementRewards rewards, Map<String, Criterion<?>> criteria, AdvancementRequirements requirements, boolean sendsTelemetryEvent, Optional<Component> name) {
     public Advancement(Optional<ResourceLocation> parent, Optional<DisplayInfo> display, AdvancementRewards rewards, Map<String, Criterion<?>> criteria, AdvancementRequirements requirements, boolean sendsTelemetryEvent) {
-        this(parent, display, rewards, Map.copyOf(criteria), requirements, sendsTelemetryEvent, display.map(Advancement::decorateName));
+        this(parent, display, rewards, criteria, requirements, sendsTelemetryEvent, display.map(Advancement::decorateName)); // Mirai - Skip cloning loot parameters
     }
 
     public static Component decorateName(DisplayInfo display) {
diff --git a/src/main/java/net/minecraft/advancements/AdvancementTree.java b/src/main/java/net/minecraft/advancements/AdvancementTree.java
index 8aa7439d9f3c071f88c84c6c75b7a65e5e5cfa82..2841691d4825f6abfd99109914664ae5ef4f9018 100644
--- a/src/main/java/net/minecraft/advancements/AdvancementTree.java
+++ b/src/main/java/net/minecraft/advancements/AdvancementTree.java
@@ -85,7 +85,7 @@ public class AdvancementTree {
         Map map = this.nodes;
 
         Objects.requireNonNull(this.nodes);
-        AdvancementNode advancementnode = (AdvancementNode) optional.map(map::get).orElse((Object) null);
+        AdvancementNode advancementnode = (AdvancementNode) optional.map(map::get).orElse(null); // Canvas - remove redundant cast
 
         if (advancementnode == null && optional.isPresent()) {
             return false;
diff --git a/src/main/java/net/minecraft/core/AxisCycle.java b/src/main/java/net/minecraft/core/AxisCycle.java
index b5d8a60dc78a76c0a55bfc30cc49d26857bd914a..8c72da8e2a4fd2891e6cfce1cf07fe83825b88c0 100644
--- a/src/main/java/net/minecraft/core/AxisCycle.java
+++ b/src/main/java/net/minecraft/core/AxisCycle.java
@@ -35,7 +35,19 @@ public enum AxisCycle {
 
         @Override
         public Direction.Axis cycle(Direction.Axis axis) {
-            return AXIS_VALUES[Math.floorMod(axis.ordinal() + 1, 3)];
+            //return AXIS_VALUES[Math.floorMod(axis.ordinal() + 1, 3)]; // Graphene - lithum: math.fast_util
+            // Graphene start - lithum: math.fast_util
+            switch (axis.ordinal()) {
+                case 0: //X
+                    return Direction.Axis.Y;
+                case 1: //Y
+                    return Direction.Axis.Z;
+                case 2: //Z
+                    return Direction.Axis.X;
+            }
+
+            throw new IllegalArgumentException();
+            // Graphene end
         }
 
         @Override
@@ -56,7 +68,19 @@ public enum AxisCycle {
 
         @Override
         public Direction.Axis cycle(Direction.Axis axis) {
-            return AXIS_VALUES[Math.floorMod(axis.ordinal() - 1, 3)];
+            //return AXIS_VALUES[Math.floorMod(axis.ordinal() - 1, 3)]; // Graphene - lithum: math.fast_util
+            // Graphene start - lithum: math.fast_util
+            switch (axis.ordinal()) {
+                case 0: //X
+                    return Direction.Axis.Z;
+                case 1: //Y
+                    return Direction.Axis.X;
+                case 2: //Z
+                    return Direction.Axis.Y;
+            }
+
+            throw new IllegalArgumentException();
+            // Graphene end
         }
 
         @Override
@@ -65,6 +89,15 @@ public enum AxisCycle {
         }
     };
 
+    // Graphene start - lithum: math.fast_util
+    static {
+        assert Direction.Axis.X.ordinal() == 0;
+        assert Direction.Axis.Y.ordinal() == 1;
+        assert Direction.Axis.Z.ordinal() == 2;
+        assert Direction.Axis.values().length == 3;
+    }
+    // Graphene end
+
     public static final Direction.Axis[] AXIS_VALUES = Direction.Axis.values();
     public static final AxisCycle[] VALUES = values();
 
diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index ec6b58dae525c81bbb1c0e2d96fbded6f00a45b5..772ffb60b1b1411c30588e9949749292aa18fb17 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -25,6 +25,12 @@ import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.Validate;
 import org.apache.commons.lang3.tuple.Pair;
 import org.slf4j.Logger;
+// JettPack start
+import it.unimi.dsi.fastutil.longs.LongList;
+import me.jellysquid.mods.lithium.common.cached_blockpos_iteration.IterateOutwardsCache;
+import me.jellysquid.mods.lithium.common.cached_blockpos_iteration.LongList2BlockPosMutableIterable;
+import static me.jellysquid.mods.lithium.common.cached_blockpos_iteration.IterateOutwardsCache.POS_ZERO;
+// JettPack end
 
 @Immutable
 public class BlockPos extends Vec3i {
@@ -298,7 +304,18 @@ public class BlockPos extends Vec3i {
         };
     }
 
+    // JettPack start - lithium: cached iterate outwards
+    private static final IterateOutwardsCache ITERATE_OUTWARDS_CACHE = new IterateOutwardsCache(50);
+    private static final LongList HOGLIN_PIGLIN_CACHE = ITERATE_OUTWARDS_CACHE.getOrCompute(8, 4, 8);
+    // JettPack end
+
     public static Iterable<BlockPos> withinManhattan(BlockPos center, int rangeX, int rangeY, int rangeZ) {
+        // JettPack start - lithium: cached iterate outwards
+        if (center != POS_ZERO) {
+            final LongList positions = rangeX == 8 && rangeY == 4 && rangeZ == 8 ? HOGLIN_PIGLIN_CACHE : ITERATE_OUTWARDS_CACHE.getOrCompute(rangeX, rangeY, rangeZ);
+            return new LongList2BlockPosMutableIterable(center, positions);
+        }
+        // JettPack end
         int i = rangeX + rangeY + rangeZ;
         // Paper start - rename variables to fix conflict with anonymous class (remap fix)
         int centerX = center.getX();
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index b805e57d5a67d77d226cd8154e970050e2e8ef4a..9d6d1fcc869466ae7b2dfc5ea1744f8663188677 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -39,7 +39,7 @@ public enum Direction implements StringRepresentable {
     private final Direction.Axis axis;
     private final Direction.AxisDirection axisDirection;
     private final Vec3i normal;
-    private static final Direction[] VALUES = values();
+    public static final Direction[] VALUES = values(); // JettPack
     private static final Direction[] BY_3D_DATA = Arrays.stream(VALUES).sorted(Comparator.comparingInt((direction) -> {
         return direction.data3d;
     })).toArray((i) -> {
@@ -197,7 +197,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public Direction getOpposite() {
-        return from3DDataValue(this.oppositeIndex);
+        return BY_3D_DATA[this.oppositeIndex]; // Graphene - lithum: math.fast_util
     }
 
     public Direction getClockWise(Direction.Axis axis) {
@@ -478,7 +478,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction getRandom(RandomSource random) {
-        return Util.getRandom(VALUES, random);
+        return BY_3D_DATA[random.nextInt(BY_3D_DATA.length)]; // Graphene - lithum: math.fast_util
     }
 
     public static Direction getNearest(double x, double y, double z) {
diff --git a/src/main/java/net/minecraft/network/VarLong.java b/src/main/java/net/minecraft/network/VarLong.java
index 3ea9f42b7ad50c0dc4466849e3432ebddcfe2f7b..4c1fbf3e2e6cfaf5f5db199b232d007ec6a9d226 100644
--- a/src/main/java/net/minecraft/network/VarLong.java
+++ b/src/main/java/net/minecraft/network/VarLong.java
@@ -8,7 +8,22 @@ public class VarLong {
     private static final int CONTINUATION_BIT_MASK = 128;
     private static final int DATA_BITS_PER_BYTE = 7;
 
+    // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+    private static final int[] EXACT_BYTE_LENGTHS = new int[65];
+    static {
+        for (int i = 0; i < 64; ++i) {
+            EXACT_BYTE_LENGTHS[i] = (64 - i + 6) / 7;
+        }
+        EXACT_BYTE_LENGTHS[64] = 1; // Special case for the number 0
+    }
+    // Gale end - Velocity - pre-compute VarInt and VarLong sizes
     public static int getByteSize(long l) {
+        // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+        return EXACT_BYTE_LENGTHS[Long.numberOfLeadingZeros(l)];
+    }
+
+    static int getByteSizeOriginal(long l) { // public -> package-private
+        // Gale end - Velocity - pre-compute VarInt and VarLong sizes
         for(int i = 1; i < 10; ++i) {
             if ((l & -1L << i * 7) == 0L) {
                 return i;
diff --git a/src/main/java/net/minecraft/network/Varint21FrameDecoder.java b/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
index 1f71357a4caef4b2cbff95b560d0f3df268b3621..be2d2bdaef04ab1c3342b955791768777a427173 100644
--- a/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
+++ b/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
@@ -1,23 +1,36 @@
 package net.minecraft.network;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
+//import io.netty.buffer.Unpooled; // Graphene - now unused
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
-import io.netty.handler.codec.CorruptedFrameException;
+//import io.netty.handler.codec.CorruptedFrameException; // Graphene - now unused
 import java.util.List;
 import javax.annotation.Nullable;
 
+// Graphene start - krypton: network.pipeline
+import me.steinborn.krypton.network.VarintByteDecoder;
+import static me.steinborn.krypton.network.util.WellKnownExceptions.BAD_LENGTH_CACHED;
+import static me.steinborn.krypton.network.util.WellKnownExceptions.VARINT_BIG_CACHED;
+// Graphene end
+
 public class Varint21FrameDecoder extends ByteToMessageDecoder {
+    // Graphene start - now unused
+    /*
     private static final int MAX_VARINT21_BYTES = 3;
     private final ByteBuf helperBuf = Unpooled.directBuffer(3);
     @Nullable
     private final BandwidthDebugMonitor monitor;
+    */
+    // Graphene end
+    private final VarintByteDecoder reader = new VarintByteDecoder(); // Graphene - krypton: network.pipeline
 
     public Varint21FrameDecoder(@Nullable BandwidthDebugMonitor packetSizeLogger) {
-        this.monitor = packetSizeLogger;
+        //this.monitor = packetSizeLogger; // Graphene - now unused
     }
 
+    // Graphene start - now unused
+    /*
     protected void handlerRemoved0(ChannelHandlerContext channelHandlerContext) {
         this.helperBuf.release();
     }
@@ -37,8 +50,12 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder {
 
         throw new CorruptedFrameException("length wider than 21-bit");
     }
+    */
+    // Graphene end
 
     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) {
+        // Graphene start - krypton: Use optimized Velocity varint decoder that reduces bounds checking
+        /*
         // Paper start - if channel is not active just discard the packet
         if (!channelHandlerContext.channel().isActive()) {
             byteBuf.skipBytes(byteBuf.readableBytes());
@@ -61,5 +78,51 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder {
                 list.add(byteBuf.readBytes(i));
             }
         }
+        */
+        // Graphene end
+
+        // Graphene start - krypton: network.pipeline
+        if (!channelHandlerContext.channel().isActive()) {
+            byteBuf.clear();
+            return;
+        }
+
+        reader.reset();
+
+        int varintEnd = byteBuf.forEachByte(reader);
+        if (varintEnd == -1) {
+            // We tried to go beyond the end of the buffer. This is probably a good sign that the
+            // buffer was too short to hold a proper varint.
+            if (reader.getResult() == VarintByteDecoder.DecodeResult.RUN_OF_ZEROES) {
+                // Special case where the entire packet is just a run of zeroes. We ignore them all.
+                byteBuf.clear();
+            }
+            return;
+        }
+
+        if (reader.getResult() == VarintByteDecoder.DecodeResult.RUN_OF_ZEROES) {
+            // this will return to the point where the next varint starts
+            byteBuf.readerIndex(varintEnd);
+        } else if (reader.getResult() == VarintByteDecoder.DecodeResult.SUCCESS) {
+            int readVarint = reader.getReadVarint();
+            int bytesRead = reader.getBytesRead();
+            if (readVarint < 0) {
+                byteBuf.clear();
+                throw BAD_LENGTH_CACHED;
+            } else if (readVarint == 0) {
+                // skip over the empty packet(s) and ignore it
+                byteBuf.readerIndex(varintEnd + 1);
+            } else {
+                int minimumRead = bytesRead + readVarint;
+                if (byteBuf.isReadable(minimumRead)) {
+                    list.add(byteBuf.retainedSlice(varintEnd + 1, readVarint));
+                    byteBuf.skipBytes(minimumRead);
+                }
+            }
+        } else if (reader.getResult() == VarintByteDecoder.DecodeResult.TOO_BIG) {
+            byteBuf.clear();
+            throw VARINT_BIG_CACHED;
+        }
+        // Graphene end
     }
 }
diff --git a/src/main/java/net/minecraft/resources/ResourceLocation.java b/src/main/java/net/minecraft/resources/ResourceLocation.java
index 38e2a8cec48bc779b8154d6d719031f457a2403e..c3255ff691025b61ea1a4bd835ef0bd405e00282 100644
--- a/src/main/java/net/minecraft/resources/ResourceLocation.java
+++ b/src/main/java/net/minecraft/resources/ResourceLocation.java
@@ -29,6 +29,7 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
     public static final String PAPER_NAMESPACE = "paper"; // Paper
     private final String namespace;
     private final String path;
+    private String cachedString = null; // Mirai - c2me: opts allocs
 
     protected ResourceLocation(String namespace, String path, @Nullable ResourceLocation.Dummy extraData) {
         this.namespace = namespace;
@@ -118,7 +119,16 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
 
     @Override
     public String toString() {
-        return this.namespace + ":" + this.path;
+        // Mirai start - c2me: opts allocs
+        /**
+         * @author ishland
+         * @reason cache toString
+         */
+        if (this.cachedString != null) return this.cachedString;
+        final String s = this.namespace + ":" + this.path;
+        this.cachedString = s;
+        return s;
+        // Mirai end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index ec268189b19b6fa5c4521f96ce211a531db35ec5..751ef8c1738c87e533715f279565b32deee2a575 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -73,6 +73,21 @@ import org.bukkit.configuration.file.YamlConfiguration;
 
 public class Main {
 
+    // Graphene start - krypton: change Netty PooledByteBufAllocator arena size
+    static {
+        // By default, Netty allocates 16MiB arenas for the PooledByteBufAllocator. This is too much
+        // memory for Minecraft, which imposes a maximum packet size of 2MiB! We'll use 4MiB as a more
+        // sane default.
+        //
+        // Note: io.netty.allocator.pageSize << io.netty.allocator.maxOrder is the formula used to
+        // compute the chunk size. We lower maxOrder from its default of 11 to 9. (We also use a null
+        // check, so that the user is free to choose another setting if need be.)
+        if (System.getProperty("io.netty.allocator.maxOrder") == null) {
+            System.setProperty("io.netty.allocator.maxOrder", "9");
+        }
+    }
+    // Graphene end
+
     private static final Logger LOGGER = LogUtils.getLogger();
 
     public Main() {}
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 935dac757280731bfeb0a8f033cbe315ecac46da..ea8b84758cf7cc2b8394467481a175dc3ef9e507 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -45,13 +45,13 @@ public class DedicatedPlayerList extends PlayerList {
     @Override
     public void op(GameProfile profile) {
         super.op(profile);
-        this.saveOps();
+        // this.saveOps(); // MultiPaper - don't double save the op list
     }
 
     @Override
     public void deop(GameProfile profile) {
         super.deop(profile);
-        this.saveOps();
+        // this.saveOps(); // MultiPaper - don't double save the op list
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 3771caa73b0b41428f3d629aca1f562df7bcfaff..e7652688d4a3d1acce2a9a29d93248af115974cd 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -106,6 +106,8 @@ import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 import org.bukkit.entity.Player;
 // CraftBukkit end
 
+import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap; // Mirai - vmp: use linked map for entity trackers for faster iteration
+
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
     private static final byte CHUNK_TYPE_REPLACEABLE = -1;
@@ -252,7 +254,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = new Int2ObjectLinkedOpenHashMap<>(); // Mirai - vmp: use linked map for entity trackers for faster iteration
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1c8724fb56e790922c7e8fc73bc97442b7a6df83..611c2dc84c639aa9fb8279d2103a0eeb1c379b4b 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -1846,6 +1846,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         if (entity instanceof Player) entityhuman = (Player) entity;
         // CraftBukkit end
 
+        ClientboundBlockDestructionPacket packet = null; // SportPaper - Cache block break animation packet
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
 
@@ -1861,7 +1862,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 // CraftBukkit end
 
                 if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
-                    entityplayer.connection.send(new ClientboundBlockDestructionPacket(entityId, pos, progress));
+                    // SportPaper start
+                    if (packet == null) packet = new ClientboundBlockDestructionPacket(entityId, pos, progress);
+                    entityplayer.connection.send(packet);
+                    // SportPaper end
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 9adff73223a7e699fb7ba22c1a0bdb53d94ef132..6678c37ca650b8b1c65adf83582dcd4ba02b1953 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -449,7 +449,7 @@ public class ServerPlayer extends Player {
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.getCoprime(i1);
-            int k1 = RandomSource.create().nextInt(i1);
+            int k1 = worldserver.random.nextInt(i1); // Patina - don't create new random instance
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
@@ -486,7 +486,7 @@ public class ServerPlayer extends Player {
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.getCoprime(i1);
-            int k1 = RandomSource.create().nextInt(i1);
+            int k1 = world.random.nextInt(i1); // Patina - don't create new random instance
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
diff --git a/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java b/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
index 8f4a964a0863b1be834c1ea1e3d49092516f9258..b5f3f199c9bb3c1054170f9046544a6dbc75746f 100644
--- a/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
+++ b/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
@@ -24,6 +24,13 @@ public class LegacyQueryHandler extends ChannelInboundHandlerAdapter {
     public void channelRead(ChannelHandlerContext channelhandlercontext, Object object) {
         ByteBuf bytebuf = (ByteBuf) object;
 
+        // Graphene start - krypton: network.pipeline
+        if (!channelhandlercontext.channel().isActive()) {
+            bytebuf.clear();
+            return;
+        }
+        // Graphene end
+
         // Paper start - Make legacy ping handler more reliable
         if (this.buf != null) {
             try {
diff --git a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
index c6bcf4a5d5c48e6f73b8e5d3662ec0d7c288c6c8..c83a1e3b17c3a0e4d8aa1fc240677ad059e7950d 100644
--- a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
@@ -13,8 +13,10 @@ import net.minecraft.server.MinecraftServer;
 
 // CraftBukkit start
 import java.net.InetAddress;
-import java.util.HashMap;
 // CraftBukkit end
+// Dionysus start
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
+// Dionysus end
 
 public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketListener {
 
@@ -24,7 +26,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
     static final java.util.regex.Pattern PROP_PATTERN = java.util.regex.Pattern.compile("\\w{0,16}");
     // Spigot end
     // CraftBukkit start - add fields
-    private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    private static final Object2LongOpenHashMap<InetAddress> throttleTracker = new Object2LongOpenHashMap<>(); // Dionysus
     private static int throttleCounter = 0;
     // CraftBukkit end
     private static final Component IGNORE_STATUS_REASON = Component.translatable("disconnect.ignoring_status_request");
@@ -51,7 +53,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
                     InetAddress address = ((java.net.InetSocketAddress) this.connection.getRemoteAddress()).getAddress();
 
                     synchronized (ServerHandshakePacketListenerImpl.throttleTracker) {
-                        if (ServerHandshakePacketListenerImpl.throttleTracker.containsKey(address) && !"127.0.0.1".equals(address.getHostAddress()) && currentTime - ServerHandshakePacketListenerImpl.throttleTracker.get(address) < connectionThrottle) {
+                        if (ServerHandshakePacketListenerImpl.throttleTracker.containsKey(address) && !"127.0.0.1".equals(address.getHostAddress()) && currentTime - ServerHandshakePacketListenerImpl.throttleTracker.getLong(address) < connectionThrottle) { // Dionysus
                             ServerHandshakePacketListenerImpl.throttleTracker.put(address, currentTime);
                             Component chatmessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().messages.kick.connectionThrottle); // Paper - Configurable connection throttle kick message
                             this.connection.send(new ClientboundLoginDisconnectPacket(chatmessage));
@@ -65,13 +67,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
                             ServerHandshakePacketListenerImpl.throttleCounter = 0;
 
                             // Cleanup stale entries
-                            java.util.Iterator iter = ServerHandshakePacketListenerImpl.throttleTracker.entrySet().iterator();
-                            while (iter.hasNext()) {
-                                java.util.Map.Entry<InetAddress, Long> entry = (java.util.Map.Entry) iter.next();
-                                if (entry.getValue() > connectionThrottle) {
-                                    iter.remove();
-                                }
-                            }
+                            throttleTracker.object2LongEntrySet().removeIf(entry -> entry.getLongValue() > connectionThrottle); // Dionysus
                         }
                     }
                     } // Paper - add closing bracket for if check above
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 3dcccca8ede9b203c24ba29b2020a583297b895c..8d89f35ce7a17daa7bf6dbc133eef07119270448 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -50,7 +50,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     static final Logger LOGGER = LogUtils.getLogger();
     private static final int MAX_TICKS_BEFORE_LOGIN = 600;
     private static final Component DISCONNECT_UNEXPECTED_QUERY = Component.translatable("multiplayer.disconnect.unexpected_query_response");
-    private static final RandomSource RANDOM = new org.bukkit.craftbukkit.util.RandomSourceWrapper(new java.util.Random()); // Paper - This is called across threads, make safe
+    private static final RandomSource RANDOM = new org.bukkit.craftbukkit.util.RandomSourceWrapper(new me.satvrn.random.FastRandom()); // Paper - This is called across threads, make safe // Graphene
     private final byte[] challenge;
     final MinecraftServer server;
     public final Connection connection;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 182acaad79e14e5e120094916a0d295a4584de7a..c92bedc2400dab693bc4c0752de9b99753e86953 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -735,6 +735,8 @@ public abstract class PlayerList {
         if (getBans().isBanned(gameprofile) && (gameprofilebanentry = getBans().get(gameprofile)) != null) {
             // Paper end
 
+            // Yatopia start - Stop wasting resources on JsonList#get
+            if (!gameprofilebanentry.hasExpired()) {
             ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned.reason", gameprofilebanentry.getReason());
             if (gameprofilebanentry.getExpires() != null) {
                 ichatmutablecomponent.append((Component) Component.translatable("multiplayer.disconnect.banned.expiration", PlayerList.BAN_DATE_FORMAT.format(gameprofilebanentry.getExpires())));
@@ -742,6 +744,10 @@ public abstract class PlayerList {
 
             // return chatmessage;
             event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
+            } else {
+                getBans().remove(gameprofile);
+            }
+            // Yatopia end
         } else if (!this.isWhiteListed(gameprofile, event)) { // Paper
             //ichatmutablecomponent = Component.translatable("multiplayer.disconnect.not_whitelisted"); // Paper
             //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure - moved to isWhitelisted
diff --git a/src/main/java/net/minecraft/server/players/StoredUserList.java b/src/main/java/net/minecraft/server/players/StoredUserList.java
index 09fc086548b9d0f97849f56f41e3a5be87f5091a..6ea58f44a13d4edd5d03698467afd0e7fd2831f5 100644
--- a/src/main/java/net/minecraft/server/players/StoredUserList.java
+++ b/src/main/java/net/minecraft/server/players/StoredUserList.java
@@ -74,9 +74,12 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
         // Paper start
         // this.g();
         // return (V) this.d.get(this.a(k0)); // CraftBukkit - fix decompile error
-        return (V) this.map.computeIfPresent(this.getKeyForUser(key), (k, v) -> {
+        // Yatopia start - Stop wasting resources on JsonList#get
+        return this.map.get(this.getKeyForUser(key));
+        /*return (V) this.map.computeIfPresent(this.getKeyForUser(key), (k, v) -> {
             return v.hasExpired() ? null : v;
-        });
+        });*/
+        // Yatopia end
         // Paper end
     }
 
@@ -145,7 +148,8 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
     public void save() throws IOException {
         this.removeExpired(); // Paper - remove expired values before saving
         JsonArray jsonarray = new JsonArray();
-        Stream<JsonObject> stream = this.map.values().stream().map((jsonlistentry) -> { // CraftBukkit - decompile error
+        // Yatopia start - Stop wasting resources on JsonList#get
+        /*Stream<JsonObject> stream = this.map.values().stream().map((jsonlistentry) -> { // CraftBukkit - decompile error
             JsonObject jsonobject = new JsonObject();
 
             Objects.requireNonNull(jsonlistentry);
@@ -153,7 +157,13 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
         });
 
         Objects.requireNonNull(jsonarray);
-        stream.forEach(jsonarray::add);
+        stream.forEach(jsonarray::add);*/
+        for (V value : this.map.values()) {
+            JsonObject obj = new JsonObject();
+            value.serialize(obj);
+            jsonarray.add(obj);
+        }
+        // Yatopia end
         BufferedWriter bufferedwriter = Files.newWriter(this.file, StandardCharsets.UTF_8);
 
         try {
diff --git a/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java b/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
index 1ef089dbf83de35d875c00efdf468c397be56978..c345f10cbf7f3451edc604f97cdf959d70639e17 100644
--- a/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
+++ b/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
@@ -349,7 +349,7 @@ public class QueryThreadGs4 extends GenericThread {
             this.identBytes[2] = bs[5];
             this.identBytes[3] = bs[6];
             this.ident = new String(this.identBytes, StandardCharsets.UTF_8);
-            this.challenge = RandomSource.create().nextInt(16777216);
+            this.challenge = java.util.concurrent.ThreadLocalRandom.current().nextInt(16777216); // Patina - don't create new random instance
             this.challengeBytes = String.format(Locale.ROOT, "\t%s%d\u0000", this.ident, this.challenge).getBytes(StandardCharsets.UTF_8);
         }
 
diff --git a/src/main/java/net/minecraft/util/Mth.java b/src/main/java/net/minecraft/util/Mth.java
index 33ace08d15bbcad66c09c7bd65dd03e784246e8f..0de9e45766eabb542b2203bb14f4a11bc69b2c87 100644
--- a/src/main/java/net/minecraft/util/Mth.java
+++ b/src/main/java/net/minecraft/util/Mth.java
@@ -30,6 +30,7 @@ public class Mth {
 
     });
     private static final RandomSource RANDOM = RandomSource.createThreadSafe();
+    public static float[] getSinTable() { return SIN; } // Mirai - lithium: CompactSineLUT
     private static final int[] MULTIPLY_DE_BRUIJN_BIT_POSITION = new int[]{0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
     private static final double ONE_SIXTH = 0.16666666666666666D;
     private static final int FRAC_EXP = 8;
@@ -39,11 +40,11 @@ public class Mth {
     private static final double[] COS_TAB = new double[257];
 
     public static float sin(float value) {
-        return SIN[(int)(value * 10430.378F) & '\uffff'];
+        return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.sin(value); // Mirai - lithium: CompactSineLUT
     }
 
     public static float cos(float value) {
-        return SIN[(int)(value * 10430.378F + 16384.0F) & '\uffff'];
+        return me.jellysquid.mods.lithium.common.util.math.CompactSineLUT.cos(value); // Mirai - lithium: CompactSineLUT
     }
 
     public static float sqrt(float value) {
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 83701fbfaa56a232593ee8f11a3afb8941238bfa..02304c154e79550d8b39d3065c27139a49aabfea 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -1,13 +1,13 @@
 package net.minecraft.util.thread;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Queues;
+//import com.google.common.collect.Queues; - JettPack
 import com.mojang.logging.LogUtils;
 import java.util.List;
-import java.util.Queue;
+//import java.util.Queue; - JettPack
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.concurrent.locks.LockSupport;
+// import java.util.concurrent.locks.LockSupport; - JettPack
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import net.minecraft.util.profiling.metrics.MetricCategory;
@@ -15,12 +15,15 @@ import net.minecraft.util.profiling.metrics.MetricSampler;
 import net.minecraft.util.profiling.metrics.MetricsRegistry;
 import net.minecraft.util.profiling.metrics.ProfilerMeasured;
 import org.slf4j.Logger;
+import java.util.concurrent.LinkedBlockingDeque; // JettPack
+import java.util.concurrent.TimeUnit; // JettPack
 
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
+    private final LinkedBlockingDeque<R> pendingRunnables = new LinkedBlockingDeque(); // JettPack
     private int blockingCount;
+    private R next = null; // JettPack
 
     protected BlockableEventLoop(String name) {
         this.name = name;
@@ -89,7 +92,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     @Override
     public void tell(R runnable) {
         this.pendingRunnables.add(runnable);
-        LockSupport.unpark(this.getRunningThread());
+        // LockSupport.unpark(this.getRunningThread()); - JettPack
     }
 
     @Override
@@ -117,15 +120,19 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
-        R runnable = this.pendingRunnables.peek();
-        if (runnable == null) {
-            return false;
-        } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
+        // JettPack start
+        if (this.next == null && !this.pendingRunnables.isEmpty()) {
+            this.waitForTasks();
+        }
+        if (this.next == null) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            R r2 = this.next;
+            this.next = null;
+            this.doRunTask(r2);
             return true;
         }
+        // JettPack end
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
@@ -144,8 +151,17 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     protected void waitForTasks() {
-        Thread.yield();
-        LockSupport.parkNanos("waiting for tasks", 100000L);
+        // JettPack start
+        if (this.next != null) {
+            throw new IllegalStateException("next != null");
+        }
+        try {
+            this.next = this.pendingRunnables.poll(100L, TimeUnit.MICROSECONDS);
+            return;
+        } catch (InterruptedException interruptedException) {
+            return;
+        }
+        // JettPack end
     }
 
     protected void doRunTask(R task) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c53f071d183fb7e13f7d7c4e5c82589b33bd7147..3db18fe569a6ed3896331705e2547489140d7fcc 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -314,6 +314,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public float yRotO;
     public float xRotO;
     private AABB bb;
+    private boolean boundingBoxChanged = false; // Mirai - vmp: skip entity move if movement is zero
     public boolean onGround;
     public boolean horizontalCollision;
     public boolean verticalCollision;
@@ -497,17 +498,34 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public boolean canSaveToDisk() {
         return true;
     }
+    
+    // JettPack start - cache eye blockpos
+    private BlockPos cached_eye_blockpos;
+    private int cached_position_hashcode;
+    // JettPack end
 
     // Purpur start - copied from Mob
     public boolean isSunBurnTick() {
         if (this.level().isDay() && !this.level().isClientSide) {
-            float f = this.getLightLevelDependentMagicValue();
-            BlockPos blockposition = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+            // JettPack start - optimizations and cache eye blockpos
+            int positionHashCode = this.getPositionHashCode();
+            if (this.cached_position_hashcode != positionHashCode) {
+                this.cached_eye_blockpos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+                this.cached_position_hashcode = positionHashCode;
+            }
+
+            float f = this.getLightLevelDependentMagicValue(cached_eye_blockpos); // Pass BlockPos to getBrightness
+
+            // Check brightness first
+            if (f <= 0.5F) return false;
+            if (this.random.nextFloat() * 30.0F >= (f - 0.4F) * 2.0F) return false;
+
             boolean flag = this.isInWaterRainOrBubble() || this.isInPowderSnow || this.wasInPowderSnow;
 
-            if (f > 0.5F && this.random.nextFloat() * 30.0F < (f - 0.4F) * 2.0F && !flag && this.level().canSeeSky(blockposition)) {
+            if (!flag && this.level().canSeeSky(this.cached_eye_blockpos)) { // JettPack - move brightness checks up
                 return true;
             }
+            // JettPack end
         }
 
         return false;
@@ -900,7 +918,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
         this.checkBelowWorld();
         if (!this.level().isClientSide) {
-            this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            // Slice start
+            if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0 && !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE));
+            } else {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            }
+            // Slice end
         }
 
         this.firstTick = false;
@@ -1101,6 +1125,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     // Paper end - detailed watchdog information
 
     public void move(MoverType movementType, Vec3 movement) {
+        // Mirai start - vmp: skip entity move if movement is zero
+        if (!boundingBoxChanged && movement.equals(Vec3.ZERO)) {
+            boundingBoxChanged = false;
+            return;
+        }
+        // Mirai end
         // Paper start - detailed watchdog information
         io.papermc.paper.util.TickThread.ensureTickThread("Cannot move an entity off-main");
         synchronized (this.posLock) {
@@ -2039,12 +2069,18 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         }
     }
 
+    // JettPack start - allow passing BlockPos to getLightLevelDependentMagicValue
     /** @deprecated */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
-        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
+        return this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ()));
     }
 
+    public float getLightLevelDependentMagicValue(BlockPos pos) {
++        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(pos) : 0.0F;
++    }
++    // JettPack end
+
     public void absMoveTo(double x, double y, double z, float yaw, float pitch) {
         this.absMoveTo(x, y, z);
         this.setYRot(yaw % 360.0F);
@@ -2139,8 +2175,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public void playerTouch(Player player) {}
 
     public void push(Entity entity) {
+        if (entity.noPhysics || this.noPhysics) return; // Akarin - Test this earlier
         if (!this.isPassengerOfSameVehicle(entity)) {
-            if (!entity.noPhysics && !this.noPhysics) {
+            if (true || !entity.noPhysics && !this.noPhysics) { // Akarin - Moved up
                 if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper
                 double d0 = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
@@ -4081,6 +4118,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public final void setBoundingBox(AABB boundingBox) {
+        if (!this.bb.equals(boundingBox)) boundingBoxChanged = true; // Mirai - vmp: skip entity move if movement is zero
         // CraftBukkit start - block invalid bounding boxes
         double minX = boundingBox.minX,
                 minY = boundingBox.minY,
@@ -4695,6 +4733,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
     // Paper end - block invalid positions
 
+    // JettPack start
+    public final int getPositionHashCode() {
+        return this.position.hashCode();
+    }
+    // JettPack end
+
     public final void setPosRaw(double x, double y, double z) {
         // Paper start
         this.setPosRaw(x, y, z, false);
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index c0d9c8d42410335509bb228f394e2e65cda86c87..010b3fc8fd2c8fb73cc8d075993b31845337f244 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -2604,6 +2604,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     protected void updateSwingTime() {
+        if (!this.swinging && this.swingTime == 0) return; // Mirai
+
         int i = this.getCurrentSwingDuration();
 
         if (this.swinging) {
@@ -3630,6 +3632,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     private void updateFallFlying() {
+        if (!this.isFallFlying()) return; // Mirai
+
         boolean flag = this.getSharedFlag(7);
 
         if (flag && !this.onGround() && !this.isPassenger() && !this.hasEffect(MobEffects.LEVITATION)) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 02978315bc2b828cc603ce7478408f3f82c249c2..17c9e3e1e2fed440cf8f498023704e05902d5ed1 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -13,6 +13,7 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 import net.minecraft.util.profiling.ProfilerFiller;
 import org.slf4j.Logger;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet; // Lithium
 
 public class GoalSelector {
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -28,7 +29,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    private final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    public final Set<WrappedGoal> availableGoals = new ObjectLinkedOpenHashSet<>(); // Lithium - replace AI goal set with optimized collection
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
diff --git a/src/main/java/net/minecraft/world/entity/animal/Sheep.java b/src/main/java/net/minecraft/world/entity/animal/Sheep.java
index 8502fc1331c2e94992ab39e4e7ea0f36e83b06a5..d756d9f9c5cb9d985859dc014d38a5d7e3117064 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Sheep.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Sheep.java
@@ -433,21 +433,56 @@ public class Sheep extends Animal implements Shearable {
         return super.finalizeSpawn(world, difficulty, spawnReason, entityData, entityNbt);
     }
 
+    // Mirai start
+    private static DyeColor properDye(DyeColor firstColor, DyeColor secondColor) {
+        if (firstColor.equals(secondColor)) return firstColor;
+        switch(firstColor) {
+            case WHITE -> {
+                switch(secondColor) {
+                    case BLUE -> {return DyeColor.LIGHT_BLUE;}
+                    case GRAY -> {return DyeColor.LIGHT_GRAY;}
+                    case BLACK -> {return DyeColor.GRAY;}
+                    case GREEN -> {return DyeColor.LIME;}
+                    case RED -> {return DyeColor.PINK;}
+                }
+            }
+            case BLUE -> {
+                switch(secondColor) {
+                    case WHITE -> {return DyeColor.LIGHT_BLUE;}
+                    case GREEN -> {return DyeColor.CYAN;}
+                    case RED -> {return DyeColor.PURPLE;}
+                }
+            }
+            case RED -> {
+                switch(secondColor) {
+                    case YELLOW -> {return DyeColor.ORANGE;}
+                    case WHITE -> {return DyeColor.PINK;}
+                    case BLUE -> {return DyeColor.PURPLE;}
+                }
+            }
+            case GREEN -> {
+                switch(secondColor) {
+                    case BLUE -> {return DyeColor.CYAN;}
+                    case WHITE -> {return DyeColor.LIME;}
+                }
+            }
+            case YELLOW -> {if (secondColor.equals(DyeColor.RED)) return DyeColor.ORANGE;}
+            case PURPLE -> {if (secondColor.equals(DyeColor.PINK)) return DyeColor.MAGENTA;}
+            case PINK -> {if (secondColor.equals(DyeColor.PURPLE)) return DyeColor.MAGENTA;}
+            case GRAY -> {if (secondColor.equals(DyeColor.WHITE)) return DyeColor.LIGHT_GRAY;}
+            case BLACK -> {if (secondColor.equals(DyeColor.WHITE)) return DyeColor.GRAY;}
+        }
+        return null;
+    }
+
     private DyeColor getOffspringColor(Animal firstParent, Animal secondParent) {
-        DyeColor enumcolor = ((Sheep) firstParent).getColor();
-        DyeColor enumcolor1 = ((Sheep) secondParent).getColor();
-        CraftingContainer inventorycrafting = Sheep.makeContainer(enumcolor, enumcolor1);
-        Optional<Item> optional = this.level().getRecipeManager().getRecipeFor(RecipeType.CRAFTING, inventorycrafting, this.level()).map((recipeholder) -> { // CraftBukkit - decompile error
-            return ((CraftingRecipe) recipeholder.value()).assemble(inventorycrafting, this.level().registryAccess());
-        }).map(ItemStack::getItem);
-
-        Objects.requireNonNull(DyeItem.class);
-        optional = optional.filter(DyeItem.class::isInstance);
-        Objects.requireNonNull(DyeItem.class);
-        return (DyeColor) optional.map(DyeItem.class::cast).map(DyeItem::getDyeColor).orElseGet(() -> {
-            return this.level().random.nextBoolean() ? enumcolor : enumcolor1;
-        });
+        DyeColor firstColor = ((Sheep)firstParent).getColor();
+        DyeColor secondColor = ((Sheep)secondParent).getColor();
+        DyeColor col = properDye(firstColor,secondColor);
+        if (col == null) col = this.level().random.nextBoolean() ? firstColor : secondColor;
+        return col;
     }
+    // Mirai end
 
     private static CraftingContainer makeContainer(DyeColor firstColor, DyeColor secondColor) {
         TransientCraftingContainer transientcraftingcontainer = new TransientCraftingContainer(new AbstractContainerMenu((MenuType) null, -1) {
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 724329ded5d72eb230db392972d30e7ba4e69ceb..52bf1536d727b2a6cf11a4cf0208fb5a4885f3b4 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -312,19 +312,21 @@ public abstract class Player extends LivingEntity {
         this.moveCloak();
         if (!this.level().isClientSide) {
             this.foodData.tick(this);
-            this.awardStat(Stats.PLAY_TIME);
-            this.awardStat(Stats.TOTAL_WORLD_TIME);
-            if (this.isAlive()) {
-                this.awardStat(Stats.TIME_SINCE_DEATH);
-            }
-
-            if (this.isDiscrete()) {
-                this.awardStat(Stats.CROUCH_TIME);
-            }
-
-            if (!this.isSleeping()) {
-                this.awardStat(Stats.TIME_SINCE_REST);
+            // Mirai start
+            if (tickCount % 20 == 0) {
+                this.awardStat(Stats.PLAY_TIME, 20);
+                this.awardStat(Stats.TOTAL_WORLD_TIME, 20);
+                if (this.isAlive()) {
+                    this.awardStat(Stats.TIME_SINCE_DEATH, 20);
+                }
+                if (this.isDiscrete()) {
+                    this.awardStat(Stats.CROUCH_TIME, 20);
+                }
+                if (!this.isSleeping()) {
+                    this.awardStat(Stats.TIME_SINCE_REST, 20);
+                }
             }
+            // Mirai end
         }
 
         int i = 29999999;
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raid.java b/src/main/java/net/minecraft/world/entity/raid/Raid.java
index eaa2943b667967f93f28d9d794d702fdaeb670ec..410ba320637ff94c1f318226a588d8ecb92dc45a 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raid.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raid.java
@@ -271,7 +271,16 @@ public class Raid {
         this.status = Raid.RaidStatus.STOPPED;
     }
 
+    private boolean isBarDirty; // JettPack
     public void tick() {
+        // JettPack start - lithium: ai.raid
+        if (this.isBarDirty) {
+            this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+
+            this.isBarDirty = false;
+        }
+        // JettPack end
+
         if (!this.isStopped()) {
             if (this.status == Raid.RaidStatus.ONGOING) {
                 boolean flag = this.active;
@@ -642,7 +651,7 @@ public class Raid {
     }
 
     public void updateBossbar() {
-        this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
+        this.isBarDirty = true; // JettPack - lithium: ai.raid
     }
 
     public float getHealthOfLivingRaiders() {
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raider.java b/src/main/java/net/minecraft/world/entity/raid/Raider.java
index 300411e88cdaef7e0ce280edbd5f18fa8d004a33..f1575776a84dacb167d644f9f2e5c7c340aaf01d 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raider.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raider.java
@@ -46,8 +46,9 @@ import net.minecraft.world.phys.Vec3;
 public abstract class Raider extends PatrollingMonster {
 
     protected static final EntityDataAccessor<Boolean> IS_CELEBRATING = SynchedEntityData.defineId(Raider.class, EntityDataSerializers.BOOLEAN);
+    public static final ItemStack CACHED_OMINOUS_BANNER = Raid.getLeaderBannerInstance(); // JettPack - lithium: ai.raid
     static final Predicate<ItemEntity> ALLOWED_ITEMS = (entityitem) -> {
-        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), Raid.getLeaderBannerInstance());
+        return !entityitem.hasPickUpDelay() && entityitem.isAlive() && ItemStack.matches(entityitem.getItem(), CACHED_OMINOUS_BANNER); // JettPack - lithium: ai.raid
     };
     @Nullable
     protected Raid raid;
@@ -149,7 +150,7 @@ public abstract class Raider extends PatrollingMonster {
                     }
                 }
 
-                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, Raid.getLeaderBannerInstance()) && entityhuman != null) {
+                if (!itemstack.isEmpty() && ItemStack.matches(itemstack, CACHED_OMINOUS_BANNER) && entityhuman != null) { // JettPack - lithium: ai.raid
                     MobEffectInstance mobeffect = entityhuman.getEffect(MobEffects.BAD_OMEN);
                     byte b0 = 1;
                     int i;
@@ -311,6 +312,7 @@ public abstract class Raider extends PatrollingMonster {
     public class ObtainRaidLeaderBannerGoal<T extends Raider> extends Goal {
 
         private final T mob;
+        private static final ItemStack CACHED_OMINOUS_BANNER = Raid.getLeaderBannerInstance(); // JettPack
 
         public ObtainRaidLeaderBannerGoal(T entityraider) { // CraftBukkit - decompile error
             this.mob = entityraider;
@@ -322,7 +324,7 @@ public abstract class Raider extends PatrollingMonster {
             if ((!this.mob.level().purpurConfig.pillagerBypassMobGriefing && !this.mob.level().getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) || !this.mob.canPickUpLoot()) return false; // Paper - respect game and entity rules for picking up items // Purpur
             Raid raid = this.mob.getCurrentRaid();
 
-            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), Raid.getLeaderBannerInstance())) {
+            if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), CACHED_OMINOUS_BANNER)) { // JettPack - lithium: ai.raid
                 Raider entityraider = raid.getLeader(this.mob.getWave());
 
                 if (entityraider == null || !entityraider.isAlive()) {
diff --git a/src/main/java/net/minecraft/world/level/GameRules.java b/src/main/java/net/minecraft/world/level/GameRules.java
index 6639902efb85b4f49f26ba5f90556fb871ef8a0e..64e540548f556e27be2fbaedcbbf7fe561ded7bd 100644
--- a/src/main/java/net/minecraft/world/level/GameRules.java
+++ b/src/main/java/net/minecraft/world/level/GameRules.java
@@ -27,6 +27,7 @@ import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
 import org.slf4j.Logger;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap; // JettPack
 
 public class GameRules {
 
@@ -130,14 +131,16 @@ public class GameRules {
 
     public GameRules() {
         // Paper start - use this to ensure gameruleArray is initialized
-        this((Map) GameRules.GAME_RULE_TYPES.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (entry) -> {
+        // JettPack start - lithium: store gamerules in fastutil hashmap
+        this(new Object2ObjectOpenHashMap<>((Map) GameRules.GAME_RULE_TYPES.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (entry) -> {
             return ((GameRules.Type) entry.getValue()).createRule();
-        })));
+        }))));
+        // JettPack end
         // Paper end
     }
 
     private GameRules(Map<GameRules.Key<?>, GameRules.Value<?>> rules) {
-        this.rules = rules;
+        this.rules = new Object2ObjectOpenHashMap<>(rules); // JettPack - lithium: store gamerules in fastutil hashmap
 
         // Paper start
         int arraySize = rules.keySet().stream().mapToInt(key -> key.gameRuleIndex).max().orElse(-1) + 1;
diff --git a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
index 84c766e09898cfc07d6e07e80f4b9aa318050a62..9cb1acdfe2a514099e9517118c7cd448bd3c2d68 100644
--- a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
+++ b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
@@ -47,16 +47,25 @@ public class LocalMobCapCalculator {
     }
 
     static class MobCounts {
-        private final Object2IntMap<MobCategory> counts = new Object2IntOpenHashMap<>(MobCategory.values().length);
+        // private final Object2IntMap<MobCategory> counts = new Object2IntOpenHashMap<>(MobCategory.values().length); // Mirai
+        private final int[] spawnGroupDensities = new int[MobCategory.values().length]; // Mirai
 
+        // Mirai start
+        /**
+         * @author ishland
+         * @reason opt: replace with array access
+         */
         public void add(MobCategory spawnGroup) {
-            this.counts.computeInt(spawnGroup, (group, density) -> {
-                return density == null ? 1 : density + 1;
-            });
+            this.spawnGroupDensities[spawnGroup.ordinal()] ++;
         }
 
+        /**
+         * @author ishland
+         * @reason opt: replace with array access
+         */
         public boolean canSpawn(MobCategory spawnGroup) {
-            return this.counts.getOrDefault(spawnGroup, 0) < spawnGroup.getMaxInstancesPerChunk();
+            return this.spawnGroupDensities[spawnGroup.ordinal()] < spawnGroup.getMaxInstancesPerChunk();
         }
+        // Mirai end
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/biome/Biome.java b/src/main/java/net/minecraft/world/level/biome/Biome.java
index ed439b7e94646141c93a7dd3704d1cdeb5c27e16..c8988ee9d2ea7567faf2b0eb16e50d943d75cb91 100644
--- a/src/main/java/net/minecraft/world/level/biome/Biome.java
+++ b/src/main/java/net/minecraft/world/level/biome/Biome.java
@@ -67,7 +67,7 @@ public final class Biome {
     private final MobSpawnSettings mobSettings;
     private final BiomeSpecialEffects specialEffects;
     // Pufferfish start - use our cache
-    private final ThreadLocal<gg.airplane.structs.Long2FloatAgingCache> temperatureCache = ThreadLocal.withInitial(() -> {
+    private static final ThreadLocal<gg.airplane.structs.Long2FloatAgingCache> temperatureCache = ThreadLocal.withInitial(() -> { // Canvas - Improve BiomeTemperatureCache
         return Util.make(() -> {
             /*
             Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = new Long2FloatLinkedOpenHashMap(1024, 0.25F) {
@@ -125,7 +125,7 @@ public final class Biome {
     public float getTemperature(BlockPos blockPos) {
         long l = blockPos.asLong();
         // Pufferfish start
-        gg.airplane.structs.Long2FloatAgingCache cache = this.temperatureCache.get();
+        gg.airplane.structs.Long2FloatAgingCache cache = temperatureCache.get(); // Canvas - Improve BiomeTemperatureCache
         float f = cache.getValue(l);
         if (!Float.isNaN(f)) {
             return f;
diff --git a/src/main/java/net/minecraft/world/level/biome/BiomeManager.java b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
index 5695c5116c8a338b2e41aafcb2dc9f2146856970..e477b2f28121e043f2edfd0918e2a4dd8ba6f091 100644
--- a/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
+++ b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
@@ -28,41 +28,72 @@ public class BiomeManager {
         return new BiomeManager(storage, this.biomeZoomSeed);
     }
 
+    // Mirai start - carpetfixes: BiomeAccess prediction
+    private static final double maxOffset = 0.4500000001D; // Mirai - carpetfixes: BiomeAccess prediction
     public Holder<Biome> getBiome(BlockPos pos) {
-        int i = pos.getX() - 2;
-        int j = pos.getY() - 2;
-        int k = pos.getZ() - 2;
-        int l = i >> 2;
-        int m = j >> 2;
-        int n = k >> 2;
-        double d = (double)(i & 3) / 4.0D;
-        double e = (double)(j & 3) / 4.0D;
-        double f = (double)(k & 3) / 4.0D;
-        int o = 0;
-        double g = Double.POSITIVE_INFINITY;
-
-        for(int p = 0; p < 8; ++p) {
-            boolean bl = (p & 4) == 0;
-            boolean bl2 = (p & 2) == 0;
-            boolean bl3 = (p & 1) == 0;
-            int q = bl ? l : l + 1;
-            int r = bl2 ? m : m + 1;
-            int s = bl3 ? n : n + 1;
-            double h = bl ? d : d - 1.0D;
-            double t = bl2 ? e : e - 1.0D;
-            double u = bl3 ? f : f - 1.0D;
-            double v = getFiddledDistance(this.biomeZoomSeed, q, r, s, h, t, u);
-            if (g > v) {
-                o = p;
-                g = v;
+        int xMinus2 = pos.getX() - 2;
+        int yMinus2 = pos.getY() - 2;
+        int zMinus2 = pos.getZ() - 2;
+        int x = xMinus2 >> 2; // BlockPos to BiomePos
+        int y = yMinus2 >> 2;
+        int z = zMinus2 >> 2;
+        double quartX = (double) (xMinus2 & 3) / 4.0D; // quartLocal divided by 4
+        double quartY = (double) (yMinus2 & 3) / 4.0D; // 0/4, 1/4, 2/4, 3/4
+        double quartZ = (double) (zMinus2 & 3) / 4.0D; // [0, 0.25, 0.5, 0.75]
+        int smallestX = 0;
+        double smallestDist = Double.POSITIVE_INFINITY;
+        for (int biomeX = 0; biomeX < 8; ++biomeX) {
+            boolean everyOtherQuad = (biomeX & 4) == 0; // 1 1 1 1 0 0 0 0
+            boolean everyOtherPair = (biomeX & 2) == 0; // 1 1 0 0 1 1 0 0
+            boolean everyOther = (biomeX & 1) == 0; // 1 0 1 0 1 0 1 0
+            double quartXX = everyOtherQuad ? quartX : quartX - 1.0D; //[-1.0,-0.75,-0.5,-0.25,0.0,0.25,0.5,0.75]
+            double quartYY = everyOtherPair ? quartY : quartY - 1.0D;
+            double quartZZ = everyOther ? quartZ : quartZ - 1.0D;
+
+            //This code block is new
+            double maxQuartYY = 0.0D, maxQuartZZ = 0.0D;
+            if (biomeX != 0) {
+                maxQuartYY = Mth.square(Math.max(quartYY + maxOffset, Math.abs(quartYY - maxOffset)));
+                maxQuartZZ = Mth.square(Math.max(quartZZ + maxOffset, Math.abs(quartZZ - maxOffset)));
+                double maxQuartXX = Mth.square(Math.max(quartXX + maxOffset,Math.abs(quartXX - maxOffset)));
+                if (smallestDist < maxQuartXX + maxQuartYY + maxQuartZZ) continue;
+            }
+
+            int xx = everyOtherQuad ? x : x + 1;
+            int yy = everyOtherPair ? y : y + 1;
+            int zz = everyOther ? z : z + 1;
+
+            //I transferred the code from method_38106 to here, so I could call continue halfway through
+            long seed = LinearCongruentialGenerator.next(this.biomeZoomSeed, xx);
+            seed = LinearCongruentialGenerator.next(seed, yy);
+            seed = LinearCongruentialGenerator.next(seed, zz);
+            seed = LinearCongruentialGenerator.next(seed, xx);
+            seed = LinearCongruentialGenerator.next(seed, yy);
+            seed = LinearCongruentialGenerator.next(seed, zz);
+            double offsetX = getFiddle(seed);
+            double sqrX = Mth.square(quartXX + offsetX);
+            if (biomeX != 0 && smallestDist < sqrX + maxQuartYY + maxQuartZZ) continue; //skip the rest of the loop
+            seed = LinearCongruentialGenerator.next(seed, this.biomeZoomSeed);
+            double offsetY = getFiddle(seed);
+            double sqrY = Mth.square(quartYY + offsetY);
+            if (biomeX != 0 && smallestDist < sqrX + sqrY + maxQuartZZ) continue; // skip the rest of the loop
+            seed = LinearCongruentialGenerator.next(seed, this.biomeZoomSeed);
+            double offsetZ = getFiddle(seed);
+            double biomeDist = sqrX + sqrY + Mth.square(quartZZ + offsetZ);
+
+            if (smallestDist > biomeDist) {
+                smallestX = biomeX;
+                smallestDist = biomeDist;
             }
         }
 
-        int w = (o & 4) == 0 ? l : l + 1;
-        int x = (o & 2) == 0 ? m : m + 1;
-        int y = (o & 1) == 0 ? n : n + 1;
-        return this.noiseBiomeSource.getNoiseBiome(w, x, y);
+        return(this.noiseBiomeSource.getNoiseBiome(
+            (smallestX & 4) == 0 ? x : x + 1,
+            (smallestX & 2) == 0 ? y : y + 1,
+            (smallestX & 1) == 0 ? z : z + 1
+        ));
     }
+    // Mirai end
 
     public Holder<Biome> getNoiseBiomeAtPosition(double x, double y, double z) {
         int i = QuartPos.fromBlock(Mth.floor(x));
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 65504432a13df45e895cf6ca885627014444563a..69d4a3029b5e3ffcfd8ccb637f432ad1cd74997b 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -659,11 +659,18 @@ public class Block extends BlockBehaviour implements ItemLike {
         private final BlockState first;
         private final BlockState second;
         private final Direction direction;
+        private int hash; // JettPack
 
         public BlockStatePairKey(BlockState self, BlockState other, Direction facing) {
             this.first = self;
             this.second = other;
             this.direction = facing;
+            // JettPack start - lithium: cached_hashcode
+            int hash = this.first.hashCode();
+            hash = 31 * hash + this.second.hashCode();
+            hash = 31 * hash + this.direction.hashCode();
+            this.hash = hash;
+            // JettPack end
         }
 
         public boolean equals(Object object) {
@@ -679,11 +686,7 @@ public class Block extends BlockBehaviour implements ItemLike {
         }
 
         public int hashCode() {
-            int i = this.first.hashCode();
-
-            i = 31 * i + this.second.hashCode();
-            i = 31 * i + this.direction.hashCode();
-            return i;
+            return this.hash; // JettPack
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index 65112ec3a6ea1c27f032477720ae74395523012b..d05baf1d2dec991d58ba79351f83e45860dfd499 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -135,6 +135,13 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
             world.playSound((Player) null, pos, SoundEvents.SCULK_CATALYST_BLOOM, SoundSource.BLOCKS, 2.0F, 0.6F + random.nextFloat() * 0.4F);
         }
 
+    // petal start
+    @Override
+    public boolean listensToEvent(GameEvent gameEvent, GameEvent.Context context) {
+        return gameEvent == GameEvent.ENTITY_DIE && context.sourceEntity() instanceof LivingEntity;
+    }
+    // petal end
+
         private void tryAwardItSpreadsAdvancement(Level world, LivingEntity deadEntity) {
             LivingEntity entityliving1 = deadEntity.getLastHurtByMob();
 
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 1ef87580574919796dbba707f44a413ee5c5781b..5b032ebca4d38a8006899c11ac767989218a1aa1 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -55,6 +55,74 @@ public class PistonMovingBlockEntity extends BlockEntity {
         this.extending = extending;
         this.isSourcePiston = source;
     }
+    // JettPack start - lithium: block.moving_block_shapes
+    private static final VoxelShape[] PISTON_BASE_WITH_MOVING_HEAD_SHAPES = precomputePistonBaseWithMovingHeadShapes();
+
+    /**
+     * We cache the offset and simplified VoxelShapes that are otherwise constructed on every call of getCollisionShape.
+     * For each offset direction and distance (6 directions, 2 distances each, and no direction with 0 distance) we
+     * store the offset and simplified VoxelShapes in the original VoxelShape when they are accessed the first time.
+     * We use safe publication, because both the Render and Server thread are using the cache.
+     *
+     * @param blockShape the original shape, must not be modified after passing it as an argument to this method
+     * @param offset     the offset distance
+     * @param direction  the offset direction
+     * @return blockShape offset and simplified
+     */
+    private static VoxelShape getOffsetAndSimplified(VoxelShape blockShape, float offset, Direction direction) {
+        VoxelShape offsetSimplifiedShape = blockShape.getOffsetSimplifiedShape(offset, direction);
+        if (offsetSimplifiedShape == null) {
+            //create the offset shape and store it for later use
+            offsetSimplifiedShape = blockShape.move(direction.getStepX() * offset, direction.getStepY() * offset, direction.getStepZ() * offset).optimize();
+            blockShape.setShape(offset, direction, offsetSimplifiedShape);
+        }
+        return offsetSimplifiedShape;
+    }
+
+    /**
+     * Precompute all 18 possible configurations for the merged piston base and head shape.
+     *
+     * @return The array of the merged VoxelShapes, indexed by {@link PistonBlockEntityMixin#getIndexForMergedShape(float, Direction)}
+     */
+    private static VoxelShape[] precomputePistonBaseWithMovingHeadShapes() {
+        float[] offsets = {0f, 0.5f, 1f};
+        Direction[] directions = Direction.values();
+
+        VoxelShape[] mergedShapes = new VoxelShape[offsets.length * directions.length];
+
+        for (Direction facing : directions) {
+            VoxelShape baseShape = Blocks.PISTON.defaultBlockState().setValue(PistonBaseBlock.EXTENDED, true)
+                    .setValue(PistonBaseBlock.FACING, facing).getCollisionShape(null, null);
+            for (float offset : offsets) {
+                //this cache is only required for the merged piston head + base shape.
+                //this shape is only used when !this.extending
+                //here: isShort = this.extending != 1.0F - this.progress < 0.25F can be simplified to:
+                //isShort = f < 0.25F , because f = getAmountExtended(this.progress) can be simplified to f == 1.0F - this.progress
+                //therefore isShort is dependent on the offset:
+                boolean isShort = offset < 0.25f;
+
+                VoxelShape headShape = (Blocks.PISTON_HEAD.defaultBlockState().setValue(PistonHeadBlock.FACING, facing))
+                        .setValue(PistonHeadBlock.SHORT, isShort).getCollisionShape(null, null);
+
+                VoxelShape offsetHead = headShape.move(facing.getStepX() * offset,
+                        facing.getStepY() * offset,
+                        facing.getStepZ() * offset);
+                mergedShapes[getIndexForMergedShape(offset, facing)] = Shapes.or(baseShape, offsetHead);
+            }
+
+        }
+
+        return mergedShapes;
+    }
+
+    private static int getIndexForMergedShape(float offset, Direction direction) {
+        if (offset != 0f && offset != 0.5f && offset != 1f) {
+            return -1;
+        }
+        //shape of offset 0 is still dependent on the direction, due to piston head and base being directional blocks
+        return (int) (2 * offset) + (3 * direction.get3DDataValue());
+    }
+    // JettPack end
 
     @Override
     public CompoundTag getUpdateTag() {
@@ -355,10 +423,27 @@ public class PistonMovingBlockEntity extends BlockEntity {
             }
 
             float f = this.getExtendedProgress(this.progress);
+            // JettPack start - lithium: block.moving_block_shapes
+            if (this.extending || !this.isSourcePiston || !(this.movedState.getBlock() instanceof PistonBaseBlock)) {
+                //here voxelShape2.isEmpty() is guaranteed, vanilla code would call union() which calls simplify()
+                VoxelShape blockShape = blockState.getCollisionShape(world, pos);
+
+                //we cache the simplified shapes, as the simplify() method costs a lot of CPU time and allocates several objects
+                VoxelShape offsetAndSimplified = getOffsetAndSimplified(blockShape, Math.abs(f), f < 0f ? this.direction.getOpposite() : this.direction);
+                return offsetAndSimplified;
+            } else {
+                //retracting piston heads have to act like their base as well, as the base block is replaced with the moving block
+                //f >= 0f is guaranteed (assuming no other mod interferes)
+                int index = getIndexForMergedShape(f, this.direction);
+                return PISTON_BASE_WITH_MOVING_HEAD_SHAPES[index];
+            }
+            /*
             double d = (double)((float)this.direction.getStepX() * f);
             double e = (double)((float)this.direction.getStepY() * f);
             double g = (double)((float)this.direction.getStepZ() * f);
             return Shapes.or(voxelShape, blockState.getCollisionShape(world, pos).move(d, e, g));
+            */
+            // JettPack end
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
index 5f285d190186a2ff5a61d05070593e1d633dd79a..6eeb9f0e8a308a4089b0d8bd2a519eac82f71e03 100644
--- a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
+++ b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
@@ -114,21 +114,15 @@ public abstract class StateHolder<O, S> {
     }
 
     public <T extends Comparable<T>, V extends T> S trySetValue(Property<T> property, V value) {
-        Comparable<?> comparable = this.values.get(property);
-        if (comparable != null && !comparable.equals(value)) {
-            S object = this.neighbours.get(property, value);
-            if (object == null) {
-                throw new IllegalArgumentException("Cannot set property " + property + " to " + value + " on " + this.owner + ", it is not an allowed value");
-            } else {
-                return object;
-            }
-        } else {
-            return (S)this;
-        }
+        // Canvas start - optimise state lookup
+        final S ret = (S) this.optimisedTable.get(property, value);
+        if (ret == null) throw new IllegalArgumentException("Cannot set property " + property + " to " + value + " on " + this.owner + ", it is not an allowed value");
+        return ret;
+        // Canvas end
     }
 
     public void populateNeighbours(Map<Map<Property<?>, Comparable<?>>, S> states) {
-        if (this.neighbours != null) {
+        if (this.optimisedTable.index_table() != null) { // Canvas - optimise state lookup
             throw new IllegalStateException();
         } else {
             Table<Property<?>, Comparable<?>, S> table = HashBasedTable.create();
@@ -143,7 +137,7 @@ public abstract class StateHolder<O, S> {
                 }
             }
 
-            this.neighbours = (Table<Property<?>, Comparable<?>, S>)(table.isEmpty() ? table : ArrayTable.create(table)); this.optimisedTable.loadInTable((Table)this.neighbours, this.values); // Paper - optimise state lookup
+            this.optimisedTable.loadInTable((Table) (table.isEmpty() ? table : ArrayTable.create(table)), this.values); // Canvas - optimise state lookup
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 66656c4cf157228c9f52b33b358713ef0172f9ff..673d1b07d0a1b034260b143f5b9f1ac9f86be1dc 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -81,7 +81,19 @@ public class LevelChunk extends ChunkAccess {
     private Supplier<FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
-    private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
+    // petal start
+    private final GameEventListenerRegistry[] gameEventListenerRegistrySections;
+    private static final int GAME_EVENT_DISPATCHER_RADIUS = 2;
+
+    private static int getGameEventSectionIndex(int sectionIndex) {
+        return sectionIndex + GAME_EVENT_DISPATCHER_RADIUS;
+    }
+
+    private static int getGameEventSectionLength(int sectionCount) {
+        return sectionCount + (GAME_EVENT_DISPATCHER_RADIUS * 2);
+    }
+
+    // petal end
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
     public volatile FullChunkStatus chunkStatus = FullChunkStatus.INACCESSIBLE; // Paper - rewrite chunk system
@@ -106,7 +118,7 @@ public class LevelChunk extends ChunkAccess {
         super(pos, upgradeData, world, net.minecraft.server.MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.BIOME), inhabitedTime, sectionArrayInitializer, blendingData); // Paper - Anti-Xray - The world isn't ready yet, use server singleton for registry
         this.tickersInLevel = Maps.newHashMap();
         this.level = (ServerLevel) world; // CraftBukkit - type
-        this.gameEventListenerRegistrySections = new Int2ObjectOpenHashMap();
+        this.gameEventListenerRegistrySections = new GameEventListenerRegistry[getGameEventSectionLength(this.getSectionsCount())]; // petal
         Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
         int j = aheightmap_type.length;
 
@@ -305,9 +317,23 @@ public class LevelChunk extends ChunkAccess {
         if (world instanceof ServerLevel) {
             ServerLevel worldserver = (ServerLevel) world;
 
-            return (GameEventListenerRegistry) this.gameEventListenerRegistrySections.computeIfAbsent(ySectionCoord, (j) -> {
-                return new EuclideanGameEventListenerRegistry(worldserver, ySectionCoord, this::removeGameEventListenerRegistry);
-            });
+            // petal start
+            int sectionIndex = getGameEventSectionIndex(this.getSectionIndexFromSectionY(ySectionCoord));
+
+            // drop game events that are too far away (32 blocks) from loaded sections
+            // this matches the highest radius of game events in the game
+            if (sectionIndex < 0 || sectionIndex >= this.gameEventListenerRegistrySections.length) {
+                return GameEventListenerRegistry.NOOP;
+            }
+
+            var dispatcher = this.gameEventListenerRegistrySections[sectionIndex];
+
+            if (dispatcher == null) {
+                dispatcher = this.gameEventListenerRegistrySections[sectionIndex] = new EuclideanGameEventListenerRegistry(worldserver, ySectionCoord, this::removeGameEventListenerRegistry);
+            }
+
+            return dispatcher;
+            // petal end
         } else {
             return super.getListenerRegistry(ySectionCoord);
         }
@@ -686,7 +712,7 @@ public class LevelChunk extends ChunkAccess {
     }
 
     private void removeGameEventListenerRegistry(int ySectionCoord) {
-        this.gameEventListenerRegistrySections.remove(ySectionCoord);
+        this.gameEventListenerRegistrySections[getGameEventSectionIndex(this.getSectionIndexFromSectionY(ySectionCoord))] = null; // petal
     }
 
     private void removeBlockEntityTicker(BlockPos pos) {
@@ -802,7 +828,7 @@ public class LevelChunk extends ChunkAccess {
             if (this.needsDecoration) {
                 //try (co.aikar.timings.Timing ignored = this.level.timings.chunkLoadPopulate.startTiming()) { // Paper // Purpur
                 this.needsDecoration = false;
-                java.util.Random random = new java.util.Random();
+                java.util.Random random = new me.satvrn.random.FastRandom(); // Graphene
                 random.setSeed(this.level.getSeed());
                 long xRand = random.nextLong() / 2L * 2L + 1L;
                 long zRand = random.nextLong() / 2L * 2L + 1L;
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 9248769e6d357f6eec68945fd7700e79b2942c41..e08101042c8b9be47fb42a7229c742595b49d101 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -28,6 +28,7 @@ import org.slf4j.Logger;
 
 public class RegionFile implements AutoCloseable {
 
+    private static final java.util.Random RANDOM = new me.satvrn.random.FastRandom(); // Graphene
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int SECTOR_BYTES = 4096;
     @VisibleForTesting
@@ -108,7 +109,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     private void backupRegionFile() {
-        Path backup = this.regionFile.getParent().resolve(this.regionFile.getFileName() + "." + new java.util.Random().nextLong() + ".backup");
+        Path backup = this.regionFile.getParent().resolve(this.regionFile.getFileName() + "." + RANDOM.nextLong() + ".backup"); // Graphene
         this.backupRegionFile(backup);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index ee692b49c62f36287bf9d008861f5d47e0e42c00..fc19193602514717588aa6e407cbd3e5e8192635 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -33,7 +33,7 @@ public class EntitySectionStorage<T extends EntityAccess> {
     }
 
     public void forEachAccessibleNonEmptySection(AABB box, AbortableIterationConsumer<EntitySection<T>> consumer) {
-        int i = 2;
+        // Mirai start - lithium: fast retrieval
         int j = SectionPos.posToSectionCoord(box.minX - 2.0D);
         int k = SectionPos.posToSectionCoord(box.minY - 4.0D);
         int l = SectionPos.posToSectionCoord(box.minZ - 2.0D);
@@ -41,25 +41,67 @@ public class EntitySectionStorage<T extends EntityAccess> {
         int n = SectionPos.posToSectionCoord(box.maxY + 0.0D);
         int o = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
 
-        for(int p = j; p <= m; ++p) {
-            long q = SectionPos.asLong(p, 0, 0);
-            long r = SectionPos.asLong(p, -1, -1);
-            LongIterator longIterator = this.sectionIds.subSet(q, r + 1L).iterator();
-
-            while(longIterator.hasNext()) {
-                long s = longIterator.nextLong();
-                int t = SectionPos.y(s);
-                int u = SectionPos.z(s);
-                if (t >= k && t <= n && u >= l && u <= o) {
-                    EntitySection<T> entitySection = this.sections.get(s);
-                    if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible() && consumer.accept(entitySection).shouldAbort()) {
-                        return;
+        if (m >= j + 4 || o >= l + 4) {
+            // Vanilla is likely more optimized when shooting entities with TNT cannons over huge distances.
+            // Choosing a cutoff of 4 chunk size, as it becomes more likely that these entity sections do not exist when
+            // they are far away from the shot entity (player despawn range, position maybe not on the ground, etc)
+            for (int p = j; p <= m; p++) {
+                long q = SectionPos.asLong(p, 0, 0);
+                long r = SectionPos.asLong(p, -1, -1);
+                LongIterator longIterator = this.sectionIds.subSet(q, r + 1L).iterator();
+
+                while (longIterator.hasNext()) {
+                    long s = longIterator.nextLong();
+                    int t = SectionPos.y(s);
+                    int u = SectionPos.z(s);
+                    if (t >= k && t <= n && u >= l && u <= o) {
+                        EntitySection<T> entitySection = this.sections.get(s);
+                        if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
+                            consumer.accept(entitySection);
+                        }
                     }
                 }
             }
+        } else {
+            // Vanilla order of the AVL long set is sorting by ascending long value. The x, y, z positions are packed into
+            // a long with the x position's lowest 22 bits placed at the MSB.
+            // Therefore the long is negative iff the 22th bit of the x position is set, which happens iff the x position
+            // is negative. A positive x position will never have its 22th bit set, as these big coordinates are far outside
+            // the world. y and z positions are treated as unsigned when sorting by ascending long value, as their sign bits
+            // are placed somewhere inside the packed long
+            for (int x = j; x <= m; x++) {
+                for (int z = Math.max(l, 0); z <= o; z++) {
+                    this.forEachInColumn(x, k, n, z, consumer);
+                }
+
+                int bound = Math.min(-1, o);
+                for (int z = l; z <= bound; z++) {
+                    this.forEachInColumn(x, k, n, z, consumer);
+                }
+            }
         }
+        // Mirai end
+    }
 
+    // Mirai start - lithium: fast retrieval
+    private void forEachInColumn(int x, int k, int n, int z, AbortableIterationConsumer<EntitySection<T>> consumer) {
+        //y from negative to positive, but y is treated as unsigned
+        for (int y = Math.max(k, 0); y <= n; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), consumer);
+        }
+        int bound = Math.min(-1, n);
+        for (int y = k; y <= bound; y++) {
+            this.consumeSection(SectionPos.asLong(x, y, z), consumer);
+        }
+    }
+
+    private void consumeSection(long pos, AbortableIterationConsumer<EntitySection<T>> consumer) {
+        EntitySection<T> entitySection = this.sections.get(pos);
+        if (entitySection != null && 0 != entitySection.size() && entitySection.getStatus().isAccessible()) {
+            consumer.accept(entitySection);
+        }
     }
+    // Mirai end
 
     public LongStream getExistingSectionPositionsInChunk(long chunkPos) {
         int i = ChunkPos.getX(chunkPos);
diff --git a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
index f30b2e964acdf44014065bd491a577040e61a2c2..9374b3b9e039843d4c2ea974f777d1da91f7eb24 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
@@ -13,8 +13,8 @@ import net.minecraft.world.phys.Vec3;
 
 public class EuclideanGameEventListenerRegistry implements GameEventListenerRegistry {
     private final List<GameEventListener> listeners = Lists.newArrayList();
-    private final Set<GameEventListener> listenersToRemove = Sets.newHashSet();
-    private final List<GameEventListener> listenersToAdd = Lists.newArrayList();
+    //private final Set<GameEventListener> listenersToRemove = Sets.newHashSet(); // petal - not necessary
+    //private final List<GameEventListener> listenersToAdd = Lists.newArrayList(); // petal
     private boolean processing;
     private final ServerLevel level;
     private final int sectionY;
@@ -34,7 +34,7 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
     @Override
     public void register(GameEventListener listener) {
         if (this.processing) {
-            this.listenersToAdd.add(listener);
+            throw new java.util.ConcurrentModificationException(); // petal - disallow concurrent modification
         } else {
             this.listeners.add(listener);
         }
@@ -45,7 +45,7 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
     @Override
     public void unregister(GameEventListener listener) {
         if (this.processing) {
-            this.listenersToRemove.add(listener);
+            throw new java.util.ConcurrentModificationException(); // petal - disallow concurrent modification
         } else {
             this.listeners.remove(listener);
         }
@@ -66,7 +66,7 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
 
             while(iterator.hasNext()) {
                 GameEventListener gameEventListener = iterator.next();
-                if (this.listenersToRemove.remove(gameEventListener)) {
+                if (false) { // petal - disallow concurrent modification
                     iterator.remove();
                 } else {
                     Optional<Vec3> optional = getPostableListenerPosition(this.level, pos, gameEventListener);
@@ -80,6 +80,8 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
             this.processing = false;
         }
 
+        // petal start
+        /*
         if (!this.listenersToAdd.isEmpty()) {
             this.listeners.addAll(this.listenersToAdd);
             this.listenersToAdd.clear();
@@ -89,6 +91,8 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
             this.listeners.removeAll(this.listenersToRemove);
             this.listenersToRemove.clear();
         }
+        */
+        // petal end
 
         return bl;
     }
diff --git a/src/main/java/net/minecraft/world/level/gameevent/GameEventListener.java b/src/main/java/net/minecraft/world/level/gameevent/GameEventListener.java
index a4148dd326b10b0eb2bc7884691d79dcda60e010..af9994c54d075f4d17d23551a366e381319c4d0c 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/GameEventListener.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/GameEventListener.java
@@ -10,6 +10,12 @@ public interface GameEventListener {
 
     boolean handleGameEvent(ServerLevel world, GameEvent event, GameEvent.Context emitter, Vec3 emitterPos);
 
+    // petal start - add check for seeing if this listener cares about an event
+    default boolean listensToEvent(net.minecraft.world.level.gameevent.GameEvent gameEvent, net.minecraft.world.level.gameevent.GameEvent.Context context) {
+        return true;
+    }
+    // petal end
+
     default GameEventListener.DeliveryMode getDeliveryMode() {
         return GameEventListener.DeliveryMode.UNSPECIFIED;
     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
index f9ee7e23e69a36730c5585a2989cebdc6b2f3342..e84a8bf780dbdcbb5ee1b1260928dc2b3ad21b39 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
@@ -13,6 +13,10 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration;
+// Mirai start - c2me: opts allocs
+import com.ishland.c2me.opts.allocs.common.PooledFeatureContext;
+import com.ishland.c2me.opts.allocs.common.SimpleObjectPool;
+// Mirai end
 
 public record ConfiguredFeature<FC extends FeatureConfiguration, F extends Feature<FC>>(F feature, FC config) {
     public static final Codec<ConfiguredFeature<?, ?>> DIRECT_CODEC = BuiltInRegistries.FEATURE.byNameCodec().dispatch((configuredFeature) -> {
@@ -22,7 +26,22 @@ public record ConfiguredFeature<FC extends FeatureConfiguration, F extends Featu
     public static final Codec<HolderSet<ConfiguredFeature<?, ?>>> LIST_CODEC = RegistryCodecs.homogeneousList(Registries.CONFIGURED_FEATURE, DIRECT_CODEC);
 
     public boolean place(WorldGenLevel world, ChunkGenerator chunkGenerator, RandomSource random, BlockPos origin) {
-        return this.feature.place(this.config, world, chunkGenerator, random, origin);
+        // Mirai start - c2me: opts allocs
+        /**
+         * @author ishland
+         * @reason pool FeatureContext
+         */
+        if (!world.ensureCanWrite(origin)) return false;
+        final SimpleObjectPool<PooledFeatureContext<?>> pool = PooledFeatureContext.POOL.get();
+        final PooledFeatureContext<FC> context = (PooledFeatureContext<FC>) pool.alloc();
+        try {
+            context.reInit(java.util.Optional.empty(), world, chunkGenerator, random, origin, this.config);
+            return this.feature.place(context);
+        } finally {
+            context.reInit();
+            pool.release(context);
+        }
+        // Mirai end
     }
 
     public Stream<ConfiguredFeature<?, ?>> getFeatures() {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
index 4be60b8d321d8f8cdd97deee16f4b42e428e57cf..1b3242bd8ce5443c622ee08050955cfe56133744 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/OreFeature.java
@@ -54,7 +54,7 @@ public class OreFeature extends Feature<OreConfiguration> {
 
     protected boolean doPlace(WorldGenLevel world, RandomSource random, OreConfiguration config, double startX, double endX, double startZ, double endZ, double startY, double endY, int x, int y, int z, int horizontalSize, int verticalSize) {
         int i = 0;
-        BitSet bitSet = new BitSet(horizontalSize * verticalSize * horizontalSize);
+        BitSet bitSet = com.ishland.c2me.opts.allocs.common.ObjectCachingUtils.getCachedOrNewBitSet(horizontalSize * verticalSize * horizontalSize); // Mirai - c2me: opts allocs
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
         int j = config.size;
         double[] ds = new double[j * 4];
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
index fb84d703b4461343d50510d7c9be32fc1f09ed22..3da6b30febc98e5392e42d39c5bd69a82116dc2d 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
@@ -11,6 +11,27 @@ public final class ImprovedNoise {
     public final double yo;
     public final double zo;
 
+    // Mirai start - c2me: opts math
+    private static final double[] FLAT_SIMPLEX_GRAD = new double[]{
+            1, 1, 0, 0,
+            -1, 1, 0, 0,
+            1, -1, 0, 0,
+            -1, -1, 0, 0,
+            1, 0, 1, 0,
+            -1, 0, 1, 0,
+            1, 0, -1, 0,
+            -1, 0, -1, 0,
+            0, 1, 1, 0,
+            0, -1, 1, 0,
+            0, 1, -1, 0,
+            0, -1, -1, 0,
+            1, 1, 0, 0,
+            0, -1, 1, 0,
+            -1, 1, 0, 0,
+            0, -1, -1, 0,
+    };
+    // Mirai end
+
     public ImprovedNoise(RandomSource random) {
         this.xo = random.nextDouble() * 256.0D;
         this.yo = random.nextDouble() * 256.0D;
@@ -34,34 +55,38 @@ public final class ImprovedNoise {
         return this.noise(x, y, z, 0.0D, 0.0D);
     }
 
+    // Mirai start - c2me: opts math
+    /**
+     * @author ishland
+     * @reason optimize: remove frequent type conversions
+     */
     /** @deprecated */
     @Deprecated
     public double noise(double x, double y, double z, double yScale, double yMax) {
         double d = x + this.xo;
         double e = y + this.yo;
         double f = z + this.zo;
-        int i = Mth.floor(d);
-        int j = Mth.floor(e);
-        int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
-        double o;
-        if (yScale != 0.0D) {
+        double i = Mth.floor(d);
+        double j = Mth.floor(e);
+        double k = Mth.floor(f);
+        double g = d - i;
+        double h = e - j;
+        double l = f - k;
+        double o = 0.0D;
+        if (yScale != 0.0) {
             double m;
-            if (yMax >= 0.0D && yMax < h) {
+            if (yMax >= 0.0 && yMax < h) {
                 m = yMax;
             } else {
                 m = h;
             }
 
-            o = (double)Mth.floor(m / yScale + (double)1.0E-7F) * yScale;
-        } else {
-            o = 0.0D;
+            o = Mth.floor(m / yScale + 1.0E-7F) * yScale;
         }
 
-        return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        return this.sampleAndLerp((int) i, (int) j, (int) k, g, h - o, l, h);
     }
+    // Mirai end
 
     public double noiseWithDerivative(double x, double y, double z, double[] ds) {
         double d = x + this.xo;
@@ -84,26 +109,76 @@ public final class ImprovedNoise {
         return this.p[input & 255] & 255;
     }
 
-    private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalY) {
-        int i = this.p(sectionX);
-        int j = this.p(sectionX + 1);
-        int k = this.p(i + sectionY);
-        int l = this.p(i + sectionY + 1);
-        int m = this.p(j + sectionY);
-        int n = this.p(j + sectionY + 1);
-        double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
-        double e = gradDot(this.p(m + sectionZ), localX - 1.0D, localY, localZ);
-        double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0D, localZ);
-        double g = gradDot(this.p(n + sectionZ), localX - 1.0D, localY - 1.0D, localZ);
-        double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0D);
-        double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0D, localY, localZ - 1.0D);
-        double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0D, localZ - 1.0D);
-        double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0D, localY - 1.0D, localZ - 1.0D);
-        double r = Mth.smoothstep(localX);
-        double s = Mth.smoothstep(fadeLocalY);
-        double t = Mth.smoothstep(localZ);
-        return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+    // Mirai start - c2me: opts math
+    /**
+     * @author ishland
+     * @reason inline math & small optimization: remove frequent type conversions and redundant ops
+     */
+    private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalX) {
+        // TODO [VanillaCopy] but optimized
+        final int var0 = sectionX & 0xFF;
+        final int var1 = (sectionX + 1) & 0xFF;
+        final int var2 = this.p[var0] & 0xFF;
+        final int var3 = this.p[var1] & 0xFF;
+        final int var4 = (var2 + sectionY) & 0xFF;
+        final int var5 = (var3 + sectionY) & 0xFF;
+        final int var6 = (var2 + sectionY + 1) & 0xFF;
+        final int var7 = (var3 + sectionY + 1) & 0xFF;
+        final int var8 = this.p[var4] & 0xFF;
+        final int var9 = this.p[var5] & 0xFF;
+        final int var10 = this.p[var6] & 0xFF;
+        final int var11 = this.p[var7] & 0xFF;
+
+        final int var12 = (var8 + sectionZ) & 0xFF;
+        final int var13 = (var9 + sectionZ) & 0xFF;
+        final int var14 = (var10 + sectionZ) & 0xFF;
+        final int var15 = (var11 + sectionZ) & 0xFF;
+        final int var16 = (var8 + sectionZ + 1) & 0xFF;
+        final int var17 = (var9 + sectionZ + 1) & 0xFF;
+        final int var18 = (var10 + sectionZ + 1) & 0xFF;
+        final int var19 = (var11 + sectionZ + 1) & 0xFF;
+        final int var20 = (this.p[var12] & 15) << 2;
+        final int var21 = (this.p[var13] & 15) << 2;
+        final int var22 = (this.p[var14] & 15) << 2;
+        final int var23 = (this.p[var15] & 15) << 2;
+        final int var24 = (this.p[var16] & 15) << 2;
+        final int var25 = (this.p[var17] & 15) << 2;
+        final int var26 = (this.p[var18] & 15) << 2;
+        final int var27 = (this.p[var19] & 15) << 2;
+        final double var60 = localX - 1.0;
+        final double var61 = localY - 1.0;
+        final double var62 = localZ - 1.0;
+        final double var87 = FLAT_SIMPLEX_GRAD[(var20) | 0] * localX + FLAT_SIMPLEX_GRAD[(var20) | 1] * localY + FLAT_SIMPLEX_GRAD[(var20) | 2] * localZ;
+        final double var88 = FLAT_SIMPLEX_GRAD[(var21) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var21) | 1] * localY + FLAT_SIMPLEX_GRAD[(var21) | 2] * localZ;
+        final double var89 = FLAT_SIMPLEX_GRAD[(var22) | 0] * localX + FLAT_SIMPLEX_GRAD[(var22) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var22) | 2] * localZ;
+        final double var90 = FLAT_SIMPLEX_GRAD[(var23) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var23) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var23) | 2] * localZ;
+        final double var91 = FLAT_SIMPLEX_GRAD[(var24) | 0] * localX + FLAT_SIMPLEX_GRAD[(var24) | 1] * localY + FLAT_SIMPLEX_GRAD[(var24) | 2] * var62;
+        final double var92 = FLAT_SIMPLEX_GRAD[(var25) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var25) | 1] * localY + FLAT_SIMPLEX_GRAD[(var25) | 2] * var62;
+        final double var93 = FLAT_SIMPLEX_GRAD[(var26) | 0] * localX + FLAT_SIMPLEX_GRAD[(var26) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var26) | 2] * var62;
+        final double var94 = FLAT_SIMPLEX_GRAD[(var27) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var27) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var27) | 2] * var62;
+
+        final double var95 = localX * 6.0 - 15.0;
+        final double var96 = fadeLocalX * 6.0 - 15.0;
+        final double var97 = localZ * 6.0 - 15.0;
+        final double var98 = localX * var95 + 10.0;
+        final double var99 = fadeLocalX * var96 + 10.0;
+        final double var100 = localZ * var97 + 10.0;
+        final double var101 = localX * localX * localX * var98;
+        final double var102 = fadeLocalX * fadeLocalX * fadeLocalX * var99;
+        final double var103 = localZ * localZ * localZ * var100;
+
+        final double var113 = var87 + var101 * (var88 - var87);
+        final double var114 = var93 + var101 * (var94 - var93);
+        final double var115 = var91 + var101 * (var92 - var91);
+        final double var116 = var89 + var101 * (var90 - var89);
+        final double var117 = var114 - var115;
+        final double var118 = var102 * (var116 - var113);
+        final double var119 = var102 * var117;
+        final double var120 = var113 + var118;
+        final double var121 = var115 + var119;
+        return var120 + (var103 * (var121 - var120));
     }
+    // Mirai end
 
     private double sampleWithDerivative(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double[] ds) {
         int i = this.p(sectionX);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
index 97ef7288ea935f3d17c5b7a9eba642143c786c2b..0a4dd6c6b48e79d40c4b0790c2b2178f894c984a 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
@@ -26,6 +26,10 @@ public class PerlinNoise {
     private final double lowestFreqValueFactor;
     private final double lowestFreqInputFactor;
     private final double maxValue;
+    // Mirai start - c2me: opts math
+    private int octaveSamplersCount = 0;
+    private double[] amplitudesArray = null;
+    // Mirai end
 
     /** @deprecated */
     @Deprecated
@@ -131,6 +135,10 @@ public class PerlinNoise {
         this.lowestFreqInputFactor = Math.pow(2.0D, (double)(-j));
         this.lowestFreqValueFactor = Math.pow(2.0D, (double)(i - 1)) / (Math.pow(2.0D, (double)i) - 1.0D);
         this.maxValue = this.edgeValue(2.0D);
+        // Mirai start - c2me: opts math
+        this.octaveSamplersCount = this.noiseLevels.length;
+        this.amplitudesArray = this.amplitudes.toDoubleArray();
+        // Mirai end
     }
 
     protected double maxValue() {
@@ -141,9 +149,33 @@ public class PerlinNoise {
         random.consumeCount(262);
     }
 
+    // Mirai start - c2me: opts math
+    /**
+     * @author ishland
+     * @reason optimize for common cases
+     */
     public double getValue(double x, double y, double z) {
-        return this.getValue(x, y, z, 0.0D, 0.0D, false);
+        double d = 0.0;
+        double e = this.lowestFreqInputFactor;
+        double f = this.lowestFreqValueFactor;
+
+        for(int i = 0; i < this.octaveSamplersCount; ++i) {
+            ImprovedNoise perlinNoiseSampler = this.noiseLevels[i];
+            if (perlinNoiseSampler != null) {
+                @SuppressWarnings("deprecation")
+                double g = perlinNoiseSampler.noise(
+                        wrap(x * e), wrap(y * e), wrap(z * e), 0.0, 0.0
+                );
+                d += this.amplitudesArray[i] * g * f;
+            }
+
+            e *= 2.0;
+            f /= 2.0;
+        }
+
+        return d;
     }
+    // Mirai end
 
     /** @deprecated */
     @Deprecated
@@ -191,9 +223,15 @@ public class PerlinNoise {
         return this.noiseLevels[this.noiseLevels.length - 1 - octave];
     }
 
+    // Mirai start - c2me: opts math
+    /**
+     * @author ishland
+     * @reason remove frequent type conversion
+     */
     public static double wrap(double value) {
-        return value - (double)Mth.lfloor(value / 3.3554432E7D + 0.5D) * 3.3554432E7D;
+        return value - Mth.lfloor(value / 3.3554432E7 + 0.5) * 3.3554432E7;
     }
+    // Mirai end
 
     protected int firstOctave() {
         return this.firstOctave;
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 36af81f0957d17e170d229059c66f4eb4539dfeb..3890a96482b4be4ce6876adacb86d87514cd4ff1 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -56,7 +56,8 @@ public class PlayerDataStorage {
             File file = new File(this.playerDir, player.getStringUUID() + ".dat");
             // Spigot Start
             boolean usingWrongFile = false;
-            if ( org.bukkit.Bukkit.getOnlineMode() && !file.exists() ) // Paper - Check online mode first
+            boolean normalFile = file.exists() && file.isFile(); // Akarin - ensures normal file
+            if ( org.bukkit.Bukkit.getOnlineMode() && !normalFile ) // Paper - Check online mode first // Akarin - ensures normal file
             {
                 file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
                 if ( file.exists() )
@@ -67,7 +68,7 @@ public class PlayerDataStorage {
             }
             // Spigot End
 
-            if (file.exists() && file.isFile()) {
+            if (normalFile) { // Akarin - avoid double I/O operation
                 nbttagcompound = NbtIo.readCompressed(file);
             }
             // Spigot Start
diff --git a/src/main/java/net/minecraft/world/phys/AABB.java b/src/main/java/net/minecraft/world/phys/AABB.java
index 5c70aa2ce1a9e89c8c271201b6755ea1325058ac..2ab17893b7dddbd1e9bae86c13d5ff976306bc09 100644
--- a/src/main/java/net/minecraft/world/phys/AABB.java
+++ b/src/main/java/net/minecraft/world/phys/AABB.java
@@ -8,6 +8,15 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 
 public class AABB {
+    // Graphene start - lithum: math.fast_util
+    static {
+        assert Direction.Axis.X.ordinal() == 0;
+        assert Direction.Axis.Y.ordinal() == 1;
+        assert Direction.Axis.Z.ordinal() == 2;
+        assert Direction.Axis.values().length == 3;
+    }
+    // Graphene end
+
     private static final double EPSILON = 1.0E-7D;
     public final double minX;
     public final double minY;
@@ -81,11 +90,35 @@ public class AABB {
     }
 
     public double min(Direction.Axis axis) {
-        return axis.choose(this.minX, this.minY, this.minZ);
+        //return axis.choose(this.minX, this.minY, this.minZ); // Graphene - lithum: math.fast_util
+        // Graphene start - lithum: math.fast_util
+        switch (axis.ordinal()) {
+            case 0: //X
+                return this.minX;
+            case 1: //Y
+                return this.minY;
+            case 2: //Z
+                return this.minZ;
+        }
+
+        throw new IllegalArgumentException();
+        // Graphene end
     }
 
     public double max(Direction.Axis axis) {
-        return axis.choose(this.maxX, this.maxY, this.maxZ);
+        //return axis.choose(this.maxX, this.maxY, this.maxZ); // Graphene - lithum: math.fast_util
+        // Graphene start - lithum: math.fast_util
+        switch (axis.ordinal()) {
+            case 0: //X
+                return this.maxX;
+            case 1: //Y
+                return this.maxY;
+            case 2: //Z
+                return this.maxZ;
+        }
+
+        throw new IllegalArgumentException();
+        // Graphene end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index a544db042c8d2ecec8d323770552c4f10ca758a6..c04da8da5b40430b61972bce32cec4e8c0370bac 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -4,6 +4,7 @@ import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
     private final int parts;
+    private double scale; // JettPack - lithium: shapes.precompute_shape_arrays
 
     CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
@@ -11,10 +12,11 @@ public class CubePointRange extends AbstractDoubleList {
         } else {
             this.parts = sectionCount;
         }
+        this.scale = 1.0D / sectionCount; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        return i * this.scale; // JettPack - lithium: shapes.precompute_shape_arrays
     }
 
     public int size() {
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
index 110405e6e70d980d3e09f04d79562b32a7413071..62d72bd9e7b0ee31cea0d43f3568762ce1ec29fb 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubeVoxelShape.java
@@ -5,6 +5,8 @@ import net.minecraft.core.Direction;
 import net.minecraft.util.Mth;
 
 public final class CubeVoxelShape extends VoxelShape {
+    private DoubleList[] list; // Gale - Lithium - cache CubeVoxelShape shape array
+
     protected CubeVoxelShape(DiscreteVoxelShape voxels) {
         super(voxels);
         this.initCache(); // Paper - optimise collisions
@@ -12,7 +14,15 @@ public final class CubeVoxelShape extends VoxelShape {
 
     @Override
     protected DoubleList getCoords(Direction.Axis axis) {
-        return new CubePointRange(this.shape.getSize(axis));
+        // Gale start - Lithium - cache CubeVoxelShape shape array
+        if (this.list == null) {
+            this.list = new DoubleList[Direction.Axis.VALUES.length];
+            for (Direction.Axis existingAxis : Direction.Axis.VALUES) {
+                this.list[existingAxis.ordinal()] = new CubePointRange(this.shape.getSize(axis));
+            }
+        }
+        return this.list[axis.ordinal()];
+        // Gale end - Lithium - cache CubeVoxelShape shape array
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java b/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java
index 6bd6385ad82481a099f3556ed2dbd3744888fc34..eec2e561eb097be2de18a4f3a23428e3ebe8cc51 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/VoxelShape.java
@@ -362,6 +362,44 @@ public abstract class VoxelShape {
     }
     // Paper end - optimise collisions
 
+    // JettPack start - lithium: block.moving_block_shapes
+    private volatile VoxelShape[] offsetAndSimplified;
+
+    public void setShape(float offset, Direction direction, VoxelShape offsetShape) {
+        if (offsetShape == null) {
+            throw new IllegalArgumentException("offsetShape must not be null!");
+        }
+        int index = getIndexForOffsetSimplifiedShapes(offset, direction);
+        VoxelShape[] offsetAndSimplifiedShapes = this.offsetAndSimplified;
+        if (offsetAndSimplifiedShapes == null) {
+            offsetAndSimplifiedShapes = new VoxelShape[1 + 2 * 6];
+        } else {
+            offsetAndSimplifiedShapes = offsetAndSimplifiedShapes.clone();
+        }
+        offsetAndSimplifiedShapes[index] = offsetShape;
+        this.offsetAndSimplified = offsetAndSimplifiedShapes;
+    }
+
+    public VoxelShape getOffsetSimplifiedShape(float offset, Direction direction) {
+        VoxelShape[] offsetAndSimplified = this.offsetAndSimplified;
+        if (offsetAndSimplified == null) {
+            return null;
+        }
+        int index = getIndexForOffsetSimplifiedShapes(offset, direction);
+        return offsetAndSimplified[index];
+    }
+
+    private static int getIndexForOffsetSimplifiedShapes(float offset, Direction direction) {
+        if (offset != 0f && offset != 0.5f && offset != 1f) {
+            throw new IllegalArgumentException("offset must be one of {0f, 0.5f, 1f}");
+        }
+        if (offset == 0f) {
+            return 0; //can treat offsetting by 0 in all directions the same
+        }
+        return (int) (2 * offset) + 2 * direction.get3DDataValue();
+    }
+    // JettPack end
+
     protected VoxelShape(DiscreteVoxelShape voxels) { // Paper - protected
         this.shape = voxels;
     }
diff --git a/src/test/java/net/minecraft/network/VarIntLongTest.java b/src/test/java/net/minecraft/network/VarIntLongTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..682996bf3802ddd2be78f25944a32235ca86accf
--- /dev/null
+++ b/src/test/java/net/minecraft/network/VarIntLongTest.java
@@ -0,0 +1,159 @@
+// Gale - Velocity - VarInt and VarLong optimizations
+
+package net.minecraft.network;
+
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class VarIntLongTest {
+
+    private static String padStringWithLeadingZeros(String string, int length) {
+        if (string.length() >= length) {
+            return string;
+        }
+        return "0".repeat(length - string.length()) + string;
+    }
+
+    private static final IntSet integerCases;
+    static {
+        integerCases = new IntOpenHashSet();
+        {
+            integerCases.add(0);
+            integerCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 32; i++) {
+                integerCases.add(1 << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                int all = 0;
+                for (int i = 0; i <= 4; i++) {
+                    int shifted = 1 << (i * factor);
+                    all |= shifted;
+                    integerCases.add(shifted);
+                    integerCases.add(shifted - 1);
+                    integerCases.add(~shifted);
+                    integerCases.add(-shifted);
+                    integerCases.add((~shifted) & (0x80000000));
+                    integerCases.add(all);
+                    integerCases.add(all - 1);
+                    integerCases.add(~all);
+                    integerCases.add(-all);
+                    integerCases.add((~all) & (0x80000000));
+                }
+            }
+        }
+        {
+            var newCases = new IntOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    int striped = 0;
+                    for (int i = offset; i < 32; i += shiftSize) {
+                        striped |= 1 << i;
+                    }
+                    final var finalStriped = striped;
+                    integerCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            integerCases.addAll(newCases);
+        }
+    }
+
+    private static final LongSet longCases;
+    static {
+        longCases = new LongOpenHashSet();
+        {
+            longCases.add(0);
+            longCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 64; i++) {
+                longCases.add(1L << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                long all = 0;
+                for (int i = 0; i <= 9; i++) {
+                    long shifted = 1L << (i * factor);
+                    all |= shifted;
+                    longCases.add(shifted);
+                    longCases.add(shifted - 1);
+                    longCases.add(~shifted);
+                    longCases.add(-shifted);
+                    longCases.add((~shifted) & (0x8000000000000000L));
+                    longCases.add(all);
+                    longCases.add(all - 1);
+                    longCases.add(~all);
+                    longCases.add(-all);
+                    longCases.add((~all) & (0x8000000000000000L));
+                }
+            }
+        }
+        {
+            var newCases = new LongOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    long striped = 0;
+                    for (int i = offset; i < 64; i += shiftSize) {
+                        striped |= 1L << i;
+                    }
+                    final var finalStriped = striped;
+                    longCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            longCases.addAll(newCases);
+        }
+    }
+
+    // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+    @Test
+    public void testGetVarIntSizeComparedToOriginal() {
+        integerCases.forEach(value -> {
+            // given
+            int originalSize = VarInt.getByteSizeOriginal(value);
+
+            // when
+            int size = VarInt.getByteSize(value);
+
+            // then
+            Assert.assertEquals("Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(value), 32) + ")", originalSize, size);
+        });
+    }
+
+    @Test
+    public void testGetVarLongSizeComparedToOriginal() {
+        longCases.forEach(value -> {
+            // given
+            int originalSize = VarLong.getByteSizeOriginal(value);
+
+            // when
+            int size = VarLong.getByteSize(value);
+
+            // then
+            Assert.assertEquals("Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Long.toBinaryString(value), 64) + ")", originalSize, size);
+        });
+    }
+    // Gale end - Velocity - pre-compute VarInt and VarLong sizes
+
+}
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 02f4a2a0bfd66a557f5167ac9ccd13ff9f3dd763..de103337386b398dfae000ba84769ed35943d00d 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1037,20 +1037,19 @@ public abstract class LivingEntity extends Entity implements Attackable {
         }
 
         if (entity != null) {
-            ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
             EntityType<?> entitytypes = entity.getType();
 
             // Purpur start
-            if (entitytypes == EntityType.SKELETON && itemstack.is(Items.SKELETON_SKULL)) {
+            if (entitytypes == EntityType.SKELETON && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.SKELETON_SKULL)) { // Canvas - Reduce sensor work
                 d0 *= entity.level().purpurConfig.skeletonHeadVisibilityPercent;
             }
-            else if (entitytypes == EntityType.ZOMBIE && itemstack.is(Items.ZOMBIE_HEAD)) {
+            else if (entitytypes == EntityType.ZOMBIE && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.ZOMBIE_HEAD)) { // Canvas - Reduce sensor work
                 d0 *= entity.level().purpurConfig.zombieHeadVisibilityPercent;
             }
-            else if (entitytypes == EntityType.CREEPER && itemstack.is(Items.CREEPER_HEAD)) {
+            else if (entitytypes == EntityType.CREEPER && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.CREEPER_HEAD)) { // Canvas - Reduce sensor work
                 d0 *= entity.level().purpurConfig.creeperHeadVisibilityPercent;
             }
-            else if ((entitytypes == EntityType.PIGLIN || entitytypes == EntityType.PIGLIN_BRUTE) && itemstack.is(Items.PIGLIN_HEAD)) {
+            else if ((entitytypes == EntityType.PIGLIN || entitytypes == EntityType.PIGLIN_BRUTE) && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.PIGLIN_HEAD)) { // Canvas - Reduce sensor work
                 d0 *= entity.level().purpurConfig.piglinHeadVisibilityPercent;
             }
             // Purpur end
