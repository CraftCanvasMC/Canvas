From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Tue, 30 Apr 2024 20:24:24 -0700
Subject: [PATCH] Multithreaded Explosion


diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index be571b949bf8d3355a25393f96066d6db6b786db..354dd4329a38fae22531d17028e954f7c8dd6d37 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -38,7 +38,7 @@ class PaperEventManager {
     public void callEvent(@NotNull Event event) {
         if (event.isAsynchronous() && this.server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping() && !Thread.currentThread().getName().startsWith("WorldTicker")) { // Canvas - multithreaded world ticking
+        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping() && !Thread.currentThread().getName().startsWith("WorldTicker") && !Thread.currentThread().getName().startsWith("ExplosionWorker")) { // Canvas - multithreaded world ticking // Multithreaded Explosions
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
 
diff --git a/src/main/java/me/dueris/canvas/CanvasConfig.java b/src/main/java/me/dueris/canvas/CanvasConfig.java
index c0f2799dec7fdeaad71502555dbcbaba13638b81..234d4eab036e37a6d843bc095f8529f06eb107cb 100644
--- a/src/main/java/me/dueris/canvas/CanvasConfig.java
+++ b/src/main/java/me/dueris/canvas/CanvasConfig.java
@@ -210,6 +210,7 @@ public class CanvasConfig {
     public static boolean useCanvasOrbOptimizations = false;
     public static double orbMergeSearchInfaltionRadius = 0.8;
     public static int maxEntitiesToReducePathfindingRates = 2;
+    public static int maxTntWorkerThreads = 3;
 
     private static void general(){
         disableFootsteps = getBoolean("disableFootsteps", disableFootsteps);
@@ -253,6 +254,7 @@ public class CanvasConfig {
         fallingBlocksLoadChunks = getBoolean("optimizations.fallingBlocksLoadChunks", fallingBlocksLoadChunks);
         tickItemFrames = getBoolean("optimizations.tickItemFrames", tickItemFrames);
         disableRaidsFromSpawnerRaiders = getBoolean("optimizations.disableRaidsFromSpawnerRaiders", disableRaidsFromSpawnerRaiders);
+        maxTntWorkerThreads = getInt("optimizations.threadripper.maxTntWorkerThreads", maxTntWorkerThreads);
     }
     
     private static void blocks(){
diff --git a/src/main/java/me/dueris/canvas/thread/level/ExplosionWorker.java b/src/main/java/me/dueris/canvas/thread/level/ExplosionWorker.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fef32201afb7250e6eeb3415ba32d7f28fdb4cc
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/level/ExplosionWorker.java
@@ -0,0 +1,21 @@
+package me.dueris.canvas.thread.level;
+
+import me.dueris.canvas.CanvasConfig;
+import me.dueris.canvas.thread.NamedTickThreadFactory;
+import net.minecraft.world.level.Explosion;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+public class ExplosionWorker {
+    private static final ExecutorService service = Executors.newFixedThreadPool(CanvasConfig.maxTntWorkerThreads, new NamedTickThreadFactory("ExplosionWorker"));
+
+    public static Future<Explosion> submitTask(Callable<Explosion> runnable) {
+        return service.submit(runnable);
+    }
+
+    public static void stopWorker() {
+        service.shutdown();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index f28d18307fe059e465875566a132c80aeeef9864..60c7170d5f734b99502139c92ccdcf39f21808e1 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1092,6 +1092,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
         MinecraftServer.worldTickerPool.shutdown(); // Canvas - Multithreaded WorldTicking
+        me.dueris.canvas.thread.level.ExplosionWorker.stopWorker(); // Canvas - Multithreaded Explosions
         LOGGER.info("Closing Server");
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 476a04d87a61b021816d2970e86042bde32d95a2..703d991a162fe42e91194d4c553fcbd06bbc7c4d 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -243,12 +243,19 @@ public class ServerChunkCache extends ChunkSource {
         this.lastChunkStatus[0] = status;
         this.lastChunk[0] = chunk;
     }
+    // Canvas start - im doing rly dumb things now
 
-    @Nullable
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
+        return this.getChunk(x, z, leastStatus, create, true);
+    }
+    // Canvas end
+
+    @Nullable
+    // @Override // Canvas
+    public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create, boolean async) { // Canvas
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
+        if (!io.papermc.paper.util.TickThread.isTickThread() && async) { // Paper - rewrite chunk system
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 675ad6b4ff4dcd58c9503eeb61acb2310d84b2ce..667541d39dc68f01205356f02a18933e32b1972b 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -30,6 +30,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -839,6 +840,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public StructureManager structureManager() {
         return this.structureManager;
     }
+    // Canvas start - end tick tasks
+
+    public ConcurrentLinkedQueue<Runnable> endTickTasks = new ConcurrentLinkedQueue<>();
+    // Canvas end
 
     public Pair<Runnable, ServerLevel> tick(BooleanSupplier shouldKeepTicking, int tickCount) { // Canvas - Multithreaded WorldTicking
         // Canvas start - Multithreaded WorldTicking
@@ -996,6 +1001,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             this.getChunkSource().tick(shouldKeepTicking, true);
             this.explosionDensityCache.clear();
+            new ArrayList<>(this.endTickTasks).forEach((r) -> {
+                r.run();
+                endTickTasks.remove(r);
+            });
             // Canvas end
         }, this); // Canvas
     }
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index 133d994d9ac9d4f9527135ac0c77e5749917f8c3..75aed8729be95518dbe059708667ab6201552df5 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -11,6 +11,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -197,7 +198,7 @@ public class Explosion {
                 chunk = this.chunkCache[chunkCacheKey];
             } else {
                 this.chunkPosCache[chunkCacheKey] = chunkKey;
-                this.chunkCache[chunkCacheKey] = chunk = this.level.getChunk(x >> 4, z >> 4);
+                this.chunkCache[chunkCacheKey] = chunk = this.level.getChunk(x >> 4, z >> 4, false);
             }
 
             BlockState blockState = chunk.getBlockStateFinal(x, y, z);
@@ -423,11 +424,17 @@ public class Explosion {
     public Vec3 center() {
         return new Vec3(this.x, this.y, this.z);
     }
+    // Canvas start
 
     public void explode() {
+        this.runExplode();
+    }
+    // Canvas end
+
+    public Explosion runExplode() { // Canvas
         // CraftBukkit start
         if ((this.level == null || this.level.purpurConfig.explosionClampRadius) && this.radius < 0.1F) { // Purpur
-            return;
+            return this; // Canvas
         }
         // CraftBukkit end
 
@@ -436,7 +443,7 @@ public class Explosion {
             Location location = new Location(this.level.getWorld(), this.x, this.y, this.z);
             if(!new org.purpurmc.purpur.event.entity.PreEntityExplodeEvent(this.source.getBukkitEntity(), location, this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F).callEvent()) {
                 this.wasCanceled = true;
-                return;
+                return this; // Canvas
             }
         }else {
             Location location = new Location(this.level.getWorld(), this.x, this.y, this.z);
@@ -444,7 +451,7 @@ public class Explosion {
             org.bukkit.block.BlockState blockState = (this.damageSource.getDirectBlockState() != null) ? this.damageSource.getDirectBlockState() : block.getState();
             if(!new org.purpurmc.purpur.event.PreBlockExplodeEvent(location.getBlock(), this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, blockState).callEvent()) {
                 this.wasCanceled = true;
-                return;
+                return this; // Canvas
             }
         }
         //Purpur end
@@ -530,7 +537,7 @@ public class Explosion {
 
                             f -= cachedBlock.resistance; // Paper - optimise explosions
 
-                            if (f > 0.0F && cachedBlock.shouldExplode == null) { // Paper - optimise explosions
+                            if (f > 0.0F || cachedBlock.shouldExplode == null) { // Paper - optimise explosions
                                 // Paper start - optimise explosions
                                 // note: we expect shouldBlockExplode to be pure with respect to power, as Vanilla currently is.
                                 // basically, it is unused, which allows us to cache the result
@@ -575,6 +582,10 @@ public class Explosion {
 
         final BlockPos.MutableBlockPos blockPos = new BlockPos.MutableBlockPos(); // Paper - optimise explosions
 
+        // Canvas start
+        ExplosionBlockCache[] cacheSave = blockCache.clone();
+        ((net.minecraft.server.level.ServerLevel) this.level).endTickTasks.add(() -> {
+        // Canvas end
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
@@ -614,7 +625,7 @@ public class Explosion {
                                     }
                                 }
                             } else {
-                                entity.hurt(this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity, getSeenFraction(vec3d, entity, blockCache, blockPos))); // Paper - actually optimise explosions
+                                entity.hurt(this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity, getSeenFraction(vec3d, entity, cacheSave, blockPos))); // Paper - actually optimise explosions
                             }
 
                             if (entity.lastDamageCancelled) { // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Skip entity if damage event was cancelled
@@ -674,13 +685,26 @@ public class Explosion {
                 }
             }
         }
-
-        this.blockCache = null; // Paper - optimise explosions
+        // Canvas start
+        this.blockCache = null;
+        this.chunkPosCache = null;
+        this.chunkCache = null;
+        // Canvas end
+
+        }); // Canvas
+        /* this.blockCache = null; // Paper - optimise explosions // Canvas
         this.chunkPosCache = null; // Paper - optimise explosions
-        this.chunkCache = null; // Paper - optimise explosions
+        this.chunkCache = null; // Paper - optimise explosions */ // Canvas
+        return this; // Canvas
     }
+    // Canvas start
 
     public void finalizeExplosion(boolean particles) {
+        this.wrapExplosion(particles);
+    }
+    // Canvas end
+
+    public Explosion wrapExplosion(boolean particles) { // Canvas
         if (this.level.isClientSide) {
             this.level.playLocalSound(this.x, this.y, this.z, (SoundEvent) this.explosionSound.value(), SoundSource.BLOCKS, 4.0F, (1.0F + (this.level.random.nextFloat() - this.level.random.nextFloat()) * 0.2F) * 0.7F, false);
         }
@@ -745,7 +769,7 @@ public class Explosion {
             }
 
             if (this.wasCanceled) {
-                return;
+                return this; // Canvas
             }
             // CraftBukkit end
             objectlistiterator = this.toBlow.iterator();
@@ -797,6 +821,7 @@ public class Explosion {
             }
         }
 
+        return this; // Canvas
     }
 
     private static void addOrAppendStack(List<Pair<ItemStack, BlockPos>> stacks, ItemStack stack, BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index d8a7d3d5ea34abae126e3521936f00a7987e3bd5..0bfc0801fad951bbdee03f433b727dedef9e990c 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -6,6 +6,8 @@ import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.ExecutionException;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -28,6 +30,7 @@ import net.minecraft.resources.ResourceLocation;
 import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -862,8 +865,15 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return this.getChunk(SectionPos.blockToSectionCoord(pos.getX()), SectionPos.blockToSectionCoord(pos.getZ()));
     }
 
+    // Canvas start
     @Override
-    public final LevelChunk getChunk(int chunkX, int chunkZ) { // Paper - final to help inline
+    public final LevelChunk getChunk(int chunkX, int chunkZ) {
+        return getChunk(chunkX, chunkZ, true);
+    }
+
+    // Canvas end
+    // @Override // Canvas
+    public final LevelChunk getChunk(int chunkX, int chunkZ, boolean async) { // Paper - final to help inline // Canvas
         // Paper start - Perf: make sure loaded chunks get the inlined variant of this function
         net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel)this).getChunkSource();
         if (cps.mainThread == Thread.currentThread()) {
@@ -873,7 +883,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             }
         }
         // Paper end - Perf: make sure loaded chunks get the inlined variant of this function
-        return (LevelChunk) this.getChunk(chunkX, chunkZ, ChunkStatus.FULL, true); // Paper - avoid a method jump
+        return (LevelChunk) this.getChunk(chunkX, chunkZ, ChunkStatus.FULL, true, async); // Paper - avoid a method jump // Canvas
     }
 
     // Paper start - if loaded
@@ -930,11 +940,26 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public final @Nullable BlockState getBlockStateIfLoadedAndInBounds(BlockPos blockposition) {
         return getWorldBorder().isWithinBounds(blockposition) ? getBlockStateIfLoaded(blockposition) : null;
     }
+    // Canvas start
 
     @Override
-    public final ChunkAccess getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) { // Paper - final for inline
+    public final ChunkAccess getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
+        return getChunk(chunkX, chunkZ, leastStatus, create, true);
+    }
+    // Canvas end
+
+    // @Override // Canvas
+    public final ChunkAccess getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean async) { // Paper - final for inline // Canvas
         // Paper end
-        ChunkAccess ichunkaccess = this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, create);
+        // Canvas start
+        ChunkAccess ichunkaccess;
+        if (this.getChunkSource() instanceof ServerChunkCache sCC) {
+            ichunkaccess = sCC.getChunk(chunkX, chunkZ, leastStatus, create, async);
+        } else {
+            ichunkaccess = this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, create);
+        }
+        // ChunkAccess ichunkaccess = this.getChunkSource().getChunk(chunkX, chunkZ, leastStatus, create);
+        // Canvas end
 
         if (ichunkaccess == null && create) {
             throw new IllegalStateException("Should always be able to create a chunk!");
@@ -1443,11 +1468,25 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
 
         Explosion.BlockInteraction explosion_effect1 = explosion_effect;
+        // Canvas start
+        java.util.Optional<Explosion> opExpl;
         Explosion explosion = new Explosion(this, entity, damageSource, behavior, x, y, z, power, createFire, explosion_effect1, particle, emitterParticle, soundEvent);
+        if (me.dueris.canvas.CanvasConfig.threadripper) {
+            try {
+                opExpl = Optional.of(me.dueris.canvas.thread.level.ExplosionWorker.submitTask(explosion::runExplode).get());
+            } catch (InterruptedException | ExecutionException e) {
+                throw new RuntimeException("An error occurred when creating an explosion!", e);
+            }
+        } else {
+        // Explosion explosion = new Explosion(this, entity, damageSource, behavior, x, y, z, power, createFire, explosion_effect1, particle, emitterParticle, soundEvent); // Move up
+        // Canvas end
 
-        explosion.explode();
-        explosion.finalizeExplosion(particles);
-        return explosion;
+        opExpl = java.util.Optional.of(explosion.runExplode()); // Canvas
+        // explosion.finalizeExplosion(particles); // Canvas
+        // Canvas start
+        }
+        return opExpl.orElse(null).wrapExplosion(particles);
+        // Canvas end
     }
 
     private Explosion.BlockInteraction getDestroyType(GameRules.Key<GameRules.BooleanValue> gameRuleKey) {
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index e650b85464ac886b4adb1a8924026d34f805aba6..762a4166af0fda9fc31310d670ff9a3a45f70e2d 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -2080,14 +2080,20 @@ public class CraftEventFactory {
         return event;
     }
 
+    // Canvas start
+
     public static EntityKnockbackEvent callEntityKnockbackEvent(CraftLivingEntity entity, Entity attacker, EntityKnockbackEvent.KnockbackCause cause, double force, Vec3 raw, double x, double y, double z) {
+        return callEntityKnockbackEvent(entity, attacker, cause, force, raw, x, y, z, false);
+    }
+    // Canvas end
+    public static EntityKnockbackEvent callEntityKnockbackEvent(CraftLivingEntity entity, Entity attacker, EntityKnockbackEvent.KnockbackCause cause, double force, Vec3 raw, double x, double y, double z, boolean async) { // Canvas
         Vector bukkitRaw = new Vector(-raw.x, raw.y, -raw.z); // Due to how the knockback calculation works, we need to invert x and z.
 
         EntityKnockbackEvent event;
         if (attacker != null) {
-            event = new EntityKnockbackByEntityEvent(entity, attacker.getBukkitEntity(), cause, force, new Vector(-raw.x, raw.y, -raw.z), new Vector(x, y, z));
+            event = new EntityKnockbackByEntityEvent(entity, attacker.getBukkitEntity(), cause, force, new Vector(-raw.x, raw.y, -raw.z), new Vector(x, y, z), async); // Canvas
         } else {
-            event = new EntityKnockbackEvent(entity, cause, force, new Vector(-raw.x, raw.y, -raw.z), new Vector(x, y, z));
+            event = new EntityKnockbackEvent(entity, cause, force, new Vector(-raw.x, raw.y, -raw.z), new Vector(x, y, z), async); // Canvas
         }
 
         Bukkit.getPluginManager().callEvent(event);
