From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Tue, 30 Apr 2024 20:38:29 -0700
Subject: [PATCH] Better TickTask Scheduler


diff --git a/src/main/java/me/dueris/canvas/thread/ScheduledTask.java b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cc5415c50c9c6aaf143a8a29c6e4ae0ea58bff3
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
@@ -0,0 +1,25 @@
+package me.dueris.canvas.thread;
+
+public class ScheduledTask {
+    Runnable runnable;
+    boolean onMain;
+    TickTaskHolder.Timing timing;
+    
+    public ScheduledTask(Runnable runnable, boolean onMain, TickTaskHolder.Timing timing) {
+        this.runnable = runnable;
+        this.onMain = onMain;
+        this.timing = timing;
+    }
+
+    public boolean canRun(TickTaskHolder.Timing timing) {
+        return this.timing == timing;
+    }
+
+    public boolean serverLevel() {
+        return !this.onMain;
+    }
+
+    public void run() {
+        this.runnable.run();
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ea37ab9d3df91bb7e3fca28f13134b9e9137083
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
@@ -0,0 +1,15 @@
+package me.dueris.canvas.thread;
+
+import me.dueris.canvas.thread.TickTaskHolder.*;
+
+public interface TickTaskHolder {
+    public void scheduleTask(Runnable runnable, Timing timing, State state);
+
+    public static enum Timing {
+        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY;
+    }
+
+    public static enum State {
+        SERVER_LEVEL, MAIN;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 60c7170d5f734b99502139c92ccdcf39f21808e1..161e5daba242f7b2daffd0c855708d3af2aaec72 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1914,6 +1914,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } catch (InterruptedException | ExecutionException e) {
             e.printStackTrace();
         }
+        // Run scheduled main thread tasks now
+        getAllLevels().forEach(Level::runMainThreadTasks);
         // Canvas end
 
         //this.profiler.popPush("connection"); // Purpur
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 846e9a4a3f46471fa59ce4fc5fb9cc42cb026eb7..7803f242e50ba3088f767a65be64767291613032 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -839,16 +839,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public StructureManager structureManager() {
         return this.structureManager;
     }
-    // Canvas start - end tick tasks
-
-    public ConcurrentLinkedQueue<Runnable> endTickTasks = new ConcurrentLinkedQueue<>();
-    // Canvas end
 
     public Pair<Runnable, ServerLevel> tick(BooleanSupplier shouldKeepTicking, int tickCount) { // Canvas - Multithreaded WorldTicking
         // Canvas start - Multithreaded WorldTicking
         return new Pair<Runnable, ServerLevel>(() -> {
         this.handlingTick = true;
             if(this.currentTickingThread != Thread.currentThread()) {this.currentTickingThread = Thread.currentThread();}
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_TICK); // Canvas
             //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
             // Moved from MinecraftSever
                 final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
@@ -959,6 +956,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_ENTITY); // Canvas
             this.entityTickList.forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
@@ -986,6 +984,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     }
                 }
             });
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.POST_ENTITY); // Canvas
             //this.timings.entityTick.stopTiming(); // Spigot // Purpur
             //this.timings.tickEntities.stopTiming(); // Spigot // Purpur
             //gameprofilerfiller.pop(); // Purpur
@@ -1000,10 +999,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             this.getChunkSource().tick(shouldKeepTicking, true);
             this.explosionDensityCache.clear();
-            new ArrayList<>(this.endTickTasks).forEach((r) -> {
+            /* new ArrayList<>(this.endTickTasks).forEach((r) -> { // Canvas - Use new tick timing system
                 r.run();
                 endTickTasks.remove(r);
-            });
+            }); */ // Canvas - Use new tick timing system
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.END_TICK); // Canvas
             // Canvas end
         }, this); // Canvas
     }
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index 75aed8729be95518dbe059708667ab6201552df5..d270696172d038e031d4f0389947a8fb8ac3d3e0 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -584,7 +584,8 @@ public class Explosion {
 
         // Canvas start
         ExplosionBlockCache[] cacheSave = blockCache.clone();
-        ((net.minecraft.server.level.ServerLevel) this.level).endTickTasks.add(() -> {
+        this.level.scheduleTask(() -> {
+        // ((net.minecraft.server.level.ServerLevel) this.level).endTickTasks.add(() -> { // Canvas - Use new tick timing system
         // Canvas end
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
@@ -691,7 +692,7 @@ public class Explosion {
         this.chunkCache = null;
         // Canvas end
 
-        }); // Canvas
+        }, me.dueris.canvas.thread.TickTaskHolder.Timing.POST_ENTITY, me.dueris.canvas.thread.TickTaskHolder.State.SERVER_LEVEL); // Canvas
         /* this.blockCache = null; // Paper - optimise explosions // Canvas
         this.chunkPosCache = null; // Paper - optimise explosions
         this.chunkCache = null; // Paper - optimise explosions */ // Canvas
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0bfc0801fad951bbdee03f433b727dedef9e990c..26e4fb9c183b6c415c68c533dc598bee17701353 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -28,6 +28,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import io.papermc.paper.util.MCUtil;
+import me.dueris.canvas.thread.ScheduledTask;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerChunkCache;
@@ -104,7 +105,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level implements LevelAccessor, AutoCloseable, me.dueris.canvas.thread.TickTaskHolder { // Canvas
 
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
@@ -144,6 +145,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public java.util.concurrent.LinkedBlockingQueue<me.dueris.canvas.thread.ScheduledTask> scheduledTasks = new java.util.concurrent.LinkedBlockingQueue<>();
 
     // CraftBukkit start Added the following
     private final CraftWorld world;
@@ -241,6 +243,44 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public CraftServer getCraftServer() {
         return (CraftServer) Bukkit.getServer();
     }
+    // Canvas start - scheduler tasks
+
+    @Override
+    public void scheduleTask(Runnable runnable, Timing timing, State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(State.MAIN), timing));
+    }
+
+    public void runAllScheduledTasks() {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(ScheduledTask::serverLevel).forEach((task) -> {
+            // We ignore timings because we are executing all remaining tasks that should be executed on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public void runAllWithTiming(Timing timing) {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(s -> s.canRun(timing)).forEach((task) -> {
+            // Run the task on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public void runMainThreadTasks() {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(s -> !s.serverLevel()).forEach((task) -> {
+            // Run the task on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public ScheduledTask[] getMainThreadTasks() {
+        return (ScheduledTask[]) this.scheduledTasks.stream().filter(s -> !s.serverLevel()).toArray().clone();
+    }
+    // Canvas end
 
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
