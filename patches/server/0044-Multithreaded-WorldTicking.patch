From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PurpleWolfMC <jedimastertoothless@hotmail.com>
Date: Fri, 24 May 2024 18:18:35 -0700
Subject: [PATCH] Multithreaded WorldTicking


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java
index b71404be2c82f7db35272b367af861e94d6c73d3..8eb53a8bbd26d2b8ba0a1fcf0982fcccbc95be67 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadedTaskQueue.java
@@ -1,13 +1,14 @@
 package ca.spottedleaf.concurrentutil.executor.standard;
 
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.atomic.AtomicLong;
 
 public class PrioritisedThreadedTaskQueue implements PrioritisedExecutor {
 
-    protected final ArrayDeque<PrioritisedTask>[] queues = new ArrayDeque[Priority.TOTAL_SCHEDULABLE_PRIORITIES]; {
+    protected final ConcurrentLinkedDeque<PrioritisedTask>[] queues = new ConcurrentLinkedDeque[Priority.TOTAL_SCHEDULABLE_PRIORITIES]; { // Canvas
         for (int i = 0; i < Priority.TOTAL_SCHEDULABLE_PRIORITIES; ++i) {
-            this.queues[i] = new ArrayDeque<>();
+            this.queues[i] = new ConcurrentLinkedDeque<>(); // Canvas
         }
     }
 
@@ -88,11 +89,11 @@ public class PrioritisedThreadedTaskQueue implements PrioritisedExecutor {
     }
 
     protected PrioritisedTask poll(final PrioritisedExecutor.Priority minPriority) {
-        final ArrayDeque<PrioritisedTask>[] queues = this.queues;
+        final ConcurrentLinkedDeque<PrioritisedTask>[] queues = this.queues; // CanvaS
         synchronized (queues) {
             final int max = minPriority.priority;
             for (int i = 0; i <= max; ++i) {
-                final ArrayDeque<PrioritisedTask> queue = queues[i];
+                final ConcurrentLinkedDeque<PrioritisedTask> queue = queues[i]; // Canvas
                 PrioritisedTask task;
                 while ((task = queue.pollFirst()) != null) {
                     if (task.trySetCompleting(i)) {
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index 8932968b6c071b0d85ef34d1f562a7b42eb1156e..4c7212d166ee436368a4327467ccedf84a7cf003 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -2,6 +2,8 @@ package com.destroystokyo.paper.util.maplist;
 
 import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
 import net.minecraft.world.entity.Entity;
+
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -85,7 +87,7 @@ public final class EntityList implements Iterable<Entity> {
         // Canvas start
         // return this.entities[index];
         int i = 0;
-        for (Entity element : this.handle) {
+        for (Entity element : new ArrayList<>(this.handle)) { // Canvas
             if (i == index) {
                 return element;
             }
@@ -98,12 +100,7 @@ public final class EntityList implements Iterable<Entity> {
     public Entity[] getRawData() {
         // Canvas start
         // return this.entities;
-        Entity[] entityArray = new Entity[this.size()];
-        int i = 0;
-        for (Entity entity : this.handle) {
-            entityArray[i++] = entity;
-        }
-        return entityArray;
+        return this.handle.toArray(new Entity[0]); // Canvas
         // Canvas end
     }
 
diff --git a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
index a5f706d6f716b2a463ae58adcde69d9e665c7733..3a74bde3857b34afeb7e4c18c0e2ccf877615a11 100644
--- a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
+++ b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
@@ -212,21 +212,19 @@ public final class SingleThreadChunkRegionManager {
         region.dead = true;
 
         // destroy region state
-        for (final Iterator<RegionSection> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
-            final RegionSection aliveSection = iterator.next();
+        for (final RegionSection aliveSection : region.sections) { // Canvas
             if (!aliveSection.hasChunks()) {
                 throw new IllegalStateException("Alive section '" + aliveSection.toStringWithRegion() + "' has no chunks!");
             }
             if (!this.regionsBySection.remove(aliveSection.regionCoordinate, aliveSection)) {
                 throw new IllegalStateException("Cannot remove alive section '" +
-                        aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
-                        this.regionsBySection.get(aliveSection.regionCoordinate));
+                    aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " + // Canvas
+                    this.regionsBySection.get(aliveSection.regionCoordinate)); // Canvas
             }
         }
 
         // rebuild regions
-        for (final Iterator<RegionSection> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
-            final RegionSection aliveSection = iterator.next();
+        for (final RegionSection aliveSection : region.sections) { // Canvas
             this.getOrCreateAndMergeSection(aliveSection.getSectionX(), aliveSection.getSectionZ(), aliveSection);
         }
     }
@@ -245,10 +243,6 @@ public final class SingleThreadChunkRegionManager {
             this.regionData = regionManager.regionDataSupplier.get();
         }
 
-        public IteratorSafeOrderedReferenceSet.Iterator<RegionSection> getSections() {
-            return this.sections.iterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
-        }
-
         protected final double getDeadSectionPercent() {
             return (double)this.deadSections.size() / (double)this.sections.size();
         }
@@ -307,9 +301,7 @@ public final class SingleThreadChunkRegionManager {
                 this.regionManager.removeFromRecalcQueue(this);
             }
 
-            for (final Iterator<RegionSection> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
-                final RegionSection section = iterator.next();
-
+            for (final RegionSection section : this.sections) { // Canvas
                 if (!mergeTarget.addRegionSection(section)) {
                     throw new IllegalStateException("Target cannot contain source's sections! Source " + this + ", target " + mergeTarget);
                 }
@@ -350,7 +342,7 @@ public final class SingleThreadChunkRegionManager {
 
             ret.append("sectionCount=").append(this.sections.size()).append(',');
             ret.append("sections=[");
-            for (final Iterator<RegionSection> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+            for (final Iterator<RegionSection> iterator = this.sections.iterator(); iterator.hasNext();) { // Canvas
                 final RegionSection section = iterator.next();
                 ret.append(section);
                 if (iterator.hasNext()) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
index 149cfb0587299f72fcfddf395fb71b70438986c1..15af27651034f7b9880142dbdf9a0bc3b847bc34 100644
--- a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
@@ -15,6 +15,7 @@ import it.unimi.dsi.fastutil.longs.LongHeapPriorityQueue;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import me.dueris.canvas.thread.TickTaskHolder;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
@@ -33,9 +34,9 @@ import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.lang.invoke.VarHandle;
-import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Objects;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -312,6 +313,7 @@ public class RegionizedPlayerChunkLoader {
 
     public void tick() {
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
+        // world.scheduleTickTask(() -> { // Canvas
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
             final PlayerChunkLoaderData loader = player.chunkLoader;
@@ -322,6 +324,7 @@ public class RegionizedPlayerChunkLoader {
             loader.update(); // can't invoke plugin logic
             loader.updateQueues(currTime);
         }
+        // }, TickTaskHolder.Timing.END_TICK, TickTaskHolder.State.SERVER_LEVEL); // Canvas
     }
 
     public static final class PlayerChunkLoaderData {
@@ -350,7 +353,7 @@ public class RegionizedPlayerChunkLoader {
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas
         private final LongOpenHashSet sentChunks = new LongOpenHashSet();
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 15ee41452992714108efe53b708b5a4e1da7c1ff..444171645a8ef81be0bcf8563398c354c1b5b138 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -35,6 +35,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -191,12 +192,22 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public Iterable<Entity> getAll() {
-        return new ArrayIterable<>(this.accessibleEntities.getRawData(), 0, this.accessibleEntities.size());
+        // Canvas start
+        return this.accessibleEntities;
+        // Canvas end
     }
 
     public Entity[] getAllCopy() {
-        return Arrays.copyOf(this.accessibleEntities.getRawData(), this.accessibleEntities.size(), Entity[].class);
+        // Canvas start
+        return this.accessibleEntities.getRawData().clone();
+        // Canvas end
     }
+    // Canvas start
+
+    public int entityCount() {
+        return this.accessibleEntities.size();
+    }
+    // Canvas end
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AbortableIterationConsumer<U> action) {
@@ -240,6 +251,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             }
         }
     }
+    private ConcurrentLinkedQueue<Runnable> statusChangesQue = new ConcurrentLinkedQueue<>(); // Canvas
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
@@ -254,7 +266,8 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
 
         if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            // LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable()); // Canvas
+            statusChangesQue.add(() -> entityStatusChange(entity, slices, oldVisibility, newVisibility, moved, created, destroyed)); // Canvas
             return;
         }
 
@@ -312,6 +325,11 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         } finally {
             if (slices != null) {
                 slices.stopPreventingStatusUpdates(false);
+                // Canvas start
+                ConcurrentLinkedQueue<Runnable> clone = new ConcurrentLinkedQueue<>(statusChangesQue);
+                statusChangesQue.clear();
+                clone.forEach(Runnable::run);
+                // Canvas end
             }
         }
     }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index e1ffd62f4ebceecb9bc5471df3da406cffea0483..889ddb1d6dd83b3b37498eeb64dae5bdc4dca47c 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -46,6 +46,7 @@ import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
@@ -112,7 +113,7 @@ public final class ChunkHolderManager {
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas
     private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
         if (c1 == c2) {
             return 0;
@@ -1026,7 +1027,7 @@ public final class ChunkHolderManager {
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1034,7 +1035,7 @@ public final class ChunkHolderManager {
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, PrioritisedExecutor.Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1372,7 +1373,7 @@ public final class ChunkHolderManager {
 
     // only call on tick thread
     protected final boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index 049e20407033073b06fcdeb46c38485f4926d778..71e79ac5e87277de3793d5ddd55bad8318e32338 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -11,6 +11,7 @@ import io.papermc.paper.chunk.system.scheduling.queue.RadiusAwarePrioritisedExec
 import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.function.BooleanSupplier;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -820,7 +821,7 @@ public final class ChunkTaskScheduler {
         return true;
     }
 
-    public static final ArrayDeque<ChunkInfo> WAITING_CHUNKS = new ArrayDeque<>(); // stack
+    public static final LinkedBlockingDeque<ChunkInfo> WAITING_CHUNKS = new LinkedBlockingDeque<>(); // stack // Canvas
 
     public static final class ChunkInfo {
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ThreadedTicketLevelPropagator.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ThreadedTicketLevelPropagator.java
index 287240ed3b440f2f5733c368416e4276f626405d..3f96bae4530022b05d5d2f12c80fe80737226507 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ThreadedTicketLevelPropagator.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ThreadedTicketLevelPropagator.java
@@ -14,6 +14,7 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.locks.LockSupport;
 
 public abstract class ThreadedTicketLevelPropagator {
@@ -717,7 +718,7 @@ public abstract class ThreadedTicketLevelPropagator {
 
     private static final class Propagator {
 
-        private static final ArrayDeque<Propagator> CACHED_PROPAGATORS = new ArrayDeque<>();
+        private static final ConcurrentLinkedDeque<Propagator> CACHED_PROPAGATORS = new ConcurrentLinkedDeque<>(); // Canvas
         private static final int MAX_PROPAGATORS = Runtime.getRuntime().availableProcessors() * 2;
 
         private static Propagator acquirePropagator() {
diff --git a/src/main/java/io/papermc/paper/command/MSPTCommand.java b/src/main/java/io/papermc/paper/command/MSPTCommand.java
index 8b5293b0c696ef21d0101493ffa41b60bf0bc86b..945f827e061d03b78948ea78a029c489017085a9 100644
--- a/src/main/java/io/papermc/paper/command/MSPTCommand.java
+++ b/src/main/java/io/papermc/paper/command/MSPTCommand.java
@@ -81,7 +81,7 @@ public final class MSPTCommand extends Command {
         return true;
     }
 
-    private static List<Component> eval(long[] times) {
+    public static List<Component> eval(long[] times) { // Canvas - private -> public
         long min = Integer.MAX_VALUE;
         long max = 0L;
         long total = 0L;
@@ -96,7 +96,7 @@ public final class MSPTCommand extends Command {
         return Arrays.asList(getColor(avgD), getColor(minD), getColor(maxD));
     }
 
-    private static Component getColor(double avg) {
+    public static Component getColor(double avg) { // Canvas - private -> public
         return text(DF.format(avg), avg >= 50 ? RED : avg >= 40 ? YELLOW : GREEN);
     }
 }
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
index 5e5a018433414af76eaa1e781f61612ddc305b07..c6fdcd4ac494925c76d87b2c27269ea39ed55bf4 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
@@ -103,6 +103,7 @@ public final class EntityCommand implements PaperSubcommand {
             Map<ResourceLocation, Integer> nonEntityTicking = Maps.newHashMap();
             ServerChunkCache chunkProviderServer = world.getChunkSource();
             world.getAllEntities().forEach(e -> {
+                if (e == null) return; // Canvas
                 ResourceLocation key = EntityType.getKey(e.getType());
 
                 MutablePair<Integer, Map<ChunkPos, Integer>> info = list.computeIfAbsent(key, k -> MutablePair.of(0, Maps.newHashMap()));
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 7ce9ebba8ce304d1f3f21d4f15ee5f3560d7700b..be571b949bf8d3355a25393f96066d6db6b786db 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -38,7 +38,7 @@ class PaperEventManager {
     public void callEvent(@NotNull Event event) {
         if (event.isAsynchronous() && this.server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
+        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping() && !Thread.currentThread().getName().startsWith("WorldTicker")) { // Canvas - multithreaded world ticking
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index 62484ebf4550b05182f693a3180bbac5d5fd906d..566609789ab52b891f00de31d5645865e540819e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -9,6 +9,7 @@ import org.bukkit.craftbukkit.entity.CraftEntity;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.Consumer;
 
 /**
@@ -44,7 +45,7 @@ public final class EntityScheduler {
     private final Object stateLock = new Object();
     private final Long2ObjectOpenHashMap<List<ScheduledTask>> oneTimeDelayed = new Long2ObjectOpenHashMap<>();
 
-    private final ArrayDeque<ScheduledTask> currentlyExecuting = new ArrayDeque<>();
+    private final ConcurrentLinkedDeque<ScheduledTask> currentlyExecuting = new ConcurrentLinkedDeque<>(); // Canvas
 
     public EntityScheduler(final CraftEntity entity) {
         this.entity = Validate.notNull(entity);
diff --git a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
index 0fd814f1d65c111266a2b20f86561839a4cef755..dcdd54d516dea6b3d29daa5832e2c90ba430f7dd 100644
--- a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -1,334 +1,81 @@
 package io.papermc.paper.util.maplist;
 
-import it.unimi.dsi.fastutil.objects.Reference2IntLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.objects.Reference2IntMap;
-import org.bukkit.Bukkit;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
-public final class IteratorSafeOrderedReferenceSet<E> {
-
-    public static final int ITERATOR_FLAG_SEE_ADDITIONS = 1 << 0;
-
-    protected final Reference2IntLinkedOpenHashMap<E> indexMap;
-    protected int firstInvalidIndex = -1;
-
-    /* list impl */
-    protected E[] listElements;
-    protected int listSize;
-
-    protected final double maxFragFactor;
-
-    protected int iteratorCount;
-
-    private final boolean threadRestricted;
+public class IteratorSafeOrderedReferenceSet<T> implements Iterable<T> {
+    private final Set<WeakReference<T>> set;
 
     public IteratorSafeOrderedReferenceSet() {
-        this(16, 0.75f, 16, 0.2);
+        this.set = new CopyOnWriteArraySet<>();
     }
 
-    public IteratorSafeOrderedReferenceSet(final boolean threadRestricted) {
-        this(16, 0.75f, 16, 0.2, threadRestricted);
-    }
-
-    public IteratorSafeOrderedReferenceSet(final int setCapacity, final float setLoadFactor, final int arrayCapacity,
-                                           final double maxFragFactor) {
-        this(setCapacity, setLoadFactor, arrayCapacity, maxFragFactor, false);
-    }
-    public IteratorSafeOrderedReferenceSet(final int setCapacity, final float setLoadFactor, final int arrayCapacity,
-                                           final double maxFragFactor, final boolean threadRestricted) {
-        this.indexMap = new Reference2IntLinkedOpenHashMap<>(setCapacity, setLoadFactor);
-        this.indexMap.defaultReturnValue(-1);
-        this.maxFragFactor = maxFragFactor;
-        this.listElements = (E[])new Object[arrayCapacity];
-        this.threadRestricted = threadRestricted;
-    }
-
-    /*
-    public void check() {
-        int iterated = 0;
-        ReferenceOpenHashSet<E> check = new ReferenceOpenHashSet<>();
-        if (this.listElements != null) {
-            for (int i = 0; i < this.listSize; ++i) {
-                Object obj = this.listElements[i];
-                if (obj != null) {
-                    iterated++;
-                    if (!check.add((E)obj)) {
-                        throw new IllegalStateException("contains duplicate");
-                    }
-                    if (!this.contains((E)obj)) {
-                        throw new IllegalStateException("desync");
-                    }
-                }
-            }
-        }
-
-        if (iterated != this.size()) {
-            throw new IllegalStateException("Size is mismatched! Got " + iterated + ", expected " + this.size());
-        }
-
-        check.clear();
-        iterated = 0;
-        for (final java.util.Iterator<E> iterator = this.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
-            final E element = iterator.next();
-            iterated++;
-            if (!check.add(element)) {
-                throw new IllegalStateException("contains duplicate (iterator is wrong)");
-            }
-            if (!this.contains(element)) {
-                throw new IllegalStateException("desync (iterator is wrong)");
-            }
-        }
-
-        if (iterated != this.size()) {
-            throw new IllegalStateException("Size is mismatched! (iterator is wrong) Got " + iterated + ", expected " + this.size());
+    public synchronized boolean add(T element) {
+        if (element == null) {
+            throw new NullPointerException("Element cannot be null");
         }
-    }
-    */
-
-    protected final boolean allowSafeIteration() {
-        return !this.threadRestricted || Bukkit.isPrimaryThread();
-    }
-
-    protected final double getFragFactor() {
-        return 1.0 - ((double)this.indexMap.size() / (double)this.listSize);
+        cleanUp();
+        return set.add(new WeakReference<>(element));
     }
 
-    public int createRawIterator() {
-        if (this.allowSafeIteration()) {
-            ++this.iteratorCount;
+    public synchronized boolean remove(T element) {
+        if (element == null) {
+            throw new NullPointerException("Element cannot be null");
         }
-        if (this.indexMap.isEmpty()) {
-            return -1;
-        } else {
-            return this.firstInvalidIndex == 0 ? this.indexMap.getInt(this.indexMap.firstKey()) : 0;
-        }
-    }
-
-    public int advanceRawIterator(final int index) {
-        final E[] elements = this.listElements;
-        int ret = index + 1;
-        for (int len = this.listSize; ret < len; ++ret) {
-            if (elements[ret] != null) {
-                return ret;
+        cleanUp();
+        for (WeakReference<T> ref : set) {
+            T obj = ref.get();
+            if (obj != null && obj.equals(element)) {
+                return set.remove(ref);
             }
         }
-
-        return -1;
+        return false;
     }
 
-    public void finishRawIterator() {
-        if (this.allowSafeIteration() && --this.iteratorCount == 0) {
-            if (this.getFragFactor() >= this.maxFragFactor) {
-                this.defrag();
-            }
+    public synchronized boolean contains(T element) {
+        if (element == null) {
+            throw new NullPointerException("Element cannot be null");
         }
-    }
-
-    public boolean remove(final E element) {
-        final int index = this.indexMap.removeInt(element);
-        if (index >= 0) {
-            if (this.firstInvalidIndex < 0 || index < this.firstInvalidIndex) {
-                this.firstInvalidIndex = index;
-            }
-            if (this.listElements[index] != element) {
-                throw new IllegalStateException();
-            }
-            this.listElements[index] = null;
-            if (this.allowSafeIteration() && this.iteratorCount == 0 && this.getFragFactor() >= this.maxFragFactor) {
-                this.defrag();
+        cleanUp();
+        for (WeakReference<T> ref : set) {
+            T obj = ref.get();
+            if (obj != null && obj.equals(element)) {
+                return true;
             }
-            //this.check();
-            return true;
         }
         return false;
     }
 
-    public boolean contains(final E element) {
-        return this.indexMap.containsKey(element);
-    }
-
-    public boolean add(final E element) {
-        final int listSize = this.listSize;
-
-        final int previous = this.indexMap.putIfAbsent(element, listSize);
-        if (previous != -1) {
-            return false;
-        }
-
-        if (listSize >= this.listElements.length) {
-            this.listElements = Arrays.copyOf(this.listElements, listSize * 2);
-        }
-        this.listElements[listSize] = element;
-        this.listSize = listSize + 1;
-
-        //this.check();
-        return true;
-    }
-
-    protected void defrag() {
-        if (this.firstInvalidIndex < 0) {
-            return; // nothing to do
-        }
-
-        if (this.indexMap.isEmpty()) {
-            Arrays.fill(this.listElements, 0, this.listSize, null);
-            this.listSize = 0;
-            this.firstInvalidIndex = -1;
-            //this.check();
-            return;
-        }
-
-        final E[] backingArray = this.listElements;
-
-        int lastValidIndex;
-        java.util.Iterator<Reference2IntMap.Entry<E>> iterator;
-
-        if (this.firstInvalidIndex == 0) {
-            iterator = this.indexMap.reference2IntEntrySet().fastIterator();
-            lastValidIndex = 0;
-        } else {
-            lastValidIndex = this.firstInvalidIndex;
-            final E key = backingArray[lastValidIndex - 1];
-            iterator = this.indexMap.reference2IntEntrySet().fastIterator(new Reference2IntMap.Entry<E>() {
-                @Override
-                public int getIntValue() {
-                    throw new UnsupportedOperationException();
-                }
-
-                @Override
-                public int setValue(int i) {
-                    throw new UnsupportedOperationException();
-                }
-
-                @Override
-                public E getKey() {
-                    return key;
-                }
-            });
-        }
-
-        while (iterator.hasNext()) {
-            final Reference2IntMap.Entry<E> entry = iterator.next();
-
-            final int newIndex = lastValidIndex++;
-            backingArray[newIndex] = entry.getKey();
-            entry.setValue(newIndex);
+    private synchronized void cleanUp() {
+        Iterator<WeakReference<T>> it = set.iterator();
+        while (it.hasNext()) {
+            WeakReference<T> ref = it.next();
+            if (ref.get() == null) {
+                it.remove();
+            }
         }
-
-        // cleanup end
-        Arrays.fill(backingArray, lastValidIndex, this.listSize, null);
-        this.listSize = lastValidIndex;
-        this.firstInvalidIndex = -1;
-        //this.check();
-    }
-
-    public E rawGet(final int index) {
-        return this.listElements[index];
     }
 
-    public int size() {
-        // always returns the correct amount - listSize can be different
-        return this.indexMap.size();
-    }
-
-    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator() {
-        return this.iterator(0);
-    }
-
-    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator(final int flags) {
-        if (this.allowSafeIteration()) {
-            ++this.iteratorCount;
+    @Override
+    public synchronized Iterator<T> iterator() {
+        cleanUp();
+        Set<T> strongRefs = new LinkedHashSet<>();
+        for (WeakReference<T> ref : set) {
+            T obj = ref.get();
+            if (obj != null) {
+                strongRefs.add(obj);
+            }
         }
-        return new BaseIterator<>(this, true, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
-    }
-
-    public java.util.Iterator<E> unsafeIterator() {
-        return this.unsafeIterator(0);
-    }
-    public java.util.Iterator<E> unsafeIterator(final int flags) {
-        return new BaseIterator<>(this, false, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
+        return strongRefs.iterator();
     }
 
-    public static interface Iterator<E> extends java.util.Iterator<E> {
-
-        public void finishedIterating();
-
+    public synchronized int size() {
+        cleanUp();
+        return set.size();
     }
 
-    protected static final class BaseIterator<E> implements IteratorSafeOrderedReferenceSet.Iterator<E> {
-
-        protected final IteratorSafeOrderedReferenceSet<E> set;
-        protected final boolean canFinish;
-        protected final int maxIndex;
-        protected int nextIndex;
-        protected E pendingValue;
-        protected boolean finished;
-        protected E lastReturned;
-
-        protected BaseIterator(final IteratorSafeOrderedReferenceSet<E> set, final boolean canFinish, final int maxIndex) {
-            this.set = set;
-            this.canFinish = canFinish;
-            this.maxIndex = maxIndex;
-        }
-
-        @Override
-        public boolean hasNext() {
-            if (this.finished) {
-                return false;
-            }
-            if (this.pendingValue != null) {
-                return true;
-            }
-
-            final E[] elements = this.set.listElements;
-            int index, len;
-            for (index = this.nextIndex, len = Math.min(this.maxIndex, this.set.listSize); index < len; ++index) {
-                final E element = elements[index];
-                if (element != null) {
-                    this.pendingValue = element;
-                    this.nextIndex = index + 1;
-                    return true;
-                }
-            }
-
-            this.nextIndex = index;
-            return false;
-        }
-
-        @Override
-        public E next() {
-            if (!this.hasNext()) {
-                throw new NoSuchElementException();
-            }
-            final E ret = this.pendingValue;
-
-            this.pendingValue = null;
-            this.lastReturned = ret;
-
-            return ret;
-        }
-
-        @Override
-        public void remove() {
-            final E lastReturned = this.lastReturned;
-            if (lastReturned == null) {
-                throw new IllegalStateException();
-            }
-            this.lastReturned = null;
-            this.set.remove(lastReturned);
-        }
-
-        @Override
-        public void finishedIterating() {
-            if (this.finished || !this.canFinish) {
-                throw new IllegalStateException();
-            }
-            this.lastReturned = null;
-            this.finished = true;
-            if (this.set.allowSafeIteration()) {
-                this.set.finishRawIterator();
-            }
-        }
-    }
 }
+
diff --git a/src/main/java/me/dueris/canvas/CanvasConfig.java b/src/main/java/me/dueris/canvas/CanvasConfig.java
index b69f6b2c1bdd129aef96a07f49971e6ee250dfdd..a7804cccf8a8c46b7818be6df48a5d803a040825 100644
--- a/src/main/java/me/dueris/canvas/CanvasConfig.java
+++ b/src/main/java/me/dueris/canvas/CanvasConfig.java
@@ -3,6 +3,7 @@ package me.dueris.canvas;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import me.dueris.canvas.command.CanvasCommand;
 import net.kyori.adventure.bossbar.BossBar;
 import net.kyori.adventure.text.minimessage.MiniMessage;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -52,7 +53,7 @@ public class CanvasConfig {
     private static File CONFIG_FILE;
     public static YamlConfiguration config;
 
-    private static Map<String, Command> commands;
+    private static Map<String, Command> commands = new HashMap<>();
 
     public static int version;
     static boolean verbose;
@@ -70,6 +71,8 @@ public class CanvasConfig {
         config.options().header(HEADER);
         config.options().copyDefaults(true);
 
+        commands.put("canvas", new CanvasCommand("canvas"));
+
         version = getInt("config-version", 33);
         set("config-version", 33);
 
@@ -174,8 +177,12 @@ public class CanvasConfig {
     public static boolean asyncPathfinding;
     public static int asyncPathfindingMaxThreads;
     public static int asyncPathfindingKeepalive;
+    public static int maxTickerThreads = 3;
+    public static boolean autoStartSpark = true;
 
     private static void optimizations(){
+        maxTickerThreads = getInt("optimizations.maxTickerThreads", maxTickerThreads);
+        autoStartSpark = getBoolean("optimizations.autoStartSpark", autoStartSpark);
         asyncPathfinding = getBoolean("optimizations.async-pathfinding.enable", true);
         asyncPathfindingMaxThreads = getInt("optimizations.async-pathfinding.max-threads", 0);
         asyncPathfindingKeepalive = getInt("optimizations.async-pathfinding.keepalive", 60);
diff --git a/src/main/java/me/dueris/canvas/command/CanvasCommand.java b/src/main/java/me/dueris/canvas/command/CanvasCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..25d0a8ef795b6cf0c65fdbf7e2c96c70a0b62c25
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/command/CanvasCommand.java
@@ -0,0 +1,241 @@
+package me.dueris.canvas.command;
+
+import java.io.File;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import com.mojang.datafixers.util.Pair;
+import me.dueris.canvas.world.TickManagerHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.format.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.TickRateManager;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.purpurmc.purpur.PurpurConfig;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GOLD;
+import static net.kyori.adventure.text.format.NamedTextColor.GRAY;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+import static net.kyori.adventure.text.format.NamedTextColor.YELLOW;
+
+public class CanvasCommand extends Command {
+    public CanvasCommand(String name) {
+        super(name);
+        this.description = "Canvas related commands";
+        this.usageMessage = "/canvas [tps | version]";
+        this.setPermission("bukkit.command.canvas");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("tps", "version")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        CraftServer server = (CraftServer) sender.getServer();
+        List<Pair<ServerTickRateManager, Float>> tpsValues = server.getServer().getAllTickRateManagers().stream().map(ServerTickRateManager::toTpsPair).toList();
+        int runningRegions = 0;
+        for (final ServerLevel allLevel : server.getServer().getAllLevels()) {
+            runningRegions += allLevel.regionManager().regionChunksMap.keySet().size();
+        }
+
+        Pair<ServerTickRateManager, Float> minMSPT = tpsValues.stream()
+            .min(Comparator.comparing(Pair::getSecond))
+            .orElseThrow(() -> new RuntimeException("List is empty"));
+
+        Pair<ServerTickRateManager, Float> maxMSPT = tpsValues.stream()
+            .max(Comparator.comparing(Pair::getSecond))
+            .orElseThrow(() -> new RuntimeException("List is empty"));
+
+        Float median = Float.valueOf((minMSPT.getSecond() + maxMSPT.getSecond()) / 2);
+        Float min = minMSPT.getSecond();
+        Float max = maxMSPT.getSecond();
+
+        if (args.length != 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("tps")) {
+            TextComponent base = Component.text("").color(TextColor.color(0x4EA2ED));
+            sender.sendMessage(base.append(
+                Component.text("==================================")));
+            sender.sendMessage(base.append(
+                Component.text("Server Status Report"))
+                .color(TextColor.color(6860008)));
+            sender.sendMessage(base.append(
+                Component.text(" - Online Players: "))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(String.valueOf(server.getOnlinePlayers().size())).color(TextColor.color(10407396)))));
+            sender.sendMessage(base.append(
+                    Component.text(" - Running Regions: "))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(String.valueOf(runningRegions)).color(TextColor.color(10407396)))));
+            sender.sendMessage(base.append(
+                Component.text(" - Running TickHolders: "))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(String.valueOf(server.getServer().getAllTickRateManagers().size())).color(TextColor.color(10407396)))));
+            sender.sendMessage(base.append(
+                Component.text(" - Lowest TickHolder TPS:"))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(" ").append(createColoredComponent(simplifyNumber(min.doubleValue()).toString(), simplifyNumber(min.doubleValue()).floatValue())))));
+            sender.sendMessage(base.append(
+                Component.text(" - Median TickHolder TPS:"))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(" ").append(createColoredComponent(simplifyNumber(median.doubleValue()).toString(), simplifyNumber(median.doubleValue()).floatValue())))));
+            sender.sendMessage(base.append(
+                Component.text(" - Highest TickHolder TPS:"))
+                .color(TextColor.color(0x2F8FE9))
+                .append(base.append(
+                    Component.text(" ").append(createColoredComponent(simplifyNumber(max.doubleValue()).toString(), simplifyNumber(max.doubleValue()).floatValue())))));
+
+            sender.sendMessage(base.append(Component.text("==================================")));
+            List<Pair<ServerTickRateManager, Long>> top3Pairs = server.getServer().getAllTickRateManagers().stream().map(ServerTickRateManager::toNanoPair)
+                .sorted(Comparator.comparing(Pair<ServerTickRateManager, Long>::getSecond))
+                .limit(3)
+                .collect(Collectors.toList());
+            sender.sendMessage(base.append(
+                Component.text("Detailed Status Report ").append(Component.text("(Highest 3)").color(TextColor.color(6860008))))
+                .color(TextColor.color(0x2F8FE9)));
+            for (Pair<ServerTickRateManager, Long> pair : top3Pairs) {
+                TickManagerHolder ticker = pair.getFirst().getHolder();
+                Integer chunkCount = ticker instanceof ServerLevel level ? level.getChunkSource().getLoadedChunksCount() : 0;
+                Integer playerCount = ticker instanceof ServerLevel level ? level.players().size() : 0;
+                Integer entityCount = ticker instanceof ServerLevel level ? level.getEntityLookup().entityCount() : 0;
+                sender.sendMessage(base.append(
+                    Component.text(" - TickHolder Level ").append(Component.text("[{}]".replace("{}", ticker.getHolderName())).color(TextColor.color(10407396))))
+                );
+                sender.sendMessage(base.append(
+                    Component.text("   ").append(
+                        getColor((double) ticker.getNanoSecondsFromLastTick() / 1_000_000)
+                        .append(base.append(Component.text(" MSPT at ")))
+                        .append(createColoredComponent(simplifyNumber(ticker.getTps()).toString(), ticker.getTps()))
+                        .append(base.append(Component.text(" TPS")))
+                    )
+                ));
+                sender.sendMessage(base.append(
+                    Component.text("   ").append(
+                        base.append(Component.text("Chunks: ").append(Component.text(chunkCount.toString()).color(TextColor.color(10407396))))
+                        .append(base.append(Component.text(" Players: ").append(Component.text(playerCount.toString()).color(TextColor.color(10407396)))))
+                        .append(base.append(Component.text(" Entities: ").append(Component.text(entityCount.toString()).color(TextColor.color(10407396)))))
+                    )
+                ));
+            }
+
+            sender.sendMessage(base.append(Component.text("==================================")));
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
+            if (verCmd != null) {
+                return verCmd.execute(sender, commandLabel, new String[0]);
+            }
+        }
+
+        return true;
+    }
+
+    public Component createColoredUtilComponent(String text, float value) {
+        float clampedValue = Math.max(0, Math.min(100, value));
+        float ratio = clampedValue / 100.0f;
+
+        int red, green;
+
+        if (ratio <= 0.18) {
+            red = 0;
+            green = 255;
+        } else if (ratio <= 0.5) {
+            float normalizedRatio = (ratio - 0.18f) / (0.5f - 0.18f);
+            red = (int) (normalizedRatio * 255);
+            green = 255;
+        } else {
+            float normalizedRatio = (ratio - 0.5f) / (1.0f - 0.5f);
+            red = 255;
+            green = (int) ((1.0f - normalizedRatio) * 255);
+        }
+
+        TextColor color = TextColor.color(red, green, 0);
+        return Component.text(text).color(color);
+    }
+
+    public static Double makeMsptReadable(double number) {
+        if (number >= 1.0) {
+            return Double.parseDouble(String.format("%.2f", number));
+        }
+
+        double precision = 0.1;
+        while (number < precision) {
+            precision /= 10;
+        }
+
+        return Math.round(number / precision) * precision;
+    }
+
+    public static List<Component> eval(long[] times) {
+        long min = Long.MAX_VALUE;
+        long max = 0L;
+        long total = 0L;
+        for (long value : times) {
+            if (value > 0L && value < min) min = value;
+            if (value > max) max = value;
+            total += value;
+        }
+        double avgD = total / (double) times.length * 1.0E-6D;
+        double minD = min * 1.0E-6D;
+        double maxD = max * 1.0E-6D;
+        return java.util.Arrays.asList(getColor(avgD), getColor(minD), getColor(maxD));
+    }
+
+    public static Component getColor(double avg) {
+        return text(makeMsptReadable(avg).toString(), avg >= 50 ? RED : avg >= 40 ? YELLOW : GREEN);
+    }
+
+    public static Double simplifyNumber(double number) {
+        if (number >= 1.0) {
+            return Math.round(number * 100.0) / 100.0;
+        }
+
+        double precision = 0.1;
+        while (number < precision) {
+            precision /= 10;
+        }
+
+        return Math.round(number / precision) * precision;
+    }
+
+    public Component createColoredComponent(String text, float value) {
+        float clampedValue = Math.max(0, Math.min(20, value));
+        float ratio = clampedValue / 20.0f;
+
+        int red = (int) ((1 - ratio) * 255);
+        int green = (int) (ratio * 255);
+
+        TextColor color = TextColor.color(red, green, 0);
+        return Component.text(text).color(color);
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java b/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..65a1d87f48d8d9bdaea763bd14136591a9938bf9
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/NamedTickThreadFactory.java
@@ -0,0 +1,63 @@
+package me.dueris.canvas.thread;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
+import org.slf4j.Logger;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class NamedTickThreadFactory implements ThreadFactory { // Extends the functionality of the NamedThreadFactory by vanilla
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private final ThreadGroup group;
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String namePrefix;
+    private int priority;
+    private boolean daemon;
+
+    public NamedTickThreadFactory(String name) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = 5;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName, boolean daemon){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = daemon;
+    }
+
+    @Override
+    public Thread newThread(Runnable runnable) {
+        TickThread thread = new TickThread(runnable, namePrefix + this.threadNumber.getAndIncrement());
+        thread.setDaemon(daemon);
+        thread.setUncaughtExceptionHandler((threadx, throwable) -> {
+            LOGGER.error("Caught exception in thread {} from {}", threadx, runnable);
+            LOGGER.error("", throwable);
+        });
+        if (thread.getPriority() != priority) {
+            thread.setPriority(priority);
+        }
+
+        return thread;
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/ScheduledTask.java b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cc5415c50c9c6aaf143a8a29c6e4ae0ea58bff3
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
@@ -0,0 +1,25 @@
+package me.dueris.canvas.thread;
+
+public class ScheduledTask {
+    Runnable runnable;
+    boolean onMain;
+    TickTaskHolder.Timing timing;
+    
+    public ScheduledTask(Runnable runnable, boolean onMain, TickTaskHolder.Timing timing) {
+        this.runnable = runnable;
+        this.onMain = onMain;
+        this.timing = timing;
+    }
+
+    public boolean canRun(TickTaskHolder.Timing timing) {
+        return this.timing == timing;
+    }
+
+    public boolean serverLevel() {
+        return !this.onMain;
+    }
+
+    public void run() {
+        this.runnable.run();
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..0bc048f7096429440685bcd6309f34c0ea7a609c
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
@@ -0,0 +1,13 @@
+package me.dueris.canvas.thread;
+
+public interface TickTaskHolder {
+    public void scheduleTickTask(Runnable runnable, Timing timing, State state);
+
+    public static enum Timing {
+        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY;
+    }
+
+    public static enum State {
+        SERVER_LEVEL, MAIN;
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/WorldTickThread.java b/src/main/java/me/dueris/canvas/thread/WorldTickThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..0dbd245466f965a80c1736a49d574c6827f2fdea
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/WorldTickThread.java
@@ -0,0 +1,26 @@
+package me.dueris.canvas.thread;
+
+import io.papermc.paper.util.TickThread;
+
+public abstract class WorldTickThread extends TickThread implements TickTaskHolder{
+
+    public WorldTickThread(final String name) {
+        super(name);
+    }
+
+    public abstract void stopWorld();
+
+    public abstract void runWorld();
+
+    public abstract void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state);
+
+    @Override
+    public void run() {
+        this.runWorld();
+    }
+
+    @Override
+    public void start() {
+        super.start();
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/region/RegionManager.java b/src/main/java/me/dueris/canvas/thread/region/RegionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c776bfc4f6e9ecaf53d918c70466c90fe0a563f
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionManager.java
@@ -0,0 +1,167 @@
+package me.dueris.canvas.thread.region;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+
+public class RegionManager {
+    private static final int MAX_CHUNKS = 20000;
+    private static final int OVERFLOW_LIMIT = 2000;
+
+    public final ConcurrentHashMap<ThreadedRegion, CopyOnWriteArraySet<ChunkPos>> regionChunksMap = new ConcurrentHashMap<>();
+    public final ConcurrentHashMap<ChunkPos, ThreadedRegion> chunkToRegionMap = new ConcurrentHashMap<>();
+    private final ServerLevel level;
+    private final Lock lock = new ReentrantLock();
+
+    public RegionManager(ServerLevel level) {
+        this.level = level;
+    }
+
+    public void stopRegions() {
+        this.regionChunksMap.keySet().forEach(region -> {
+            region.stopSpinning();
+        });
+    }
+
+    public ChunkPos[][] chunkMap() {
+        Set<ChunkPos> positions = new HashSet<>();
+        for (final ThreadedRegion value : this.chunkToRegionMap.values()) {
+            positions.addAll(value.chunkSet());
+        }
+        return createChunkPosArray(positions);
+    }
+
+    public ChunkPos[][] chunkMap(ThreadedRegion region) {
+        return createChunkPosArray(region.chunkSet());
+    }
+
+    public static ChunkPos[][] createChunkPosArray(Set<ChunkPos> chunkPosSet) {
+        if (chunkPosSet.isEmpty()) {
+            return new ChunkPos[0][0];
+        }
+
+        int minX = Integer.MAX_VALUE;
+        int maxX = Integer.MIN_VALUE;
+        int minZ = Integer.MAX_VALUE;
+        int maxZ = Integer.MIN_VALUE;
+
+        for (ChunkPos chunkPos : chunkPosSet) {
+            if (chunkPos.x < minX) {
+                minX = chunkPos.x;
+            }
+            if (chunkPos.x > maxX) {
+                maxX = chunkPos.x;
+            }
+            if (chunkPos.z < minZ) {
+                minZ = chunkPos.z;
+            }
+            if (chunkPos.z > maxZ) {
+                maxZ = chunkPos.z;
+            }
+        }
+
+        int width = maxX - minX + 1;
+        int height = maxZ - minZ + 1;
+
+        ChunkPos[][] chunkPosArray = new ChunkPos[width][height];
+
+        for (ChunkPos chunkPos : chunkPosSet) {
+            int xIndex = chunkPos.x - minX;
+            int zIndex = chunkPos.z - minZ;
+            chunkPosArray[xIndex][zIndex] = chunkPos;
+        }
+
+        return chunkPosArray;
+    }
+
+    public void tick(Set<ChunkPos> newChunkPosSet) {
+        lock.lock();
+        try {
+            Set<ChunkPos> addedChunks = new HashSet<>(newChunkPosSet);
+            addedChunks.removeAll(chunkToRegionMap.keySet());
+
+            Set<ChunkPos> removedChunks = new HashSet<>(chunkToRegionMap.keySet());
+            removedChunks.removeAll(newChunkPosSet);
+
+            for (ChunkPos chunkPos : addedChunks) {
+                ThreadedRegion region = findOrCreateRegion(chunkPos);
+                regionChunksMap.computeIfAbsent(region, r -> new CopyOnWriteArraySet<>()).add(chunkPos);
+                chunkToRegionMap.put(chunkPos, region);
+            }
+
+            for (ChunkPos chunkPos : removedChunks) {
+                ThreadedRegion region = chunkToRegionMap.remove(chunkPos);
+                if (region != null) {
+                    regionChunksMap.get(region).remove(chunkPos);
+                    if (regionChunksMap.get(region).size() <= MAX_CHUNKS * 0.2) {
+                        mergeRegion(region);
+                    }
+                }
+            }
+
+            mergeNeighboringRegions();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public Optional<ThreadedRegion> getChunkPosRegion(ChunkPos pos) {
+        for (ThreadedRegion region : this.chunkToRegionMap.values()) {
+            if (region.chunkSet().contains(pos)) {
+                return Optional.of(region);
+            }
+        }
+        return Optional.empty();
+    }
+
+    private ThreadedRegion findOrCreateRegion(ChunkPos chunkPos) {
+        for (ThreadedRegion region : regionChunksMap.keySet()) {
+            if (regionChunksMap.get(region).size() < MAX_CHUNKS) {
+                return region;
+            }
+        }
+
+        System.out.println("New region creating..");
+        ThreadedRegion newRegion = new ThreadedRegion(this.level);
+        regionChunksMap.put(newRegion, new CopyOnWriteArraySet<>());
+        return newRegion;
+    }
+
+    private void mergeRegion(ThreadedRegion region) {
+        for (ThreadedRegion neighbor : regionChunksMap.keySet()) {
+            if (neighbor != region && region.isNeighbor(neighbor)) {
+                if (regionChunksMap.get(neighbor).size() + regionChunksMap.get(region).size() <= MAX_CHUNKS + OVERFLOW_LIMIT) {
+                    neighbor.merge(regionChunksMap.get(region));
+                    regionChunksMap.remove(region);
+                    for (ChunkPos chunkPos : regionChunksMap.get(region)) {
+                        chunkToRegionMap.put(chunkPos, neighbor);
+                    }
+                    break;
+                }
+            }
+        }
+    }
+
+    private void mergeNeighboringRegions() {
+        List<ThreadedRegion> regionList = new ArrayList<>(regionChunksMap.keySet());
+        for (int i = 0; i < regionList.size(); i++) {
+            for (int j = i + 1; j < regionList.size(); j++) {
+                ThreadedRegion region1 = regionList.get(i);
+                ThreadedRegion region2 = regionList.get(j);
+                if (region1.isNeighbor(region2) && regionChunksMap.get(region1).size() + regionChunksMap.get(region2).size() <= MAX_CHUNKS) {
+                    region1.merge(regionChunksMap.get(region2));
+                    regionChunksMap.remove(region2);
+                    for (ChunkPos chunkPos : regionChunksMap.get(region2)) {
+                        chunkToRegionMap.put(chunkPos, region1);
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/me/dueris/canvas/thread/region/RegionThread.java b/src/main/java/me/dueris/canvas/thread/region/RegionThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b9bdb38d9f9b82984386f355228ada9e6b52f18
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/RegionThread.java
@@ -0,0 +1,21 @@
+package me.dueris.canvas.thread.region;
+
+import io.papermc.paper.util.TickThread;
+import me.dueris.canvas.thread.TickTaskHolder;
+
+public abstract class RegionThread extends TickThread  implements TickTaskHolder {
+    public RegionThread(final String name) {
+        super(name);
+    }
+
+    abstract void tickRegion();
+
+    abstract void spin();
+
+    abstract void stopSpinning();
+
+    @Override
+    public void run() {
+        this.spin();
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java b/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java
new file mode 100644
index 0000000000000000000000000000000000000000..397a1a9a09d00eb9b02422a2d928939148a3b540
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/region/ThreadedRegion.java
@@ -0,0 +1,390 @@
+package me.dueris.canvas.thread.region;
+
+import java.awt.*;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import me.dueris.canvas.thread.ScheduledTask;
+import me.dueris.canvas.thread.TickTaskHolder;
+import me.dueris.canvas.world.TickManagerHolder;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.TickTask;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.util.debugchart.DebugSampleSubscriptionTracker;
+import net.minecraft.util.debugchart.RemoteDebugSampleType;
+import net.minecraft.util.debugchart.RemoteSampleLogger;
+import net.minecraft.util.debugchart.TpsDebugDimensions;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.command.defaults.ReloadCommand;
+
+public class ThreadedRegion extends RegionThread implements TickManagerHolder {
+    private static final Logger LOGGER = LogManager.getLogger("ThreadedRegion");
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal("1E9").multiply(new java.math.BigDecimal(MinecraftServer.SAMPLE_INTERVAL));
+    public final CountDownLatch latch = new CountDownLatch(1);
+    public final Double[] recentTps = new Double[4];
+    public final MinecraftServer.RollingAverage tps5s = new MinecraftServer.RollingAverage(5);
+    public final MinecraftServer.RollingAverage tps1 = new MinecraftServer.RollingAverage(60);
+    public final MinecraftServer.RollingAverage tps5 = new MinecraftServer.RollingAverage(60 * 5);
+    public final MinecraftServer.RollingAverage tps15 = new MinecraftServer.RollingAverage(60 * 15);
+    private final ConcurrentLinkedQueue<ScheduledTask> scheduledTasks = new ConcurrentLinkedQueue<>();
+    private final ServerLevel level;
+    private final MinecraftServer server;
+    private final ResourceKey<Level> dimension;
+    private final ServerTickRateManager tickRateManager;
+    public volatile boolean running = false;
+    public int tickCount = 0;
+    public int currentTick;
+    public long currentTickLong;
+    public boolean lagging = false;
+    public Long lastNanoTickTime = 0L;
+    public long currentTime;
+    private long nextTickTimeNanos;
+    private long lastOverloadWarningNanos;
+    private long taskExecutionStartNanos;
+    private long idleTimeNanos;
+    private long delayedTasksMaxNextTickTimeNanos;
+    private boolean mayHaveDelayedTasks;
+    private ThreadedRegion.EventLoop eventLoop;
+    private net.minecraft.util.debugchart.SampleLogger tickTimeLogger;
+    private final Set<ChunkPos> chunks = new CopyOnWriteArraySet<>();
+    private final Lock lock = new ReentrantLock();
+    private final RegionManager manager;
+
+    public ThreadedRegion(ServerLevel level) {
+        super("ThreadedRegion");
+        this.level = level;
+        this.setUncaughtExceptionHandler((thread1, throwable) -> {
+            ServerLevel.LOGGER.error("Uncaught exception in ThreadedRegion", throwable);
+        });
+        this.setPriority(Thread.NORM_PRIORITY + 2);
+        if (Runtime.getRuntime().availableProcessors() > 4) {
+            this.setPriority(8);
+        }
+        this.server = level.server;
+        this.dimension = level.dimension();
+        this.tickRateManager = new ServerTickRateManager(this);
+        this.manager = level.regionManager();
+        this.start();
+    }
+
+    @Override
+    protected void tickRegion() {
+        tickCount++;
+        Set<ChunkPos> chunkPosSet = manager.regionChunksMap.get(this);
+        if (chunkPosSet != null) {
+            this.updateChunks(chunkPosSet);
+        }
+    }
+
+    @Override
+    public PlayerList getPlayerList() {
+        return this.server.getPlayerList();
+    }
+
+    @Override
+    public CommandSourceStack createCommandSourceStack() {
+        return this.server.createCommandSourceStack();
+    }
+
+    @Override
+    public void onTickRateChanged() {
+        server.onTickRateChanged();
+    }
+
+    @Override
+    public ServerTickRateManager getManager() {
+        return tickRateManager;
+    }
+
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public String getHolderName() {
+        return this.dimension.location().toString();
+    }
+
+    private void startMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            this.taskExecutionStartNanos = Util.getNanos();
+            this.idleTimeNanos = 0L;
+        }
+
+    }
+
+    private void finishMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            net.minecraft.util.debugchart.SampleLogger samplelogger = this.tickTimeLogger;
+
+            samplelogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            samplelogger.logPartialSample(this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.IDLE.ordinal());
+        }
+
+    }
+
+    @Override
+    protected void stopSpinning() {
+        this.running = false;
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void spin() {
+        long tickSection = Util.getNanos();
+        this.running = true;
+        this.eventLoop = new ThreadedRegion.EventLoop(this);
+        DebugSampleSubscriptionTracker debugSampleSubscriptionTracker = new DebugSampleSubscriptionTracker(this.getPlayerList());
+        this.tickTimeLogger = new RemoteSampleLogger(TpsDebugDimensions.values().length, debugSampleSubscriptionTracker, RemoteDebugSampleType.TICK_TIME);
+        while (this.running) {
+            try {
+                long tickDuration;
+                currentTime = Util.getNanos();
+                if (ReloadCommand.isReloading) continue; // Dont tick worlds during reload
+                if (!server.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+                    tickDuration = 0L;
+                    this.nextTickTimeNanos = Util.getNanos();
+                    this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                } else {
+                    tickDuration = this.tickRateManager().nanosecondsPerTick();
+                    long elapsedTime = Util.getNanos() - this.nextTickTimeNanos;
+
+                    if (elapsedTime > 20 + 20L * tickDuration && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * tickDuration) {
+                        long ticksBehind = elapsedTime / tickDuration;
+
+                        if (server.server.getWarnOnOverload() && tickCount > 300)
+                            LOGGER.warn("Can't keep up! Is the region overloaded? Running {}ms or {} ticks behind.", elapsedTime / TimeUtil.NANOSECONDS_PER_MILLISECOND, ticksBehind);
+                        this.nextTickTimeNanos += ticksBehind * tickDuration;
+                        this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                    }
+                }
+                ++this.currentTickLong;
+                currentTime = Util.getNanos();
+                if (++this.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+                    final long diff = currentTime - tickSection;
+                    final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff);
+                    tps1.add(currentTps, diff);
+                    tps5.add(currentTps, diff);
+                    tps15.add(currentTps, diff);
+
+                    this.recentTps[0] = tps5s.getAverage();
+                    this.recentTps[1] = tps1.getAverage();
+                    this.recentTps[2] = tps5.getAverage();
+                    this.recentTps[3] = tps15.getAverage();
+                    lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+                    tickSection = currentTime;
+                }
+                this.nextTickTimeNanos += tickDuration;
+
+                long i = Util.getNanos();
+                this.tickRegion();
+                this.lastNanoTickTime = Util.getNanos() - i;
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + tickDuration, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+                    this.nextTickTimeNanos = currentTime + nextTickTimeNanos;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+        latch.countDown();
+    }
+
+    public void waitUntilNextTick() {
+        eventLoop.managedBlock(() -> !(server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < this.nextTickTimeNanos));
+    }
+
+    public boolean haveTime() {
+        if (server.forceTicks) {
+            return true;
+        }
+        if (server.isOversleep)
+            return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
+        return server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+    }
+
+    @Override
+    public void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(TickTaskHolder.State.MAIN), timing));
+    }
+
+    public void runAllScheduledTasks() {
+        List<ScheduledTask> tasksToRun = new java.util.ArrayList<>(this.scheduledTasks);
+        this.scheduledTasks.clear();
+
+        for (ScheduledTask task : tasksToRun) {
+            task.run();
+        }
+    }
+
+    public void runAllWithTiming(Timing timing) {
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (task.canRun(timing) && task.serverLevel()) {
+                iterator.remove();
+                task.run();
+            }
+        }
+    }
+
+    public ServerLevel level() {
+        return level;
+    }
+
+    public ResourceKey<Level> dimension() {
+        return dimension;
+    }
+
+    public ServerTickRateManager tickRateManager() {
+        return tickRateManager;
+    }
+
+    public int tickCount() {
+        return tickCount;
+    }
+
+    public void addChunk(ChunkPos chunkPos) {
+        lock.lock();
+        try {
+            if (!chunks.add(chunkPos)) {
+                throw new IllegalStateException("Chunk already in region");
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void removeChunk(ChunkPos chunkPos) {
+        lock.lock();
+        try {
+            chunks.remove(chunkPos);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public int size() {
+        lock.lock();
+        try {
+            return chunks.size();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public ChunkPos[][] chunks() {
+        return this.manager.createChunkPosArray(this.chunkSet());
+    }
+
+    public Set<ChunkPos> chunkSet() {
+        lock.lock();
+        try {
+            return Collections.unmodifiableSet(chunks);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public boolean isNeighbor(ThreadedRegion other) {
+        lock.lock();
+        try {
+            for (ChunkPos chunkPos : chunks) {
+                if (other.chunks.contains(chunkPos)) {
+                    return true;
+                }
+            }
+            return false;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void merge(Set<ChunkPos> otherChunks) {
+        lock.lock();
+        try {
+            for (ChunkPos chunkPos : otherChunks) {
+                addChunk(chunkPos);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void updateChunks(Set<ChunkPos> newChunks) {
+        lock.lock();
+        try {
+            chunks.clear();
+            chunks.addAll(newChunks);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    private static class EventLoop extends net.minecraft.util.thread.ReentrantBlockableEventLoop<net.minecraft.server.TickTask> {
+        private final ServerLevel level;
+
+        public EventLoop(ThreadedRegion region) {
+            super("ThreadedRegion_" + region.hashCode());
+            this.level = region.level;
+        }
+
+        @Override
+        protected TickTask wrapRunnable(Runnable runnable) {
+            if (level.server.hasStopped && Thread.currentThread().equals(level.server.shutdownThread)) {
+                runnable.run();
+                runnable = () -> {};
+            }
+            return new TickTask(level.tickCount, runnable);
+        }
+
+        @Override
+        protected boolean shouldRun(TickTask ticktask) {
+            return ticktask.getTick() + 3 < level.tickCount || level.server.haveTime();
+        }
+
+        @Override
+        protected Thread getRunningThread() {
+            return Thread.currentThread();
+        }
+
+        public boolean getRunningTask() {
+            return this.runningTask();
+        }
+    }
+
+}
diff --git a/src/main/java/me/dueris/canvas/world/TickManagerHolder.java b/src/main/java/me/dueris/canvas/world/TickManagerHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..812ca23a793e3adeea4f3fbf5d60c0b954a9c03a
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/world/TickManagerHolder.java
@@ -0,0 +1,21 @@
+package me.dueris.canvas.world;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.world.TickRateManager;
+
+public interface TickManagerHolder {
+    public PlayerList getPlayerList();
+
+    public CommandSourceStack createCommandSourceStack();
+
+    public void onTickRateChanged();
+
+    public TickRateManager getManager();
+
+    public Float getTps();
+
+    public Long getNanoSecondsFromLastTick();
+
+    public String getHolderName();
+}
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 7b3638212bcfffaa85d3bd033358817292d1f7f8..33407454005f16145d5c8bd6835e776812ce2216 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -359,6 +359,7 @@ public class Commands {
                 });
             }
         } catch (Exception exception) {
+            exception.printStackTrace(); // Canvas - lets print command stacktraces
             if (throwCommandError) throw exception;
             MutableComponent ichatmutablecomponent = Component.literal(exception.getMessage() == null ? exception.getClass().getName() : exception.getMessage());
 
diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index f70a80b496bd1498778e82fc221c3b1b39308b75..aac1c0a52087f2fa6cd60d46185047bf4f4111c6 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -9,6 +9,7 @@ import it.unimi.dsi.fastutil.longs.LongSet;
 import java.util.ArrayDeque;
 import java.util.Optional;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -500,7 +501,7 @@ public class BlockPos extends Vec3i {
     public static int breadthFirstTraversal(
         BlockPos pos, int maxDepth, int maxIterations, BiConsumer<BlockPos, Consumer<BlockPos>> nextQueuer, Predicate<BlockPos> callback
     ) {
-        Queue<Pair<BlockPos, Integer>> queue = new ArrayDeque<>();
+        Queue<Pair<BlockPos, Integer>> queue = new ConcurrentLinkedDeque<>(); // Canvas
         LongSet longSet = new LongOpenHashSet();
         queue.add(Pair.of(pos, 0));
         int i = 0;
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 1a37654aff9a9c86c9f7af10a1cf721371f0c5ec..2ede26ce0ce71282ef259360ec7128641f41b82f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,9 @@ package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -18,18 +21,18 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public static final StreamCodec<FriendlyByteBuf, ClientboundSectionBlocksUpdatePacket> STREAM_CODEC = Packet.codec(ClientboundSectionBlocksUpdatePacket::write, ClientboundSectionBlocksUpdatePacket::new);
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
-    private final short[] positions;
+    private final Short[] positions;
     private final BlockState[] states;
 
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ConcurrentLinkedQueue<Short> positions, LevelChunkSection section) {
         this.sectionPos = sectionPos;
         int i = positions.size();
 
-        this.positions = new short[i];
+        this.positions = new Short[i];
         this.states = new BlockState[i];
         int j = 0;
 
-        for (ShortIterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
+        for (Iterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
             short short0 = (Short) shortiterator.next();
 
             this.positions[j] = short0;
@@ -39,9 +42,9 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     }
 
     // CraftBukkit start - Add constructor
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ShortSet shortset, BlockState[] states) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ConcurrentLinkedQueue<Short> shortset, BlockState[] states) {
         this.sectionPos = sectionposition;
-        this.positions = shortset.toShortArray();
+        this.positions = shortset.toArray(new Short[0]);
         this.states = states;
     }
     // CraftBukkit end
@@ -50,7 +53,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
         this.sectionPos = SectionPos.of(buf.readLong());
         int i = buf.readVarInt();
 
-        this.positions = new short[i];
+        this.positions = new Short[i];
         this.states = new BlockState[i];
 
         for (int j = 0; j < i; ++j) {
@@ -63,9 +66,9 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     }
 
     // Paper start - Multi Block Change API
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<BlockState> blockChanges) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ConcurrentHashMap<Short, ?> blockChanges) {
         this.sectionPos = sectionPos;
-        this.positions = blockChanges.keySet().toShortArray();
+        this.positions = blockChanges.keySet().toArray(new Short[0]);
         this.states = blockChanges.values().toArray(new BlockState[0]);
     }
     // Paper end - Multi Block Change API
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index f20460c7e0c5a50e62684a30ab1b37631a0b26ba..cb2be12583d008aae57786dc422afbfd55a93180 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -13,6 +13,7 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
@@ -40,12 +41,18 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -54,6 +61,9 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import me.dueris.canvas.thread.NamedTickThreadFactory;
+import me.dueris.canvas.thread.WorldTickThread;
+import me.dueris.canvas.world.TickManagerHolder;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
@@ -118,6 +128,7 @@ import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
 import net.minecraft.util.thread.ReentrantBlockableEventLoop;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.RandomSequences;
+import net.minecraft.world.TickRateManager;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.ai.village.VillageSiege;
 import net.minecraft.world.entity.npc.CatSpawner;
@@ -192,7 +203,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 
 import co.aikar.timings.MinecraftTimings; // Paper
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable, TickManagerHolder { // Canvas
 
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogUtils.getLogger();
@@ -202,7 +213,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final int TICK_STATS_SPAN = 100;
     private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND; // Canvas - private -> public
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
     private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
@@ -237,11 +248,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private int port;
     private final LayeredRegistryAccess<RegistryLayer> registries;
     private Map<ResourceKey<Level>, ServerLevel> levels;
+    // Canvas start - Multithreaded WorldTicking
+    // Canvas end
     private PlayerList playerList;
-    private volatile boolean running;
+    public volatile boolean running; // Canvas
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
     private boolean stopped;
-    private int tickCount;
+    public int tickCount; // Canvas
     private int ticksUntilAutosave;
     protected final Proxy proxy;
     private boolean onlineMode;
@@ -286,7 +299,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private String serverId;
     public MinecraftServer.ReloadableResources resources;
     private final StructureTemplateManager structureTemplateManager;
-    private final ServerTickRateManager tickRateManager;
+    public final ServerTickRateManager tickRateManager; // Canvas
     protected WorldData worldData;
     public PotionBrewing potionBrewing;
     private volatile boolean isSaving;
@@ -306,9 +319,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Spigot start
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
-    private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
+    public static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop // Canvas
     @Deprecated(forRemoval = true) // Paper
-    public final double[] recentTps = new double[ 4 ]; // Purpur
+    public final Double[] recentTps = new Double[ 4 ]; // Purpur // Canvas
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public static long currentTickLong = 0L; // Paper - track current tick as a long
@@ -340,6 +353,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         thread.start();
         return s0;
     }
+    // Canvas start - Multithreaded WorldTicking
+
+    public List<ServerTickRateManager> getAllTickRateManagers() {
+        List<ServerTickRateManager> managers = new ArrayList<>();
+        managers.add(this.tickRateManager);
+        this.getAllLevels().forEach(level -> {
+            managers.add((ServerTickRateManager) level.tickRateManager());
+        });
+        return managers;
+    }
+    // Canvas end
 
     public MinecraftServer(OptionSet options, WorldLoader.DataLoadContext worldLoader, Thread thread, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PackRepository resourcepackrepository, WorldStem worldstem, Proxy proxy, DataFixer datafixer, Services services, ChunkProgressListenerFactory worldloadlistenerfactory) {
         super("Server");
@@ -964,7 +988,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // CraftBukkit start
-    private boolean hasStopped = false;
+    public boolean hasStopped = false; // Canvas
     private boolean hasLoggedStop = false; // Paper - Debugging
     public volatile boolean hasFullyShutdown = false; // Paper
     private final Object stopLock = new Object();
@@ -1075,6 +1099,25 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.onServerExit();
         // Paper end - move final shutdown items here
     }
+    // Canvas start
+
+    private final LinkedBlockingQueue<WorldTickThread> currentWorldThreads = new LinkedBlockingQueue<>();
+    public void shutdownTickers() {
+        for (final WorldTickThread currentWorldThread : currentWorldThreads) {
+            currentWorldThread.stopWorld();
+            try {
+                currentWorldThread.join();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    @Override
+    public ServerTickRateManager getManager() {
+        return tickRateManager;
+    }
+    // Canvas end
 
     public String getLocalIp() {
         return this.localIp;
@@ -1134,7 +1177,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private final java.math.BigDecimal[] samples;
         private final long[] times;
 
-        RollingAverage(int size) {
+        public RollingAverage(int size) { // Canvas
             this.size = size;
             this.time = size * SEC_IN_NANO;
             this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
@@ -1170,6 +1213,39 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Spigot End
 
     public static volatile RuntimeException chunkSystemCrash; // Paper - rewrite chunk system
+    // Canvas start
+    public BooleanSupplier shouldKeepTicking;
+    private boolean shouldTickLevels = false;
+    private long lastNanoTickTime = 0L;
+
+    public void stopWorlds() {
+        this.getAllLevels().forEach(ServerLevel::stopWorld);
+
+        this.getAllLevels().forEach(level -> {
+            try {
+                // level.latch.await();
+                LOGGER.info("ServerLevel \"{}\" stopped successfully!".replace("{}", level.getWorld().getKey().asString()));
+            } catch (Throwable throwable) {
+                throw new IllegalStateException("Shutdown process for WorldTicker was interupted!");
+            }
+        });
+    }
+
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public String getHolderName() {
+        return "MinecraftServer";
+    }
+    // Canvas end
 
     protected void runServer() {
         try {
@@ -1191,12 +1267,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // anything at 3+ won't be caught here but also will trip watchdog....
             // tasks are default scheduled at -1 + delay, and first tick will tick at 1
             String doneTime = String.format(java.util.Locale.ROOT, "%.3fs", (double) (Util.getNanos() - serverStartTime) / 1.0E9D);
+            // Canvas start - rewrite world ticking
+            LOGGER.info("Canvas: Starting Multithreaded WorldTickers");
+            try {
+                for (ServerLevel level : this.getAllLevels()) {
+                    this.currentWorldThreads.add(level);
+                    level.start();
+                }
+            } catch (Throwable throwable) {
+                throw new IllegalStateException("Failed to start WorldTickers");
+            }
+            // Canvas end
             LOGGER.info("Done ({})! For help, type \"help\"", doneTime);
+            this.shouldTickLevels = true; // Canvas
             // Paper end
 
             org.spigotmc.WatchdogThread.tick(); // Paper
             org.spigotmc.WatchdogThread.hasStarted = true; // Paper
-            Arrays.fill( this.recentTps, 20 );
+            Arrays.fill( this.recentTps, 20D ); // Canvas
             // Paper start - further improve server tick loop
             long tickSection = Util.getNanos();
             long currentTime;
@@ -1284,9 +1372,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.nextTickTimeNanos += i;
                 //this.startMetricsRecordingTick(); // Purpur
                 //this.profiler.push("tick"); // Purpur
-                this.tickServer(flag ? () -> {
+                // Canvas start
+                shouldKeepTicking = flag ? () -> {
                     return false;
-                } : this::haveTime);
+                } : this::haveTime;
+                long iA = Util.getNanos();
+                this.tickServer(shouldKeepTicking);
+                this.lastNanoTickTime = Util.getNanos() - iA;
+                // Canvas end
                 //this.profiler.popPush("nextTickWait"); // Purpur
                 this.mayHaveDelayedTasks = true;
                 this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + i, this.nextTickTimeNanos);
@@ -1332,6 +1425,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             try {
                 this.stopped = true;
+                // Canvas start
+                LOGGER.info("Waiting for ServerLevel processes to finish..");
+                this.shutdownTickers();
+                // Canvas end
                 this.stopServer();
             } catch (Throwable throwable1) {
                 MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
@@ -1406,7 +1503,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return crashreport;
     }
 
-    private boolean haveTime() {
+    public boolean haveTime() { // Canvas
         // Paper start
         if (this.forceTicks) {
             return true;
@@ -1418,12 +1515,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Paper start
-    boolean isOversleep = false;
+    public boolean isOversleep = false; // Canvas
     private boolean canOversleep() {
         return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
     }
 
-    private boolean canSleepForTickNoOversleep() {
+    public boolean canSleepForTickNoOversleep() { // Canvas
         return this.forceTicks || this.runningTask() || Util.getNanos() < this.nextTickTimeNanos;
     }
     // Paper end
@@ -1434,7 +1531,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // CraftBukkit end
     }
 
-    protected void waitUntilNextTick() {
+    public void waitUntilNextTick() { // Canvas
         //this.executeAll(); // Paper - move this into the tick method for timings
         this.managedBlock(() -> {
             return !this.canSleepForTickNoOversleep(); // Paper - move oversleep into full server tick
@@ -1506,6 +1603,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public final void executeMidTickTasks() {
+        if (true) return; // Canvas - disable mid-tick tasks
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
@@ -1712,6 +1810,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return Math.max(100, (int) (f * 300.0F));
     }
 
+    @Override // Canvas
     public void onTickRateChanged() {
         int i = this.computeNextAutosaveInterval();
 
@@ -1764,6 +1863,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
         getAllLevels().forEach(level -> {
             for (final Entity entity : level.getEntityLookup().getAllCopy()) { // Paper - rewrite chunk system
+                if (entity == null) continue; // Canvas
                 if (entity.isRemoved()) {
                     continue;
                 }
@@ -1772,6 +1872,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     bukkit.taskScheduler.executeTick();
                 }
             }
+            level.tickRegions();
         });
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
@@ -1793,7 +1894,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         //MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper // Purpur
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        /* for (final ServerLevel level : this.getAllLevels()) { // Canvas
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1808,46 +1909,55 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
                 entityplayer.connection.send(packet); // Add support for per player time
             }
-        }
+        } */ // Canvas
         // Paper end - Perf: Optimize time updates
         //MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper // Purpur
 
-        this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
-        Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
-        while (iterator.hasNext()) {
+        // this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked // Canvas
+        /* // Canvas start - Multithreaded WorldTicking // Canvas - i decided to rewrite all of world ticking!
+        Iterator iterator = this.getAllLevels().iterator();
+        final AtomicBoolean finishedTicking = new AtomicBoolean(false);
+        List<com.mojang.datafixers.util.Pair<Runnable, ServerLevel>> worldTicks = new ArrayList();
+        while (iterator.hasNext() && !finishedTicking.get()){
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
-            worldserver.updateLagCompensationTick(); // Paper - lag compensation
-            worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+        // Canvas end
 
-            /*this.profiler.push(() -> { // Purpur
+            this.profiler.push(() -> { // Purpur
                 String s = String.valueOf(worldserver);
 
                 return s + " " + String.valueOf(worldserver.dimension().location());
-            });*/ // Purpur
-            /* Drop global time updates
+            }); // Purpur
+             Drop global time updates
             if (this.tickCount % 20 == 0) {
                 //this.profiler.push("timeSync"); // Purpur
                 this.synchronizeTime(worldserver);
                 //this.profiler.pop(); // Purpur
             }
-            // CraftBukkit end */
+            // CraftBukkit end
 
             //this.profiler.push("tick"); // Purpur
 
             try {
+                // Canvas start
+                if (worldserver == null) {
+                    finishedTicking.set(true);
+                    break;
+                }
+
+                Pair<Runnable, ServerLevel> tick = worldserver.tick(shouldKeepTicking, tickCount);
+                // Canvas end
                 //worldserver.timings.doTick.startTiming(); // Spigot // Purpur
-                worldserver.tick(shouldKeepTicking);
+                // worldserver.tick(shouldKeepTicking); // Canvas
                 // Paper start
-                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) { // Canvas
                     regionManager.recalculateRegions();
-                }
+                } // Canvas
                 // Paper end
                 //worldserver.timings.doTick.stopTiming(); // Spigot // Purpur
+                if (tick != null) worldTicks.add(tick); // Canvas
             } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                if(throwable instanceof NoSuchElementException) return; // Canvas
+                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception preparing WorldTick!"); // Canvas
 
                 worldserver.fillReportDetails(crashreport);
                 throw new ReportedException(crashreport);
@@ -1855,9 +1965,38 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             //this.profiler.pop(); // Purpur
             //this.profiler.pop(); // Purpur
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            // worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions // Canvas
         }
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        // Canvas start - Multithreaded WorldTicking
+        List<CompletableFuture<Void>> futureTicks = new ArrayList();
+        for(com.mojang.datafixers.util.Pair<Runnable, ServerLevel> tick : worldTicks){
+            futureTicks.add(CompletableFuture.runAsync(() -> {
+                try {
+                    tick.getFirst().run();
+                } catch (Exception throwable) {
+                    CrashReport report = CrashReport.forThrowable(throwable, "Exception ticking world!");
+                    tick.getSecond().fillReportDetails(report);
+                    throw new ReportedException(report);
+                }
+            }, this.worldTickerPool));
+        }
+            CompletableFuture<Void> allTicks = CompletableFuture.allOf(futureTicks.toArray(new CompletableFuture[0]));
+        // try {
+        //     allTicks.get();
+        // } catch (InterruptedException | ExecutionException e) {
+        //     e.printStackTrace();
+        // }
+        // Run scheduled main thread tasks now */ // Canvas
+        getAllLevels().forEach(level -> {
+            for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : level.getChunkSource().chunkMap.regionManagers) {
+                regionManager.recalculateRegions();
+            }
+            level.getChunkSource().tick(shouldKeepTicking, true);
+            level.explosionDensityCache.clear();
+        });
+        getAllLevels().forEach(Level::runMainThreadTasks);
+        // Canvas end
 
         //this.profiler.popPush("connection"); // Purpur
         // MinecraftTimings.connectionTimer.startTiming(); // Spigot // Paper // Purpur
@@ -1880,7 +2019,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         //MinecraftTimings.tickablesTimer.stopTiming(); // Spigot // Paper // Purpur
 
         //this.profiler.popPush("send chunks"); // Purpur
-        iterator = this.playerList.getPlayers().iterator();
+        Iterator iterator = this.playerList.getPlayers().iterator(); // Canvas
 
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
@@ -1944,6 +2083,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        if (this.shouldTickLevels) level.runWorld(); // Canvas
     }
 
     public void removeLevel(ServerLevel level) {
@@ -1951,6 +2091,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        if (this.shouldTickLevels) level.stopWorld(); // Canvas
     }
     // CraftBukkit end
 
@@ -2196,6 +2337,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.stopped;
     }
 
+    @Override // Canvas
     public PlayerList getPlayerList() {
         return this.playerList;
     }
@@ -2540,6 +2682,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.resources.managers.getCommands();
     }
 
+    @Override // Canvas
     public CommandSourceStack createCommandSourceStack() {
         ServerLevel worldserver = this.overworld();
 
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index ef520d1dd00ae9473c1f34e2df4d8b064fe4d6ea..7ae149ee70aa2bb930538ae667a8d488cb2cc335 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -24,6 +24,8 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.BiConsumer;
 import javax.annotation.Nullable;
 import net.minecraft.FileUtil;
@@ -54,10 +56,10 @@ public class PlayerAdvancements {
     private final PlayerList playerList;
     private final Path playerSavePath;
     private AdvancementTree tree;
-    private final Map<AdvancementHolder, AdvancementProgress> progress = new LinkedHashMap();
-    private final Set<AdvancementHolder> visible = new HashSet();
-    private final Set<AdvancementHolder> progressChanged = new HashSet();
-    private final Set<AdvancementNode> rootsToUpdate = new HashSet();
+    private final ConcurrentHashMap<AdvancementHolder, AdvancementProgress> progress = new ConcurrentHashMap();
+    private final Set<AdvancementHolder> visible = new io.netty.util.internal.ConcurrentSet<>();
+    private final ConcurrentLinkedQueue<AdvancementHolder> progressChanged = new ConcurrentLinkedQueue();
+    private final ConcurrentLinkedQueue<AdvancementNode> rootsToUpdate = new ConcurrentLinkedQueue();
     private ServerPlayer player;
     @Nullable
     private AdvancementHolder lastSelectedTab;
diff --git a/src/main/java/net/minecraft/server/ServerTickRateManager.java b/src/main/java/net/minecraft/server/ServerTickRateManager.java
index 37dcf3dc3e50afd85912a7496c828576a38a4e9c..b5658e2cfbfe54b6ea7c75f00466b2c284fea5b8 100644
--- a/src/main/java/net/minecraft/server/ServerTickRateManager.java
+++ b/src/main/java/net/minecraft/server/ServerTickRateManager.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import com.mojang.datafixers.util.Pair;
+import me.dueris.canvas.world.TickManagerHolder;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.game.ClientboundTickingStatePacket;
 import net.minecraft.network.protocol.game.ClientboundTickingStepPacket;
@@ -14,9 +16,9 @@ public class ServerTickRateManager extends TickRateManager {
     private long sprintTimeSpend = 0L;
     private long scheduledCurrentSprintTicks = 0L;
     private boolean previousIsFrozen = false;
-    private final MinecraftServer server;
+    private final TickManagerHolder server; // Canvas
 
-    public ServerTickRateManager(MinecraftServer server) {
+    public ServerTickRateManager(TickManagerHolder server) { // Canvas
         this.server = server;
     }
 
@@ -24,6 +26,21 @@ public class ServerTickRateManager extends TickRateManager {
         return this.scheduledCurrentSprintTicks > 0L;
     }
 
+    // Canvas start
+
+    public TickManagerHolder getHolder() {
+        return server;
+    }
+
+    public Pair<ServerTickRateManager, Float> toTpsPair() {
+        return new Pair<>(this, getHolder().getTps());
+    }
+
+    public Pair<ServerTickRateManager, Long> toNanoPair() {
+        return new Pair<>(this, getHolder().getNanoSecondsFromLastTick());
+    }
+    // Canvas end
+
     @Override
     public void setFrozen(boolean frozen) {
         super.setFrozen(frozen);
diff --git a/src/main/java/net/minecraft/server/commands/TickCommand.java b/src/main/java/net/minecraft/server/commands/TickCommand.java
index 5ce845a9cd84c355e2716dfcb0b62686c783c9f9..e2bbfe84841cba1c0fddcdb6e2a717765015ed7c 100644
--- a/src/main/java/net/minecraft/server/commands/TickCommand.java
+++ b/src/main/java/net/minecraft/server/commands/TickCommand.java
@@ -13,7 +13,6 @@ import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.util.TimeUtil;
 
 public class TickCommand {
-    private static final float MAX_TICKRATE = 10000.0F;
     private static final String DEFAULT_TICKRATE = String.valueOf(20);
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
@@ -24,7 +23,7 @@ public class TickCommand {
                 .then(
                     Commands.literal("rate")
                         .then(
-                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F, 10000.0F))
+                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F)) // Canvas - remove cap on tick cmd
                                 .suggests((context, suggestionsBuilder) -> SharedSuggestionProvider.suggest(new String[]{DEFAULT_TICKRATE}, suggestionsBuilder))
                                 .executes(context -> setTickingRate(context.getSource(), FloatArgumentType.getFloat(context, "rate")))
                         )
@@ -60,8 +59,13 @@ public class TickCommand {
     }
 
     private static int setTickingRate(CommandSourceStack source, float rate) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        serverTickRateManager.setTickRate(rate);
+        // Canvas start
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            tickRateManager.setTickRate(rate);
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // serverTickRateManager.setTickRate(rate);
+        // Canvas end
         String string = String.format("%.1f", rate);
         source.sendSuccess(() -> Component.translatable("commands.tick.rate.success", string), true);
         return (int)rate;
@@ -98,8 +102,16 @@ public class TickCommand {
     }
 
     private static int sprint(CommandSourceStack source, int ticks) {
-        boolean bl = source.getServer().tickRateManager().requestGameToSprint(ticks);
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.requestGameToSprint(ticks)) {
+                success[0] = false;
+            }
+        });
+        // boolean bl = source.getServer().tickRateManager().requestGameToSprint(ticks);
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.sprint.stop.success"), true);
         }
 
@@ -108,7 +120,21 @@ public class TickCommand {
     }
 
     private static int setFreeze(CommandSourceStack source, boolean frozen) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // Canvas start
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (frozen) {
+                if (tickRateManager.isSprinting()) {
+                    tickRateManager.stopSprinting();
+                }
+
+                if (tickRateManager.isSteppingForward()) {
+                    tickRateManager.stopStepping();
+                }
+            }
+
+            tickRateManager.setFrozen(frozen);
+        });
+        /* ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
         if (frozen) {
             if (serverTickRateManager.isSprinting()) {
                 serverTickRateManager.stopSprinting();
@@ -120,6 +146,7 @@ public class TickCommand {
         }
 
         serverTickRateManager.setFrozen(frozen);
+        */ // Canvas end
         if (frozen) {
             source.sendSuccess(() -> Component.translatable("commands.tick.status.frozen"), true);
         } else {
@@ -130,9 +157,17 @@ public class TickCommand {
     }
 
     private static int step(CommandSourceStack source, int steps) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stepGameIfPaused(steps);
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stepGameIfPaused(steps)) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stepGameIfPaused(steps);
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.step.success", steps), true);
         } else {
             source.sendFailure(Component.translatable("commands.tick.step.fail"));
@@ -142,9 +177,17 @@ public class TickCommand {
     }
 
     private static int stopStepping(CommandSourceStack source) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stopStepping();
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stopStepping()) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stopStepping();
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.step.stop.success"), true);
             return 1;
         } else {
@@ -154,9 +197,17 @@ public class TickCommand {
     }
 
     private static int stopSprinting(CommandSourceStack source) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stopSprinting();
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stopSprinting()) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stopSprinting();
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.sprint.stop.success"), true);
             return 1;
         } else {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 2a7e00d6222ae8fb74fc8886962b572b6ffe22cb..bd1f448b7601b3d2aaae4afa1a56d60caa72744b 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -252,6 +252,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
         org.purpurmc.purpur.PurpurConfig.registerCommands();
+        me.dueris.canvas.CanvasConfig.registerCommands(); // Canvas
         // Purpur end
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 472b9494f8a34a8ba90d6a2936b0db7530a229ad..735bdf41c74f76046abcb2d30494053d25713c02 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -7,6 +7,7 @@ import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.function.IntConsumer;
@@ -54,7 +55,7 @@ public class ChunkHolder {
     // Paper - rewrite chunk system
     public final ChunkPos pos;
     private boolean hasChangedSections;
-    private final ShortSet[] changedBlocksPerSection;
+    private final ConcurrentLinkedQueue<Short>[] changedBlocksPerSection;
     private final BitSet blockChangedLightSectionFilter;
     private final BitSet skyChangedLightSectionFilter;
     private final LevelLightEngine lightEngine;
@@ -130,7 +131,7 @@ public class ChunkHolder {
         this.onLevelChange = null; // Paper - rewrite chunk system
         this.playerProvider = playersWatchingChunkProvider;
         // Paper - rewrite chunk system
-        this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
+        this.changedBlocksPerSection = new ConcurrentLinkedQueue[world.getSectionsCount()];
         this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
     }
 
@@ -225,7 +226,7 @@ public class ChunkHolder {
             if (i < 0 || i >= this.changedBlocksPerSection.length) return; // CraftBukkit - SPIGOT-6086, SPIGOT-6296
             if (this.changedBlocksPerSection[i] == null) {
                 this.hasChangedSections = true; this.addToBroadcastMap(); // Paper - optimise chunk tick iteration
-                this.changedBlocksPerSection[i] = new ShortOpenHashSet();
+                this.changedBlocksPerSection[i] = new ConcurrentLinkedQueue<>();
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
@@ -295,7 +296,7 @@ public class ChunkHolder {
                 list = this.getPlayers(false); // Paper - rewrite chunk system
 
                 for (int i = 0; i < this.changedBlocksPerSection.length; ++i) {
-                    ShortSet shortset = this.changedBlocksPerSection[i];
+                    ConcurrentLinkedQueue<Short> shortset = this.changedBlocksPerSection[i];
 
                     if (shortset != null) {
                         this.changedBlocksPerSection[i] = null;
@@ -304,7 +305,7 @@ public class ChunkHolder {
                             SectionPos sectionposition = SectionPos.of(chunk.getPos(), j);
 
                             if (shortset.size() == 1) {
-                                BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
+                                BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().next());
                                 BlockState iblockdata = world.getBlockState(blockposition);
 
                                 this.broadcast(list, new ClientboundBlockUpdatePacket(blockposition, iblockdata));
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 345f143b0eeb77acb96e4bc716f3b23782ac782f..8db0affddcd5aced848114f74ef654598f7ad256 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -31,6 +31,7 @@ import java.io.Writer;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
@@ -42,6 +43,9 @@ import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
@@ -66,6 +70,7 @@ import net.minecraft.network.protocol.game.ClientboundChunksBiomesPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
+import net.minecraft.util.ByIdMap;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -140,10 +145,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final AtomicInteger tickingGenerated; // Paper - public
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
-    private final Long2ByteMap chunkTypeCache;
-    private final Long2LongMap chunkSaveCooldowns;
-    private final Queue<Runnable> unloadQueue;
+    public final ConcurrentHashMap<Integer, TrackedEntity> entityMap; // Canvas
+    private final ConcurrentHashMap<Long, Byte> chunkTypeCache; // Canvas
     public int serverViewDistance;
     private WorldGenContext worldGenContext; public final WorldGenContext getWorldGenContext() { return this.worldGenContext; } // Paper - rewrite chunk system
 
@@ -245,7 +248,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final io.papermc.paper.util.player.NearbyPlayers nearbyPlayers;
     // Paper end
     // Paper start - optimise chunk tick iteration
-    public final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
+    public final ConcurrentLinkedQueue<ChunkHolder> needsChangeBroadcasting = new ConcurrentLinkedQueue<>(); // Canvas
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
     // Paper end - optimise chunk tick iteration
 
@@ -254,10 +257,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
-        this.chunkTypeCache = new Long2ByteOpenHashMap();
-        this.chunkSaveCooldowns = new Long2LongOpenHashMap();
-        this.unloadQueue = Queues.newConcurrentLinkedQueue();
+        this.entityMap = new ConcurrentHashMap<>(); // Canvas
+        this.chunkTypeCache = new ConcurrentHashMap<>(); // Canvas
         Path path = session.getDimensionPath(world.dimension());
 
         this.storageName = path.getFileName().toString();
@@ -1118,7 +1119,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
                         while (objectiterator.hasNext()) {
                             ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1138,7 +1139,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer entityplayer) {
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1156,7 +1157,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - optimised tracker
-    private final void processTrackQueue() {
+    private synchronized final void processTrackQueue() {
         //this.level.timings.tracker1.startTiming(); // Purpur
         try {
             for (TrackedEntity tracker : this.entityMap.values()) {
@@ -1188,7 +1189,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator objectiterator = this.entityMap.values().iterator(); // Canvas
         //this.level.timings.tracker1.startTiming(); // Paper // Purpur
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 476a04d87a61b021816d2970e86042bde32d95a2..5db26087c1dea8ec23f1d230f182c777acca1ffe 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -6,10 +6,13 @@ import com.mojang.datafixers.DataFixer;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -67,8 +70,8 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(); // Canvas
+    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(); // Canvas
     final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
     final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
     final java.util.concurrent.atomic.AtomicLong chunkFutureAwaitCounter = new java.util.concurrent.atomic.AtomicLong(); // Paper - chunk system rewrite
@@ -589,7 +592,7 @@ public class ServerChunkCache extends ChunkSource {
                 if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
                     chunkIterator = this.tickingChunks.iterator();
                 } else {
-                    chunkIterator = this.tickingChunks.unsafeIterator();
+                    chunkIterator = this.tickingChunks.iterator(); // Canvas
                     List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.tickingChunks.size());
                     while (chunkIterator.hasNext()) {
                         shuffled.add(chunkIterator.next());
@@ -641,9 +644,9 @@ public class ServerChunkCache extends ChunkSource {
                 }
                 // Paper start - optimise chunk tick iteration
                 } finally {
-                    if (chunkIterator instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
-                        safeIterator.finishedIterating();
-                    }
+                    // if (chunkIterator instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet safeIterator) {
+                    //     safeIterator.finishedIterating();
+                    // }
                 }
                 // Paper end - optimise chunk tick iteration
                 // this.level.timings.chunkTicks.stopTiming(); // Paper // Purpur
@@ -661,7 +664,7 @@ public class ServerChunkCache extends ChunkSource {
                 //this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing // Purpur
             // Paper start - optimise chunk tick iteration
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+                ConcurrentLinkedQueue<ChunkHolder> copy = (ConcurrentLinkedQueue<ChunkHolder>) new ConcurrentLinkedQueue<>(this.chunkMap.needsChangeBroadcasting); // Canvas
                 this.chunkMap.needsChangeBroadcasting.clear();
                 for (ChunkHolder holder : copy) {
                     holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index dd6278fe99e2ee4daa95249c71ea935dd08b0025..003f9575de45aa25ed43e693885e5db3fea1cb62 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -10,6 +10,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -394,7 +395,7 @@ public class ServerEntity {
         }
 
         if (this.entity instanceof LivingEntity) {
-            Set<AttributeInstance> set = ((LivingEntity) this.entity).getAttributes().getDirtyAttributes();
+            ConcurrentLinkedQueue<AttributeInstance> set = ((LivingEntity) this.entity).getAttributes().getDirtyAttributes(); // Canvas
 
             if (!set.isEmpty()) {
                 // CraftBukkit start - Send scaled max health
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index d8d63405e7eb388d8690d8a4c645bbb3955108b7..1ee78110ae9da57730a519f04bb5c28b4f079648 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,11 +6,13 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
+import me.dueris.canvas.world.TickManagerHolder;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
@@ -22,6 +24,7 @@ import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -30,6 +33,10 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -41,6 +48,7 @@ import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -60,6 +68,7 @@ import net.minecraft.network.protocol.game.ClientboundExplodePacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -67,7 +76,10 @@ import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.TickTask;
 import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.players.PlayerList;
 import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
@@ -77,6 +89,7 @@ import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
+import net.minecraft.util.TimeUtil;
 import net.minecraft.util.Unit;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -170,6 +183,7 @@ import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
+import org.bukkit.command.defaults.ReloadCommand;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.WeatherType;
@@ -182,19 +196,19 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 
-public class ServerLevel extends Level implements WorldGenLevel {
+public class ServerLevel extends Level implements WorldGenLevel, TickManagerHolder { // Canvas
 
     public static final BlockPos END_SPAWN_POINT = new BlockPos(100, 50, 0);
     public static final IntProvider RAIN_DELAY = UniformInt.of(12000, 180000);
     public static final IntProvider RAIN_DURATION = UniformInt.of(12000, 24000);
     private static final IntProvider THUNDER_DELAY = UniformInt.of(12000, 180000);
     public static final IntProvider THUNDER_DURATION = UniformInt.of(3600, 15600);
-    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final Logger LOGGER = LogUtils.getLogger(); // Canvas - private -> public
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
     final List<ServerPlayer> players;
     public final ServerChunkCache chunkSource;
-    private final MinecraftServer server;
+    public final MinecraftServer server; // Canvas - private -> public
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
     private int lastSpawnChunkRadius;
     final EntityTickList entityTickList;
@@ -210,7 +224,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     final Set<Mob> navigatingMobs;
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
+    private final CopyOnWriteArrayList<BlockEventData> blockEvents; // Canvas
     private final List<BlockEventData> blockEventsToReschedule;
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
@@ -224,6 +238,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private boolean forceTime; // Purpur
     private final RandomSequences randomSequences;
     public long lastMidTickExecuteFailure; // Paper - execute chunk tasks mid tick
+    public ServerTickRateManager tickRateManager;
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess convertable;
@@ -232,6 +247,16 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur
+    // Canvas start - Multithreaded WorldTicking
+    public Thread currentTickingThread = null;
+    public me.dueris.canvas.thread.region.RegionManager manager;
+
+    public static Throwable getAddToWorldStackTrace(Entity entity) {
+        final Throwable thr = new Throwable(entity + " Added to world at " + new java.util.Date());
+        io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateThrowable(thr);
+        return thr;
+    }
+    // Canvas end
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -706,12 +731,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
         this.players = Lists.newArrayList();
+        this.tickRateManager = new ServerTickRateManager(this);
         this.entityTickList = new EntityTickList();
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.pathTypesByPosCache = new PathTypeCache();
-        this.navigatingMobs = new ObjectOpenHashSet();
-        this.blockEvents = new ObjectLinkedOpenHashSet();
+        this.navigatingMobs = ConcurrentHashMap.newKeySet();
+        this.blockEvents = new CopyOnWriteArrayList<>();
         this.blockEventsToReschedule = new ArrayList(64);
         this.dragonParts = new Int2ObjectOpenHashMap();
         this.tickTime = flag1;
@@ -828,11 +854,253 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public StructureManager structureManager() {
         return this.structureManager;
     }
+    // Canvas start - Rewrite world ticking
+
+    public volatile boolean running = false;
+    public final CountDownLatch latch = new CountDownLatch(1);
+    private long nextTickTimeNanos;
+    private long lastOverloadWarningNanos;
+    public int tickCount = 0;
+    public int currentTick;
+    public long currentTickLong;
+    private long taskExecutionStartNanos;
+    private long idleTimeNanos;
+    private long delayedTasksMaxNextTickTimeNanos;
+    private boolean mayHaveDelayedTasks;
+    public boolean lagging = false;
+    public Long lastNanoTickTime = 0L;
+    public final Double[] recentTps = new Double[4];
+    private EventLoop eventLoop;
+    public long currentTime;
+    private net.minecraft.util.debugchart.SampleLogger tickTimeLogger;
+    private net.minecraft.util.debugchart.DebugSampleSubscriptionTracker debugSampleSubscriptionTracker;
+    public final MinecraftServer.RollingAverage tps5s = new MinecraftServer.RollingAverage(5);
+    public final MinecraftServer.RollingAverage tps1 = new MinecraftServer.RollingAverage(60);
+    public final MinecraftServer.RollingAverage tps5 = new MinecraftServer.RollingAverage(60 * 5);
+    public final MinecraftServer.RollingAverage tps15 = new MinecraftServer.RollingAverage(60 * 15);
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(MinecraftServer.SAMPLE_INTERVAL));
 
-    public void tick(BooleanSupplier shouldKeepTicking) {
-        //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
+    @Override
+    public PlayerList getPlayerList() {
+        return this.server.getPlayerList();
+    }
+
+    @Override
+    public CommandSourceStack createCommandSourceStack() {
+        return this.server.createCommandSourceStack();
+    }
+
+    @Override
+    public void onTickRateChanged() {
+        server.onTickRateChanged();
+    }
+
+    @Override
+    public ServerTickRateManager getManager() {
+        return tickRateManager;
+    }
+
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public String getHolderName() {
+        return this.dimension.location().toString();
+    }
+
+    private void startMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            this.taskExecutionStartNanos = Util.getNanos();
+            this.idleTimeNanos = 0L;
+        }
+
+    }
+
+    private void finishMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            net.minecraft.util.debugchart.SampleLogger samplelogger = this.tickTimeLogger;
+
+            samplelogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            samplelogger.logPartialSample(this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.IDLE.ordinal());
+        }
+
+    }
+
+    public void tickRegions() {
+        this.manager.tick(
+            new java.util.HashSet<ChunkPos>(io.papermc.paper.chunk.system.ChunkSystem.getVisibleChunkHolders(this).stream().map(ChunkHolder::getPos).toList())
+        );
+    }
+
+    public me.dueris.canvas.thread.region.RegionManager regionManager() {
+        return this.manager;
+    }
+
+    @Override
+    public void stopWorld() {
+        this.running = false;
+        try {
+            LOGGER.info("Stopping ServerLevel({})...", this.dimension().location().toString());
+            regionManager().stopRegions();
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
 
-        this.handlingTick = true;
+    @Override
+    public void runWorld() {
+        long tickSection = Util.getNanos();
+        this.manager = new me.dueris.canvas.thread.region.RegionManager(this);
+        this.running = true;
+        this.eventLoop = new EventLoop(this);
+        this.debugSampleSubscriptionTracker = new net.minecraft.util.debugchart.DebugSampleSubscriptionTracker(this.getPlayerList());
+        this.tickTimeLogger = new net.minecraft.util.debugchart.RemoteSampleLogger(net.minecraft.util.debugchart.TpsDebugDimensions.values().length, this.debugSampleSubscriptionTracker, net.minecraft.util.debugchart.RemoteDebugSampleType.TICK_TIME);
+        while (this.running) {
+            try {
+                long tickDuration;
+                currentTime = Util.getNanos();
+                if (ReloadCommand.isReloading) continue; // Dont tick worlds during reload
+                if (!server.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+                    tickDuration = 0L;
+                    this.nextTickTimeNanos = Util.getNanos();
+                    this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                } else {
+                    tickDuration = this.tickRateManager().nanosecondsPerTick();
+                    long elapsedTime = Util.getNanos() - this.nextTickTimeNanos;
+
+                    if (elapsedTime > 20 + 20L * tickDuration && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * tickDuration) {
+                        long ticksBehind = elapsedTime / tickDuration;
+
+                        if (server.server.getWarnOnOverload() && tickCount > 300) LOGGER.warn("Can't keep up! Is the world overloaded? Running {}ms or {} ticks behind. ServerLevelIdentifier: {identifier}"
+                            .replace("{identifier}", this.getWorld().getKey().asString()), elapsedTime / TimeUtil.NANOSECONDS_PER_MILLISECOND, ticksBehind);
+                        this.nextTickTimeNanos += ticksBehind * tickDuration;
+                        this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                    }
+                }
+                ++this.currentTickLong;
+                currentTime = Util.getNanos();
+                if (++this.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+                    final long diff = currentTime - tickSection;
+                    final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff);
+                    tps1.add(currentTps, diff);
+                    tps5.add(currentTps, diff);
+                    tps15.add(currentTps, diff);
+
+                    this.recentTps[0] = tps5s.getAverage();
+                    this.recentTps[1] = tps1.getAverage();
+                    this.recentTps[2] = tps5.getAverage();
+                    this.recentTps[3] = tps15.getAverage();
+                    lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+                    tickSection = currentTime;
+                }
+                this.nextTickTimeNanos += tickDuration;
+
+                BooleanSupplier supplier = tickDuration == 0L ? () -> {
+                    return false;
+                } : this::haveTime;
+                long i = Util.getNanos();
+                this.tick(supplier, ++tickCount).run();
+                this.lastNanoTickTime = Util.getNanos() - i;
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + tickDuration, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+                    this.nextTickTimeNanos = currentTime + nextTickTimeNanos;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+        latch.countDown();
+    }
+
+    public void waitUntilNextTick() {
+        eventLoop.managedBlock(() -> !(server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < this.nextTickTimeNanos));
+    }
+
+    public boolean haveTime() {
+        if (server.forceTicks) {
+            return true;
+        }
+        if (server.isOversleep) return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
+        return server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+    }
+
+    private static class EventLoop extends net.minecraft.util.thread.ReentrantBlockableEventLoop<net.minecraft.server.TickTask> {
+        private final ServerLevel level;
+
+        public EventLoop(ServerLevel level) {
+            super("ServerLevel_" + level.dimension().location().toString());
+            this.level = level;
+        }
+
+        @Override
+        protected TickTask wrapRunnable(Runnable runnable) {
+            if (level.server.hasStopped && Thread.currentThread().equals(level.server.shutdownThread)) {
+                runnable.run();
+                runnable = () -> {};
+            }
+            return new TickTask(level.tickCount, runnable);
+        }
+
+        @Override
+        protected boolean shouldRun(TickTask ticktask) {
+            return ticktask.getTick() + 3 < level.tickCount || level.server.haveTime();
+        }
+
+        @Override
+        protected Thread getRunningThread() {
+            return Thread.currentThread();
+        }
+
+        public boolean getRunningTask() {
+            return this.runningTask();
+        }
+
+    }
+    // Canvas end
+
+    public Runnable tick(BooleanSupplier shouldKeepTicking, int tickCount) { // Canvas - Multithreaded WorldTicking
+        // Canvas start - Multithreaded WorldTicking
+        return () -> {
+            // Ensure it still ticks time
+            final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+                final long dayTime = this.getDayTime();
+                long worldTime = this.getGameTime();
+                final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+                for (Player entityhuman : this.players()) {
+                    if (!(entityhuman instanceof ServerPlayer) || (!this.isForceTime() && (tickCount + entityhuman.getId()) % 20 != 0)) {
+                        continue;
+                    }
+                    ServerPlayer entityplayer = (ServerPlayer) entityhuman;
+                    long playerTime = entityplayer.getPlayerTime();
+                    ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
+                        new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+                    entityplayer.connection.send(packet);
+                }
+            this.handlingTick = true;
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_TICK); // Canvas
+            //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
+            // Moved from MinecraftSever
+            this.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+            this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = this.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+            this.updateLagCompensationTick();
+            this.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+            // Move end
+        // Canvas end
         TickRateManager tickratemanager = this.tickRateManager();
         boolean flag = tickratemanager.runsNormally();
 
@@ -892,7 +1160,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         //gameprofilerfiller.popPush("chunkSource"); // Purpur
         //this.timings.chunkProviderTick.startTiming(); // Paper - timings // Purpur
-        this.getChunkSource().tick(shouldKeepTicking, true);
+        // this.getChunkSource().tick(shouldKeepTicking, true); // Canvas
         //this.timings.chunkProviderTick.stopTiming(); // Paper - timings // Purpur
         //gameprofilerfiller.popPush("blockEvents"); // Purpur
         if (flag) {
@@ -901,7 +1169,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             // this.timings.doSounds.stopTiming(); // Spigot // Purpur
         }
 
-        this.handlingTick = false;
+        // this.handlingTick = false; // Canvas
         //gameprofilerfiller.pop(); // Purpur
         boolean flag1 = !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || !this.players.isEmpty() || !this.getForcedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players // Paper - restore this
 
@@ -920,12 +1188,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_ENTITY); // Canvas
             this.entityTickList.forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
                     } else if (!tickratemanager.isEntityFrozen(entity)) {
                         //gameprofilerfiller.push("checkDespawn"); // Purpur
+                        if (entity.isRemoved()) return; // Canvas - if we despawned, dont tick it!
                         entity.checkDespawn();
                         //gameprofilerfiller.pop(); // Purpur
                         if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
@@ -946,6 +1216,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     }
                 }
             });
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.POST_ENTITY); // Canvas
             //this.timings.entityTick.stopTiming(); // Spigot // Purpur
             //this.timings.tickEntities.stopTiming(); // Spigot // Purpur
             //gameprofilerfiller.pop(); // Purpur
@@ -954,6 +1225,15 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         //gameprofilerfiller.push("entityManagement"); // Purpur
         //this.entityManager.tick(); // Paper - rewrite chunk system
+            // Canvas start - Multithreaded WorldTicking
+            /* new ArrayList<>(this.endTickTasks).forEach((r) -> { // Canvas - Use new tick timing system
+                r.run();
+                endTickTasks.remove(r);
+            }); */ // Canvas - Use new tick timing system
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.END_TICK); // Canvas
+            this.handlingTick = false;
+            // Canvas end
+        }; // Canvas
     }
 
     @Override
@@ -2197,7 +2477,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+        return this.tickRateManager;
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index b863f6fe65c796a1d3102cc3eddb5d6c5becd3ac..6aec48b8b4402ded5d17787eeb4e9a74ac1fc5cd 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -25,6 +25,7 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import me.dueris.canvas.thread.TickTaskHolder;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
diff --git a/src/main/java/net/minecraft/util/ThreadingDetector.java b/src/main/java/net/minecraft/util/ThreadingDetector.java
index 84b3a37fe2a4597312c26abded08a45e7218cd17..f321015a7fd5bfb76964b5ab788d5b78d8af6da9 100644
--- a/src/main/java/net/minecraft/util/ThreadingDetector.java
+++ b/src/main/java/net/minecraft/util/ThreadingDetector.java
@@ -33,19 +33,23 @@ public class ThreadingDetector {
 
         try {
             this.stackTraceLock.lock();
-            if (!this.lock.tryAcquire()) {
-                this.threadThatFailedToAcquire = Thread.currentThread();
-                bl = true;
-                this.stackTraceLock.unlock();
+            // Canvas start
+            if(!(Thread.currentThread() instanceof io.papermc.paper.util.TickThread)){
+                if (!this.lock.tryAcquire()) {
+                    this.threadThatFailedToAcquire = Thread.currentThread();
+                    bl = true;
+                    this.stackTraceLock.unlock();
 
-                try {
-                    this.lock.acquire();
-                } catch (InterruptedException var6) {
-                    Thread.currentThread().interrupt();
-                }
+                    try {
+                        this.lock.acquire();
+                    } catch (InterruptedException var6) {
+                        Thread.currentThread().interrupt();
+                    }
 
-                throw this.fullException;
+                    throw this.fullException;
+                }
             }
+            // Canvas end
         } finally {
             if (!bl) {
                 this.stackTraceLock.unlock();
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 9473d1e70ab28415343d0f709df5e341db493e46..4c9258b824bf0adf0bf779a6004ccbc857292c3a 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -3943,7 +3943,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 }).orElse(null); // CraftBukkit - decompile error
             }
         } else {
-            BlockPos blockposition1 = flag1 ? ServerLevel.END_SPAWN_POINT : destination.getSharedSpawnPos();
+            BlockPos blockposition1 = flag1 ? ServerLevel.END_SPAWN_POINT.offset(0, 1, 0) : destination.getSharedSpawnPos(); // Canvas - Multithreaded WorldTicking -- Fix spawning 1 block bellow end platform
 
             destination.getChunkSource().addRegionTicket(TicketType.PORTAL, new ChunkPos(blockposition1), 3, blockposition1);
             int i;
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index c51b429822d56761f69c49ecd4addfab7b90bad8..b126cb21b2b679def6c92734daa758aab7fafe48 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -7,6 +7,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
@@ -20,7 +21,7 @@ import org.slf4j.Logger;
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Map<Holder<Attribute>, AttributeInstance> attributes = new Object2ObjectOpenHashMap<>();
-    private final Set<AttributeInstance> dirtyAttributes = new ObjectOpenHashSet<>();
+    private final ConcurrentLinkedQueue<AttributeInstance> dirtyAttributes = new ConcurrentLinkedQueue<>();
     private final AttributeSupplier supplier;
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
 
@@ -40,7 +41,7 @@ public class AttributeMap {
         }
     }
 
-    public Set<AttributeInstance> getDirtyAttributes() {
+    public ConcurrentLinkedQueue<AttributeInstance> getDirtyAttributes() {
         return this.dirtyAttributes;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 487bb3e75afc5871a79506a54f0f4af806460b14..abf6287a5fce30bb3aa5248df9a41f02a875e349 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -10,9 +10,10 @@ import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+import me.dueris.canvas.thread.TickTaskHolder;
+import me.dueris.canvas.thread.WorldTickThread;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -25,14 +26,13 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
+import me.dueris.canvas.thread.ScheduledTask;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -41,8 +41,6 @@ import net.minecraft.world.TickRateManager;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -101,7 +99,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level extends WorldTickThread implements LevelAccessor, AutoCloseable { // Canvas
 
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
@@ -137,10 +135,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public final boolean isClientSide;
     private final WorldBorder worldBorder;
     private final BiomeManager biomeManager;
-    private final ResourceKey<Level> dimension;
+    public final ResourceKey<Level> dimension; // Canvas
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public java.util.concurrent.LinkedBlockingQueue<me.dueris.canvas.thread.ScheduledTask> scheduledTasks = new java.util.concurrent.LinkedBlockingQueue<>();
 
     // CraftBukkit start Added the following
     private final CraftWorld world;
@@ -229,6 +228,46 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public CraftServer getCraftServer() {
         return (CraftServer) Bukkit.getServer();
     }
+    // Canvas start - scheduler tasks
+
+    @Override
+    public void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(TickTaskHolder.State.MAIN), timing));
+    }
+
+    public void runAllScheduledTasks() {
+        List<ScheduledTask> tasksToRun = new java.util.ArrayList<>(this.scheduledTasks);
+        this.scheduledTasks.clear();
+        
+        for (ScheduledTask task : tasksToRun) {
+            task.run();
+        }
+    }    
+
+    public void runAllWithTiming(Timing timing) {
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (task.canRun(timing) && task.serverLevel()) {
+                iterator.remove();
+                task.run();
+            }
+        }
+    }
+
+    public void runMainThreadTasks() {
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (!task.serverLevel()) {
+                iterator.remove();
+                task.run();
+            }
+        }
+    }
+    // Canvas end
 
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
@@ -249,6 +288,16 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public abstract ResourceKey<LevelStem> getTypeKey();
 
     protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config; Async-Anti-Xray: Pass executor
+        // Canvas start
+        super(resourcekey.location().toString());
+        this.setUncaughtExceptionHandler((thread1, throwable) -> {
+            ServerLevel.LOGGER.error("Uncaught exception in WorldTicker thread", throwable);
+        });
+        this.setPriority(Thread.NORM_PRIORITY + 2);
+        if (Runtime.getRuntime().availableProcessors() > 4) {
+            this.setPriority(8);
+        }
+        // Canvas end
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
         this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName(), env); // Purpur
@@ -1292,6 +1341,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
     }
+    private it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity> toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Canvas
 
     protected void tickBlockEntities() {
         //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
@@ -1311,7 +1361,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         boolean flag = this.tickRateManager().runsNormally();
 
         int tilesThisCycle = 0;
-        var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll
+        // var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll // Canvas
         toRemove.add(null); // Paper - Fix MC-117075
         for (tileTickPosition = 0; tileTickPosition < this.blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters
             this.tileTickPosition = (this.tileTickPosition < this.blockEntityTickers.size()) ? this.tileTickPosition : 0;
@@ -1327,12 +1377,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 tickingblockentity.tick();
                 // Paper start - execute chunk tasks during tick
                 if ((this.tileTickPosition & 7) == 0) {
-                    MinecraftServer.getServer().executeMidTickTasks();
+                    // MinecraftServer.getServer().executeMidTickTasks(); // Canvas - tick midtick tasks at end of tick
                 }
                 // Paper end - execute chunk tasks during tick
             }
         }
         this.blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075
+        toRemove.clear(); // Canvas
 
         //this.timings.tileEntityTick.stopTiming(); // Spigot // Purpur
         this.tickingBlockEntities = false;
@@ -1344,7 +1395,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
             tickConsumer.accept(entity);
-            MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick
+            // MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick // Canvas - tick midtick tasks at end of tick
         } catch (Throwable throwable) {
             if (throwable instanceof ThreadDeath) throw throwable; // Paper
             // Paper start - Prevent block entity and entity crashes
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 83a39f900551e39d5af6f17a339a386ddee4feef..cab564e383012f3c8e51ae46318fdde2cdf32964 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -4,13 +4,15 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking?
-
+    // private final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking? // Canvas
+    private final ConcurrentLinkedQueue<Entity> entities = new ConcurrentLinkedQueue<>(); // Canvas
     private void ensureActiveIsNotIterated() {
         // Paper - replace with better logic, do not delay removals
     }
@@ -36,13 +38,13 @@ public class EntityTickList {
         // Paper start - replace with better logic, do not delay removals/additions
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
-        io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+        Iterator<Entity> iterator = this.entities.iterator();
         try {
             while (iterator.hasNext()) {
                 action.accept(iterator.next());
             }
         } finally {
-            iterator.finishedIterating();
+            // iterator.finishedIterating();
         }
         // Paper end - replace with better logic, do not delay removals/additions
     }
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 106af2b2c7ff72c7549975aef75cdcff8d9a7d97..8ba2d45a9c81e8b86dbe594174fd60a2b408f53e 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -4,6 +4,7 @@ import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,7 +17,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
+    private final ConcurrentLinkedDeque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>(); // Canvas
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
     private int count = 0;
 
@@ -55,10 +56,11 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             if (bl) {
                 this.addedThisLayer.add(entry);
             } else {
+                if (entry == null) return; // Canvas
                 this.stack.push(entry);
             }
         } else if (this.count - 1 == this.maxChainedNeighborUpdates) {
-            LOGGER.error("Too many chained neighbor updates. Skipping the rest. First skipped position: " + pos.toShortString());
+            LOGGER.error("Too many chained neighbor updates. Skipping the rest. First skipped position: {}", pos.toShortString()); // Canvas
         }
 
         if (!bl) {
@@ -70,6 +72,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         try {
             while (!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
                 for (int i = this.addedThisLayer.size() - 1; i >= 0; i--) {
+                    if (this.addedThisLayer.get(i) == null) continue; // Canvas
                     this.stack.push(this.addedThisLayer.get(i));
                 }
 
@@ -78,7 +81,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
 
                 while (this.addedThisLayer.isEmpty()) {
                     if (!neighborUpdates.runNext(this.level)) {
+                        if (!this.stack.isEmpty()) { // Canvas
                         this.stack.pop();
+                        } // Canvas
                         break;
                     }
                 }
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index 2cdd18f724296f10cd4a522d1e8196723d39cf45..82d71f2f5459316d3cb22e41338d7de1afb6a716 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -9,6 +9,7 @@ import java.util.Optional;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.PriorityBlockingQueue;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -19,7 +20,7 @@ import net.minecraft.nbt.ListTag;
 import net.minecraft.world.level.ChunkPos;
 
 public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickContainerAccess<T> {
-    private final Queue<ScheduledTick<T>> tickQueue = new PriorityQueue<>(ScheduledTick.DRAIN_ORDER);
+    private final Queue<ScheduledTick<T>> tickQueue = new PriorityBlockingQueue<>(11, ScheduledTick.DRAIN_ORDER); // Canvas
     @Nullable
     private List<SavedTick<T>> pendingTicks;
     private final Set<ScheduledTick<?>> ticksPerPosition = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index a6d62abd3102770652f914b9d697c6d3c2533cfc..59a419eae9fc3cfe1060de2ce636cf186545d42d 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -11,11 +11,15 @@ import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 import java.util.LongSummaryStatistics;
+import java.util.Map;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.BiConsumer;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
@@ -32,10 +36,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
     private final LongPredicate tickCheck;
     private final Supplier<ProfilerFiller> profiler;
-    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
-    private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), map -> map.defaultReturnValue(Long.MAX_VALUE));
+    private final ConcurrentHashMap<Long, LevelChunkTicks<T>> allContainers = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Long, Long> nextTickForContainer = new ConcurrentHashMap<>();
     private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
-    private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
+    private final Queue<ScheduledTick<T>> toRunThisTick = new ConcurrentLinkedDeque<>(); // Canvas
     private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
@@ -100,12 +104,12 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void sortContainersToTick(long time) {
-        ObjectIterator<Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
+        Iterator<Map.Entry<Long, Long>> objectIterator = this.nextTickForContainer.entrySet().iterator();
 
         while (objectIterator.hasNext()) {
-            Entry entry = objectIterator.next();
-            long l = entry.getLongKey();
-            long m = entry.getLongValue();
+            Map.Entry<Long, Long> entry = objectIterator.next();
+            long l = entry.getKey();
+            long m = entry.getValue();
             if (m <= time) {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index d7f9c0c06cb150c91b270b4f5384a7eb53381fec..4cd6e10d8d9a8be2cb2b9c4c82c4a1f5a2c32085 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1193,6 +1193,7 @@ public final class CraftServer implements Server {
         org.spigotmc.SpigotConfig.registerCommands(); // Spigot
         io.papermc.paper.command.PaperCommands.registerCommands(this.console); // Paper
         org.purpurmc.purpur.PurpurConfig.registerCommands(); // Purpur
+        me.dueris.canvas.CanvasConfig.registerCommands(); // Canvas
         this.overrideAllCommandBlockCommands = this.commandsConfiguration.getStringList("command-block-overrides").contains("*");
         this.ignoreVanillaPermissions = this.commandsConfiguration.getBoolean("ignore-vanilla-permissions");
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c33c8eaddff22896093645d471feb145830640b6..4ef59d956be8ca1740e81d901e97f0e1c307f297 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -170,6 +170,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public int getEntityCount() {
         int ret = 0;
         for (net.minecraft.world.entity.Entity entity : world.getEntities().getAll()) {
+            if (entity == null) continue; // Canvas
             if (entity.isChunkLoaded()) {
                 ++ret;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ded27a775655ed1e5c1ee336abbe81fc64453cc4..5aa9e2cda8c9b61758d54f090cfb5297f7970778 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -32,6 +32,8 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
@@ -1001,20 +1003,20 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMultiBlockChange(final Map<? extends io.papermc.paper.math.Position, BlockData> blockChanges) {
         if (this.getHandle().connection == null) return;
 
-        Map<SectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState>> sectionMap = new HashMap<>();
+        Map<SectionPos, ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState>> sectionMap = new HashMap<>();
 
         for (Map.Entry<? extends io.papermc.paper.math.Position, BlockData> entry : blockChanges.entrySet()) {
             BlockData blockData = entry.getValue();
             BlockPos blockPos = io.papermc.paper.util.MCUtil.toBlockPos(entry.getKey());
             SectionPos sectionPos = SectionPos.of(blockPos);
 
-            it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState> sectionData = sectionMap.computeIfAbsent(sectionPos, key -> new it.unimi.dsi.fastutil.shorts.Short2ObjectArrayMap<>());
+            ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState> sectionData = sectionMap.computeIfAbsent(sectionPos, key -> new ConcurrentHashMap<>());
             sectionData.put(SectionPos.sectionRelativePos(blockPos), ((CraftBlockData) blockData).getState());
         }
 
-        for (Map.Entry<SectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState>> entry : sectionMap.entrySet()) {
+        for (Map.Entry<SectionPos, ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState>> entry : sectionMap.entrySet()) {
             SectionPos sectionPos = entry.getKey();
-            it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState> blockData = entry.getValue();
+            ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState> blockData = entry.getValue();
 
             net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket packet = new net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket(sectionPos, blockData);
             this.getHandle().connection.send(packet);
@@ -1058,10 +1060,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.sendBlockChanges(blocks);
     }
 
-    private record ChunkSectionChanges(ShortSet positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
+    private record ChunkSectionChanges(ConcurrentLinkedQueue<Short> positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
 
         public ChunkSectionChanges() {
-            this(new ShortArraySet(), new ArrayList<>());
+            this(new ConcurrentLinkedQueue(), new ArrayList<>());
         }
     }
 
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 6b0a3b49b4fc85d916faab26a5432d88ff56eae7..1e25d89f38af24c0eb20413d5b43762f8ba0ccb2 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -6,6 +6,8 @@ import java.lang.management.ThreadInfo;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+
 import org.bukkit.Bukkit;
 
 public final class WatchdogThread extends io.papermc.paper.util.TickThread // Paper - rewrite chunk system
@@ -47,7 +49,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
         log.log(Level.SEVERE, "Ticking entity: " + entityType + ", entity class: " + entity.getClass().getName());
         log.log(Level.SEVERE, "Entity status: removed: " + entity.isRemoved() + ", valid: " + entity.valid + ", alive: " + entity.isAlive() + ", is passenger: " + entity.isPassenger());
         log.log(Level.SEVERE, "Entity UUID: " + entityUUID);
-        log.log(Level.SEVERE, "Position: world: '" + (world == null ? "unknown world?" : world.getWorld().getName()) + "' at location (" + posX + ", " + posY + ", " + posZ + ")");
+        log.log(Level.SEVERE, "Position: world: '" + (world == null ? "unknown world?" : world.getTypeKey().toString()) + "' at location (" + posX + ", " + posY + ", " + posZ + ")"); // Canvas - show typekey instead of worldname
         log.log(Level.SEVERE, "Velocity: " + (mot == null ? "unknown velocity" : mot.toString()) + " (in blocks per tick)");
         log.log(Level.SEVERE, "Entity AABB: " + entity.getBoundingBox());
         if (moveVec != null) {
@@ -55,6 +57,31 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
             log.log(Level.SEVERE, "Start position: (" + moveStartX + ", " + moveStartY + ", " + moveStartZ + ")");
             log.log(Level.SEVERE, "Move vector: " + moveVec.toString());
         }
+        // Canvas - show thread report when dumping entities
+        if(((ServerLevel)entity.level()).currentTickingThread != null){ // Most likely actively ticking
+            log.log(Level.SEVERE, "------------------------------");
+            log.log(Level.SEVERE, "TickingThread found, dumping...");
+            log.log(Level.SEVERE, "------------------------------");
+            Thread thread = ((ServerLevel)entity.level()).currentTickingThread;
+            StackTraceElement[] elements = thread.getStackTrace();
+            log.log(Level.SEVERE, "Current Thread: " + thread.getName());
+            ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(thread.getId(), Integer.MAX_VALUE);
+            log.log(Level.SEVERE, "\tPID: " + threadInfo.getThreadId()
+                + " | Suspended: " + threadInfo.isSuspended()
+                + " | Native: " + threadInfo.isInNative()
+                + " | State: " + threadInfo.getThreadState());
+            if (threadInfo.getLockedMonitors().length != 0){
+                log.log(Level.SEVERE, "\tThread is waiting on monitor(s):");
+                for (MonitorInfo monitor : threadInfo.getLockedMonitors()){
+                    log.log(Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame());
+                }
+            }
+            log.log(Level.SEVERE, "\tStack:");
+            for (StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace())){
+                log.log( Level.SEVERE, "\t\t" + stack );
+            }
+        }
+        // Canvas end
     }
 
     private void dumpTickingInfo() {
@@ -134,17 +161,33 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
             WatchdogThread.instance.stopping = true;
         }
     }
+    private static final long TIME_THRESHOLD = 45_000_000_000L; // Canvas
 
     @Override
     public void run()
     {
         while ( !this.stopping )
         {
-            //
             // Paper start
             Logger log = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
             MinecraftServer server = MinecraftServer.getServer();
+            // Canvas start
+            long curTime = System.nanoTime();
+            server.getAllLevels().forEach(level -> {
+                long elapsedTime = curTime - level.currentTime;
+
+                    if (elapsedTime >= TIME_THRESHOLD && level.running) {
+                        log.log(Level.SEVERE, "------------------------------");
+                        log.log(Level.SEVERE, "Well it seems something went wrong! A ServerLevel is crashing, wonderful.");
+                        for (final StackTraceElement stackTraceElement : level.getStackTrace()) {
+                            log.log(Level.SEVERE, "\t\t" + stackTraceElement.toString());
+                        }
+                        this.dumpTickingInfo();
+                        log.log(Level.SEVERE, "------------------------------");
+                    }
+            });
+            // Canvas end
             if ( this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG) )) // Paper - add property to disable
             {
                 boolean isLongTimeout = currentTime > lastTick + timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > lastTick + 1000);
@@ -192,7 +235,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Canvas!):" ); // Paper // Purpur // Canvas
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
-                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+                // WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log ); // Canvas - rewrite watchdog during entity dumps
                 log.log( Level.SEVERE, "------------------------------" );
                 //
                 // Paper start - Only print full dump on long timeouts
@@ -263,7 +306,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
             }
         }
         log.log( Level.SEVERE, "\tStack:" );
-        //
+
         for ( StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace()) ) // Paper
         {
             log.log( Level.SEVERE, "\t\t" + stack );
