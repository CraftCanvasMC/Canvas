From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PurpleWolfMC <jedimastertoothless@hotmail.com>
Date: Tue, 21 May 2024 16:34:06 -0700
Subject: [PATCH] Better TickTask Scheduler


diff --git a/src/main/java/me/dueris/canvas/thread/ScheduledTask.java b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cc5415c50c9c6aaf143a8a29c6e4ae0ea58bff3
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/ScheduledTask.java
@@ -0,0 +1,25 @@
+package me.dueris.canvas.thread;
+
+public class ScheduledTask {
+    Runnable runnable;
+    boolean onMain;
+    TickTaskHolder.Timing timing;
+    
+    public ScheduledTask(Runnable runnable, boolean onMain, TickTaskHolder.Timing timing) {
+        this.runnable = runnable;
+        this.onMain = onMain;
+        this.timing = timing;
+    }
+
+    public boolean canRun(TickTaskHolder.Timing timing) {
+        return this.timing == timing;
+    }
+
+    public boolean serverLevel() {
+        return !this.onMain;
+    }
+
+    public void run() {
+        this.runnable.run();
+    }
+}
diff --git a/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ea37ab9d3df91bb7e3fca28f13134b9e9137083
--- /dev/null
+++ b/src/main/java/me/dueris/canvas/thread/TickTaskHolder.java
@@ -0,0 +1,15 @@
+package me.dueris.canvas.thread;
+
+import me.dueris.canvas.thread.TickTaskHolder.*;
+
+public interface TickTaskHolder {
+    public void scheduleTask(Runnable runnable, Timing timing, State state);
+
+    public static enum Timing {
+        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY;
+    }
+
+    public static enum State {
+        SERVER_LEVEL, MAIN;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b052e37d44c370bd19a339dadcc7da17319de5bc..3975333e5d9ce4266d4a0edadd8b0d6dba24461d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1908,6 +1908,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } catch (InterruptedException | ExecutionException e) {
             e.printStackTrace();
         }
+        // Run scheduled main thread tasks now
+        getAllLevels().forEach(Level::runMainThreadTasks);
         // Canvas end
 
         //this.profiler.popPush("connection"); // Purpur
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a7fe097334c2f07853335c1c04da6ad2539c75dd..3a9d866556bb79fc3f5d79385a75a63a127b3981 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -844,6 +844,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return new Pair<Runnable, ServerLevel>(() -> {
         this.handlingTick = true;
             if(this.currentTickingThread != Thread.currentThread()) {this.currentTickingThread = Thread.currentThread();}
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_TICK); // Canvas
             //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
             // Moved from MinecraftSever
                 final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
@@ -954,6 +955,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.PRE_ENTITY); // Canvas
             this.entityTickList.forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
@@ -981,6 +983,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     }
                 }
             });
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.POST_ENTITY); // Canvas
             //this.timings.entityTick.stopTiming(); // Spigot // Purpur
             //this.timings.tickEntities.stopTiming(); // Spigot // Purpur
             //gameprofilerfiller.pop(); // Purpur
@@ -995,6 +998,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             this.getChunkSource().tick(shouldKeepTicking, true);
             this.explosionDensityCache.clear();
+            /* new ArrayList<>(this.endTickTasks).forEach((r) -> { // Canvas - Use new tick timing system
+                r.run();
+                endTickTasks.remove(r);
+            }); */ // Canvas - Use new tick timing system
+            this.runAllWithTiming(me.dueris.canvas.thread.TickTaskHolder.Timing.END_TICK); // Canvas
             // Canvas end
         }, this); // Canvas
     }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 37ae1f287ba85c93205721fb19830f09198b7b00..fa53c38b9b5d1c2a7689e3a0a7ecb6c07c8f2252 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -26,6 +26,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import io.papermc.paper.util.MCUtil;
+import me.dueris.canvas.thread.ScheduledTask;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
@@ -101,7 +102,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level implements LevelAccessor, AutoCloseable, me.dueris.canvas.thread.TickTaskHolder { // Canvas
 
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
@@ -141,6 +142,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public java.util.concurrent.LinkedBlockingQueue<me.dueris.canvas.thread.ScheduledTask> scheduledTasks = new java.util.concurrent.LinkedBlockingQueue<>();
 
     // CraftBukkit start Added the following
     private final CraftWorld world;
@@ -229,6 +231,44 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public CraftServer getCraftServer() {
         return (CraftServer) Bukkit.getServer();
     }
+    // Canvas start - scheduler tasks
+
+    @Override
+    public void scheduleTask(Runnable runnable, Timing timing, State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(State.MAIN), timing));
+    }
+
+    public void runAllScheduledTasks() {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(ScheduledTask::serverLevel).forEach((task) -> {
+            // We ignore timings because we are executing all remaining tasks that should be executed on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public void runAllWithTiming(Timing timing) {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(s -> s.canRun(timing)).forEach((task) -> {
+            // Run the task on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public void runMainThreadTasks() {
+        new java.util.ArrayList<ScheduledTask>(this.scheduledTasks).stream().filter(s -> !s.serverLevel()).forEach((task) -> {
+            // Run the task on the ServerLevel thread
+            task.run();
+            // Remove it from the tasks that need to be executed
+            this.scheduledTasks.remove(task);
+        });
+    }
+
+    public ScheduledTask[] getMainThreadTasks() {
+        return (ScheduledTask[]) this.scheduledTasks.stream().filter(s -> !s.serverLevel()).toArray().clone();
+    }
+    // Canvas end
 
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
