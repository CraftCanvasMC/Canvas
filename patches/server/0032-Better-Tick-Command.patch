From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Sat, 4 Jan 2025 09:27:14 -0800
Subject: [PATCH] Better Tick Command


diff --git a/src/main/java/io/github/dueris/canvas/Config.java b/src/main/java/io/github/dueris/canvas/Config.java
index 24facbbc45d546521baa7f869ac75115b083db4b..da4980b343f1a800ce2e54ae431915ff2337cd35 100644
--- a/src/main/java/io/github/dueris/canvas/Config.java
+++ b/src/main/java/io/github/dueris/canvas/Config.java
@@ -25,6 +25,7 @@ public class Config implements ConfigData {
     public boolean optimizePistonMovingBlockEntity = true;
     public boolean clumpOrbs = true;
     public boolean useCompactSineLUT = true;
+    public boolean useCanvasTickCommand = true;
 
     public static Config init() {
         AutoConfig.register(Config.class, GsonConfigSerializer::new);
diff --git a/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java b/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java
index 40c13d4f2d807395e9bd8e7168fdc3e757205606..7726d236aced7bac14bb9b50dbcc489b8bf20d73 100644
--- a/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java
+++ b/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java
@@ -12,10 +12,6 @@ public final class CanvasCommands {
 
     private static final Map<String, Command> COMMANDS = new HashMap<>();
 
-    static {
-        COMMANDS.put("threadedtps", new ThreadedTpsCommand("threadedtps"));
-    }
-
     private CanvasCommands() {
     }
 
diff --git a/src/main/java/io/github/dueris/canvas/command/ThreadedTpsCommand.java b/src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java
similarity index 85%
rename from src/main/java/io/github/dueris/canvas/command/ThreadedTpsCommand.java
rename to src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java
index ae73b6ad8eac9eb339e44559dd0199120a9c63dc..d6aa0c6f2eda1dc9e3343d6fc1b356c3ca8d5a61 100644
--- a/src/main/java/io/github/dueris/canvas/command/ThreadedTpsCommand.java
+++ b/src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java
@@ -7,7 +7,6 @@ import java.lang.management.ThreadMXBean;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Function;
 import java.util.stream.Collectors;
@@ -15,7 +14,6 @@ import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.TextComponent;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
-import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -26,23 +24,18 @@ import static java.lang.String.valueOf;
 import static net.kyori.adventure.text.Component.text;
 import static net.kyori.adventure.text.format.TextColor.color;
 
-public class ThreadedTpsCommand extends Command {
+public class ThreadedTickDiagnosis {
     private static final List<String> TPS_OPTIONS = Arrays.asList("tps5", "tps10", "tps60");
     static int HEADER = 0x5FC3DD;
     static int VALUE = 0x96D6F0;
 
-    protected ThreadedTpsCommand(@NotNull final String name) {
-        super(name);
-    }
-
     public static @NotNull Double simplifyNumber(@NotNull Float num, boolean min) {
         DecimalFormat df = new DecimalFormat("###.##");
         double r = Double.parseDouble(df.format(num.doubleValue()));
         return min ? Math.min(r, 20.00) : r;
     }
 
-    @Override
-    public boolean execute(@NotNull final CommandSender sender, @NotNull final String commandLabel, @NotNull final String @NotNull [] args) {
+    public static boolean execute(@NotNull final CommandSender sender) {
         CraftServer server = (CraftServer) sender.getServer();
         float min;
         float max;
@@ -118,7 +111,7 @@ public class ThreadedTpsCommand extends Command {
         return true;
     }
 
-    public void sendCollective(@NotNull Function<List<TextComponent>, List<TextComponent>> builder, CommandSender sender) {
+    public static void sendCollective(@NotNull Function<List<TextComponent>, List<TextComponent>> builder, CommandSender sender) {
         Component base = Component.text("").appendNewline();
         for (final TextComponent textComponent : builder.apply(new ArrayList<>())) {
             base = base.append(textComponent).appendNewline();
@@ -126,26 +119,21 @@ public class ThreadedTpsCommand extends Command {
         sender.sendMessage(base);
     }
 
-    @Override
-    public @NotNull List<String> tabComplete(@NotNull final CommandSender sender, @NotNull final String alias, @NotNull final String @NotNull [] args) {
-        return Collections.emptyList();
-    }
-
-    private @NotNull TextComponent reportLine(String label, String value, int labelColor, int valueColor) {
+    private static @NotNull TextComponent reportLine(String label, String value, int labelColor, int valueColor) {
         return (text(label).color(color(labelColor))
             .append(text(value).color(color(valueColor))));
     }
 
-    private @NotNull TextComponent reportLine(String label, Component value, int labelColor) {
+    private static @NotNull TextComponent reportLine(String label, Component value, int labelColor) {
         return (text(label).color(color(labelColor)).append(value));
     }
 
-    private @NotNull TextComponent subReportLine(String label, String value, int labelColor, int valueColor) {
+    private static @NotNull TextComponent subReportLine(String label, String value, int labelColor, int valueColor) {
         return (text("   " + label).color(color(labelColor))
             .append(text(value).color(color(valueColor))));
     }
 
-    public int usingThreads() {
+    public static int usingThreads() {
         ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
         return (int) java.util.Arrays.stream(threadMXBean.getAllThreadIds())
             .mapToObj(threadMXBean::getThreadInfo)
@@ -153,7 +141,7 @@ public class ThreadedTpsCommand extends Command {
             .count();
     }
 
-    public Component createColoredUtilComponent(String text, float value) {
+    public static @NotNull Component createColoredUtilComponent(String text, float value) {
         float ratio = Math.max(0, Math.min(100, value)) / 100.0f;
         int red = (ratio <= 0.5) ? (int) (ratio * 510) : 255;
         int green = (ratio <= 0.5) ? 255 : (int) ((1.0f - ratio) * 510);
@@ -161,7 +149,7 @@ public class ThreadedTpsCommand extends Command {
         return text(text).color(color(red, green, 0));
     }
 
-    public Component createColoredComponent(String text, float value, float outOf) {
+    public static @NotNull Component createColoredComponent(String text, float value, float outOf) {
         float ratio = Math.max(0, Math.min(outOf, value)) / outOf;
         int red = (int) ((1 - ratio) * 255);
         int green = (int) (ratio * 255);
diff --git a/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java b/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java
index f44552f06f505fc64615e8af67ba4f8e912d99cd..e903c0fb9c1824c0c4a7707cabbcaa4d2bd1b257 100644
--- a/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java
+++ b/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java
@@ -6,6 +6,7 @@ import java.io.File;
 import java.io.IOException;
 import java.nio.file.Path;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.BooleanSupplier;
@@ -166,4 +167,7 @@ public class ThreadedServer {
         LOGGER.info("Removed level from threaded context: {}", level.dimension().location());
     }
 
+    public Collection<ServerLevel> getAllLevels() {
+        return MinecraftServer.getServer().levels.values();
+    }
 }
diff --git a/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java b/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java
index d02093b25fb4c8f9c45821b93dbef108efcd403a..0801d6cd725d85a871d13e4d9ab3a89332486203 100644
--- a/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java
+++ b/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java
@@ -329,4 +329,10 @@ public abstract class MinecraftServerWorld extends ReentrantBlockableEventLoop<T
             ((ServerPlayer) player).connection.send(packet);
         }
     }
+
+    @Override
+    public void skipTickWait() {
+        this.delayedTasksMaxNextTickTimeNanos = Util.getNanos();
+        this.nextTickTimeNanos = Util.getNanos();
+    }
 }
diff --git a/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java b/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java
index 02633c7342e9e3d4307763ab7b1cafbd97eab412..c59f6423f559e048ec2581f67adaf8566997447d 100644
--- a/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java
+++ b/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java
@@ -2,6 +2,7 @@ package io.github.dueris.canvas.server.level;
 
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.ServerTickRateManager;
 
 public interface TickRateManagerInstance {
     void broadcastPacketsToPlayers(Packet<?> packet);
@@ -9,4 +10,8 @@ public interface TickRateManagerInstance {
     CommandSourceStack createCommandSourceStack();
 
     void onTickRateChanged();
+
+    ServerTickRateManager tickRateManager();
+
+    void skipTickWait();
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index fb8be18a418c846cc9b4403775563373d3cd1e9e..dab719fb5620a36a05b4e7a359d784254b13b51b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -251,7 +251,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private String localIp;
     private int port;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels;
+    public Map<ResourceKey<Level>, ServerLevel> levels; // Canvas - private -> public
     private PlayerList playerList;
     private volatile boolean running;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
@@ -2884,7 +2884,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public float getCurrentSmoothedTickTime() {
         return this.smoothedTickTimeMillis;
     }
+    // Canvas start
 
+    @Override
+    public void skipTickWait() {
+        this.delayedTasksMaxNextTickTimeNanos = Util.getNanos();
+        this.nextTickTimeNanos = Util.getNanos();
+    }
+
+    @Override
+    // Canvas end
     public ServerTickRateManager tickRateManager() {
         return this.tickRateManager;
     }
diff --git a/src/main/java/net/minecraft/server/ServerTickRateManager.java b/src/main/java/net/minecraft/server/ServerTickRateManager.java
index 65de1de0cab5bd1b8d6aedf2013cffa915c1977e..3d00a538dc38bd1a2189051f29aad8b5a94b5c77 100644
--- a/src/main/java/net/minecraft/server/ServerTickRateManager.java
+++ b/src/main/java/net/minecraft/server/ServerTickRateManager.java
@@ -133,4 +133,16 @@ public class ServerTickRateManager extends TickRateManager {
         player.connection.send(ClientboundTickingStatePacket.from(this));
         player.connection.send(ClientboundTickingStepPacket.from(this));
     }
+    // Canvas start
+
+    private boolean unlocked = false;
+
+    public void toggleUnlockTickRate(boolean unlocked) {
+        this.unlocked = unlocked;
+    }
+
+    public boolean isUnlockedTickRate() {
+        return unlocked;
+    }
+    // Canvas end
 }
diff --git a/src/main/java/net/minecraft/server/commands/TickCommand.java b/src/main/java/net/minecraft/server/commands/TickCommand.java
index 13d96b54f48d60b098b80e04ba6168762c335c75..84d76c64e7b304c18ba47fa7817160736c38ce16 100644
--- a/src/main/java/net/minecraft/server/commands/TickCommand.java
+++ b/src/main/java/net/minecraft/server/commands/TickCommand.java
@@ -1,23 +1,161 @@
 package net.minecraft.server.commands;
 
 import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.Message;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.command.ThreadedTickDiagnosis;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.commands.SharedSuggestionProvider;
 import net.minecraft.commands.arguments.TimeArgument;
+import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.TimeUtil;
+import org.jetbrains.annotations.NotNull;
 
 public class TickCommand {
     private static final float MAX_TICKRATE = 10000.0F;
     private static final String DEFAULT_TICKRATE = String.valueOf(20);
+    // Canvas start
+    private static final String UNCAPPED_TICKRATE = String.valueOf(-1);
+    private static final String[] RATE_SUGGESTIONS = new String[]{DEFAULT_TICKRATE, UNCAPPED_TICKRATE};
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        if (Config.INSTANCE.useCanvasTickCommand) {
+            dispatcher.register(
+                Commands.literal("threadedtick")
+                    .requires(source -> source.hasPermission(3))
+                    .then(Commands.literal("diagnosis").executes(context -> {
+                        CommandSourceStack commandSourceStack = context.getSource();
+                        ThreadedTickDiagnosis.execute(commandSourceStack.getBukkitSender());
+                        return 1;
+                    }))
+                    .then(
+                        Commands.argument("threadstate", StringArgumentType.word())
+                            .suggests((_, builder) -> SharedSuggestionProvider.suggest(getThreadStates(), builder))
+                                .then(Commands.literal("rate")
+                                    .then(Commands.argument("rate", FloatArgumentType.floatArg(-1.0F, 10000.0F))
+                                            .suggests((_, suggestionsBuilder) -> SharedSuggestionProvider.suggest(RATE_SUGGESTIONS, suggestionsBuilder)).executes(context -> {
+                                                float rate = FloatArgumentType.getFloat(context, "rate");
+                                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                                    if (rate == -1) {
+                                                        serverTickRateManager.toggleUnlockTickRate(true);
+                                                    } else if (rate > 0) {
+                                                        serverTickRateManager.setTickRate(rate);
+                                                    }
+                                                });
+                                                if (rate == -1) {
+                                                    context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate."), true);
+                                                } else if (rate > 0) {
+                                                    String string = String.format(Locale.ROOT, "%.1f", rate);
+                                                    context.getSource().sendSuccess(() -> Component.translatable("commands.tick.rate.success", string), true);
+                                                }
+                                                return 1;
+                                            })
+                                    )
+                                )
+                                .then(Commands.literal("unbind").executes(context -> {
+                                    execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                        serverTickRateManager.toggleUnlockTickRate(true);
+                                    });
+                                    context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate on thread(s)."), true);
+                                    return 1;
+                                }))
+                                .then(Commands.literal("rebind").executes(context -> {
+                                    execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                        serverTickRateManager.toggleUnlockTickRate(false);
+                                    });
+                                    context.getSource().sendSuccess(() -> Component.literal("Rebound tickrate to thread(s)."), true);
+                                    return 1;
+                                }))
+                                .then(Commands.literal("unfreeze").executes(context -> {
+                                    boolean frozen = false;
+                                    execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                        serverTickRateManager.setFrozen(frozen);
+                                        context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.running"), true);
+                                    });
+                                    return 1;
+                                }))
+                                .then(Commands.literal("freeze").executes(context -> {
+                                    boolean frozen = true;
+                                    execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                        if (serverTickRateManager.isSprinting()) {
+                                            serverTickRateManager.stopSprinting();
+                                        }
+
+                                        if (serverTickRateManager.isSteppingForward()) {
+                                            serverTickRateManager.stopStepping();
+                                        }
+
+                                        serverTickRateManager.setFrozen(frozen);
+                                        context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.frozen"), true);
+                                    });
+                                    return 1;
+                                }))
+                            )
+                    );
+        }
+        tickCommand(dispatcher);
+    }
+
+    public static void execute(@NotNull String state, Consumer<ServerTickRateManager> action) throws CommandSyntaxException {
+        if (state.equalsIgnoreCase("global")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+            for (final ServerLevel level : MinecraftServer.getThreadedServer().getAllLevels()) {
+                action.accept((ServerTickRateManager) level.tickRateManager());
+            }
+        } else if (state.equalsIgnoreCase("main")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+        } else {
+            if (!state.contains(":")) {
+                Message message = Component.literal("State isn't valid or known: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            ResourceLocation location = ResourceLocation.parse(state);
+            ServerLevel level = MinecraftServer.getServer().getLevel(ResourceKey.create(Registries.DIMENSION, location));
+            if (level == null) {
+                Message message = Component.literal("Couldn't build level: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            action.accept((ServerTickRateManager) level.tickRateManager());
+        }
+    }
+
+    private static String[] getThreadStates() {
+        List<String> states = new ArrayList<>();
+        states.add("global");
+        states.add("main");
+        states.addAll(MinecraftServer.getThreadedServer().getAllLevels()
+            .stream()
+            .map(ServerLevel::dimension)
+            .map(ResourceKey::location)
+            .map(ResourceLocation::toString).collect(Collectors.toSet()));
+        return states.toArray(new String[0]);
+    }
+
+    /**
+     * @deprecated Use threadedtick command instead of this. This runs on a global
+     * state, while threadedtick can be more powerful for specific contexts.
+     */
+    @Deprecated(forRemoval = true)
+    private static void tickCommand(CommandDispatcher<CommandSourceStack> dispatcher) {
+    // Canvas end
         dispatcher.register(
             Commands.literal("tick")
                 .requires(source -> source.hasPermission(3))
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index b597334eed9d7a3b08bb17bd067fc5e5021b4a73..000e2d6f13ab8aaaf002f3124d270664e2000ca4 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -88,6 +88,7 @@ import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerConnectionListener;
@@ -2317,8 +2318,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     @Override
-    public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+    public ServerTickRateManager tickRateManager() { // Canvas
+        return this.tickRateManager; // Canvas
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index c811d9defc456d93943caa99c895a390aa911179..e985b6bdaabfe26b1ca675d5c704544392a8e773 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -15,6 +15,7 @@ import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import javax.annotation.CheckReturnValue;
 import io.github.dueris.canvas.server.level.MinecraftServerWorld;
+import io.github.dueris.canvas.server.level.TickRateManagerInstance;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
 import net.minecraft.server.MinecraftServer;
@@ -155,7 +156,15 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         try {
             while (!stopCondition.getAsBoolean()) {
                 if (!this.pollTask()) {
+                    // Canvas start
+                    if (this instanceof TickRateManagerInstance tickRateManagerInstance && !tickRateManagerInstance.tickRateManager().isUnlockedTickRate()) {
                     this.waitForTasks();
+                    } else if (this instanceof TickRateManagerInstance tickRateManagerInstance) {
+                        // Skipping because unlocked
+                        tickRateManagerInstance.skipTickWait();
+                        break;
+                    }
+                    // Canvas end
                 }
             }
         } finally {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 3b9ee2b5049c427780ca6b293422959c1b720964..97ec073a21b30ccd19a5d4a2d9c1c5bcdb344d31 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -26,6 +26,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
@@ -1865,7 +1866,7 @@ public abstract class Level extends MinecraftServerWorld implements LevelAccesso
         return this.levelData;
     }
 
-    public abstract TickRateManager tickRateManager();
+    public abstract ServerTickRateManager tickRateManager(); // Canvas
 
     public float getThunderLevel(float delta) {
         return Mth.lerp(delta, this.oThunderLevel, this.thunderLevel) * this.getRainLevel(delta);
