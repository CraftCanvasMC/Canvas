From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Fri, 10 Jan 2025 19:51:15 -0800
Subject: [PATCH] Threaded Dimensions


diff --git a/build.gradle.kts b/build.gradle.kts
index bf1eccdc5b4553f2b25a3049c468a35e64cce3dc..795ff47f075eff2699819a0cc6bac799682b0c0e 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -43,7 +43,7 @@ dependencies {
     log4jPlugins.annotationProcessorConfigurationName("org.apache.logging.log4j:log4j-core:2.19.0") // Paper - Needed to generate meta for our Log4j plugins
     runtimeOnly(log4jPlugins.output)
     alsoShade(log4jPlugins.output)
-    implementation("io.netty:netty-codec-haproxy:4.1.97.Final") // Paper - Add support for proxy protocol
+    implementation("io.netty:netty-codec-haproxy:4.2.0.RC1") // Paper - Add support for proxy protocol // Canvas - bump netty
     // Paper end
     implementation("org.apache.logging.log4j:log4j-iostreams:2.24.1") // Paper - remove exclusion
     implementation("org.ow2.asm:asm-commons:9.7.1")
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java b/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
index 2e876b918672e8ef3b5197b7e6b1597247fdeaa1..7a4fd6a1762bba8ed784eaebc45b64f3970f8bf9 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
@@ -1,17 +1,20 @@
 package ca.spottedleaf.moonrise.common.list;
 
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntMaps;
 import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicInteger;
 
 public final class ReferenceList<E> implements Iterable<E> {
 
     private static final Object[] EMPTY_LIST = new Object[0];
 
-    private final Reference2IntOpenHashMap<E> referenceToIndex;
+    private final Reference2IntMap<E> referenceToIndex; // Canvas
     private E[] references;
-    private int count;
+    private final AtomicInteger count = new AtomicInteger(); // Canvas - atomic
 
     public ReferenceList() {
         this((E[])EMPTY_LIST);
@@ -19,22 +22,22 @@ public final class ReferenceList<E> implements Iterable<E> {
 
     public ReferenceList(final E[] referenceArray) {
         this.references = referenceArray;
-        this.referenceToIndex = new Reference2IntOpenHashMap<>(2, 0.8f);
+        this.referenceToIndex = Reference2IntMaps.synchronize(new Reference2IntOpenHashMap<>(2, 0.8f)); // Canvas
         this.referenceToIndex.defaultReturnValue(Integer.MIN_VALUE);
     }
 
     private ReferenceList(final E[] references, final int count, final Reference2IntOpenHashMap<E> referenceToIndex) {
         this.references = references;
-        this.count = count;
+        this.count.set(count); // Canvas - atomic
         this.referenceToIndex = referenceToIndex;
     }
 
     public ReferenceList<E> copy() {
-        return new ReferenceList<>(this.references.clone(), this.count, this.referenceToIndex.clone());
+        return new ReferenceList<>(this.references.clone(), this.count.get(), new Reference2IntOpenHashMap<>(this.referenceToIndex)); // Canvas // - atomic
     }
 
     public int size() {
-        return this.count;
+        return this.count.get(); // Canvas - atomic
     }
 
     public boolean contains(final E obj) {
@@ -48,7 +51,13 @@ public final class ReferenceList<E> implements Iterable<E> {
         }
 
         // move the object at the end to this index
-        final int endIndex = --this.count;
+        // Canvas start - convert count to atomic, set count to 0 if endIndex < 0
+        int endIndex = this.count.decrementAndGet();
+        if(endIndex < 0) {
+            this.count.set(0);
+            endIndex = 0;
+        }
+        // Canvas end
         final E end = (E)this.references[endIndex];
         if (index != endIndex) {
             // not empty after this call
@@ -61,7 +70,7 @@ public final class ReferenceList<E> implements Iterable<E> {
     }
 
     public boolean add(final E obj) {
-        final int count = this.count;
+        final int count = this.count.get(); // Canvas - atomic
         final int currIndex = this.referenceToIndex.putIfAbsent(obj, count);
 
         if (currIndex != Integer.MIN_VALUE) {
@@ -76,13 +85,13 @@ public final class ReferenceList<E> implements Iterable<E> {
         }
 
         list[count] = obj;
-        this.count = count + 1;
+        this.count.set(count + 1); // Canvas - atomic
 
         return true;
     }
 
     public E getChecked(final int index) {
-        if (index < 0 || index >= this.count) {
+        if (index < 0 || index >= this.count.get()) { // Canvas - atomic
             throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
         }
         return this.references[index];
@@ -102,8 +111,8 @@ public final class ReferenceList<E> implements Iterable<E> {
 
     public void clear() {
         this.referenceToIndex.clear();
-        Arrays.fill(this.references, 0, this.count, null);
-        this.count = 0;
+        Arrays.fill(this.references, 0, this.count.get(), null); // Canvas - atomic
+        this.count.set(0); // Canvas - atomic
     }
 
     @Override
@@ -114,12 +123,12 @@ public final class ReferenceList<E> implements Iterable<E> {
 
             @Override
             public boolean hasNext() {
-                return this.current < ReferenceList.this.count;
+                return this.current < ReferenceList.this.count.get(); // Canvas - atomic
             }
 
             @Override
             public E next() {
-                if (this.current >= ReferenceList.this.count) {
+                if (this.current >= ReferenceList.this.count.get()) { // Canvas - atomic
                     throw new NoSuchElementException();
                 }
                 return this.lastRet = ReferenceList.this.references[this.current++];
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index d21ce54ebb5724c04eadf56a2cde701d5eeb5db2..d9fad142bded299cb185ddb58adf2438459e65d2 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -28,6 +28,10 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 
 public final class ChunkEntitySlices {
@@ -40,9 +44,11 @@ public final class ChunkEntitySlices {
 
     private final EntityCollectionBySection allEntities;
     private final EntityCollectionBySection hardCollidingEntities;
-    private final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    private final Reference2ObjectOpenHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
-    private final EntityList entities = new EntityList();
+    // Canvas start - use concurrent equivalent
+    private final ConcurrentHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+    private final ConcurrentHashMap<EntityType<?>, EntityCollectionBySection> entitiesByType;
+    private final List<Entity> entities = new CopyOnWriteArrayList<>();
+    // Canvas end
 
     public FullChunkStatus status;
     public final ChunkData chunkData;
@@ -67,8 +73,10 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
-        this.entitiesByType = new Reference2ObjectOpenHashMap<>();
+        // Canvas start - use concurrent equivalent
+        this.entitiesByClass = new ConcurrentHashMap<>();
+        this.entitiesByType = new ConcurrentHashMap<>();
+        // Canvas end
 
         this.status = status;
         this.chunkData = chunkData;
@@ -134,7 +142,7 @@ public final class ChunkEntitySlices {
             return null;
         }
 
-        final Entity[] rawData = this.entities.getRawData();
+        final Entity[] rawData = this.entities.toArray(new Entity[0]);
         final List<Entity> collectedEntities = new ArrayList<>(len);
         for (int i = 0; i < len; ++i) {
             final Entity entity = rawData[i];
@@ -153,7 +161,7 @@ public final class ChunkEntitySlices {
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
         final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+        final Entity[] collectedEntities = Arrays.copyOf(this.entities.toArray(new Entity[0]), len);
 
         for (int i = 0; i < len; ++i) {
             final Entity entity = collectedEntities[i];
@@ -182,7 +190,7 @@ public final class ChunkEntitySlices {
             return new ArrayList<>();
         }
 
-        final Entity[] rawData = this.entities.getRawData();
+        final Entity[] rawData = this.entities.toArray(new Entity[0]);
         final List<Entity> collectedEntities = new ArrayList<>(len);
         for (int i = 0; i < len; ++i) {
             collectedEntities.add(rawData[i]);
@@ -196,7 +204,7 @@ public final class ChunkEntitySlices {
     }
 
     public void mergeInto(final ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
+        final Entity[] entities = this.entities.toArray(new Entity[0]);
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
             final Entity entity = entities[i];
             slices.addEntity(entity, ((ChunkSystemEntity)entity).moonrise$getSectionY());
@@ -221,7 +229,7 @@ public final class ChunkEntitySlices {
     public void updateStatus(final FullChunkStatus status, final EntityLookup lookup) {
         this.status = status;
 
-        final Entity[] entities = this.entities.getRawData();
+        final Entity[] entities = this.entities.toArray(new Entity[0]);
 
         for (int i = 0, size = this.entities.size(); i < size; ++i) {
             final Entity entity = entities[i];
@@ -248,10 +256,7 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().addEntity(entity, sectionIndex);
             }
@@ -282,10 +287,7 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().removeEntity(entity, sectionIndex);
             }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index 7554c109c35397bc1a43dd80e87764fd78645bbf..ce56130201025457d7aad64740b9e5d59adb1dea 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -8,6 +8,7 @@ import ca.spottedleaf.moonrise.common.util.WorldUtil;
 import ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -30,6 +31,7 @@ import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -190,6 +192,12 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             return Arrays.copyOf(this.accessibleEntities.getRawData(), this.accessibleEntities.size(), Entity[].class);
         }
     }
+    // Canvas start
+
+    public int entityCount() {
+        return this.accessibleEntities.size();
+    }
+    // Canvas end
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AbortableIterationConsumer<U> action) {
@@ -226,6 +234,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             }
         }
     }
+    private ConcurrentLinkedQueue<Runnable> statusChangesQue = new ConcurrentLinkedQueue<>(); // Canvas
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
@@ -233,14 +242,15 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
         if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
             // recursive status update
-            LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
+            // LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable()); // Canvas - silence.
             return;
         }
 
         final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
 
         if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            // LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable()); // Canvas
+            statusChangesQue.add(() -> entityStatusChange(entity, slices, oldVisibility, newVisibility, moved, created, destroyed)); // Canvas
             return;
         }
 
@@ -322,6 +332,11 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         } finally {
             if (slices != null) {
                 slices.stopPreventingStatusUpdates(false);
+                // Canvas start
+                ConcurrentLinkedQueue<Runnable> clone = new ConcurrentLinkedQueue<>(statusChangesQue);
+                statusChangesQue.clear();
+                clone.forEach(Runnable::run);
+                // Canvas end
             }
         }
     }
@@ -474,7 +489,13 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
         } else {
             if (slices.isPreventingStatusUpdates()) {
-                throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas start
+               ((ServerLevel)entity.level()).taskScheduler.schedule(() -> {
+                    removeEntity(entity);
+                });
+                return;
+                // throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas end
             }
             if (!slices.removeEntity(entity, sectionY)) {
                 LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
@@ -510,7 +531,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         }
     }
 
-    protected ChunkEntitySlices moveEntity(final Entity entity) {
+    protected synchronized ChunkEntitySlices moveEntity(final Entity entity) { // Canvas
         // ensure we own the entity
         this.checkThread(entity, "Cannot move entity off-main");
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index dd2509996bfd08e8c3f9f2be042229eac6d7692d..02f2e84e8de17365169a2535a7d36d6b741d4e57 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -16,6 +16,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManage
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonObject;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
@@ -39,6 +40,7 @@ import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -301,7 +303,7 @@ public final class RegionizedPlayerChunkLoader {
         return false;
     }
 
-    public void tick() {
+    public synchronized void tick() { // Canvas
         TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.players())) {
@@ -341,8 +343,8 @@ public final class RegionizedPlayerChunkLoader {
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+        private final ConcurrentSet<Long> sentChunks = new ConcurrentSet<>(); // Canvas - use concurrent equivalent
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -486,7 +488,7 @@ public final class RegionizedPlayerChunkLoader {
             }
 
             @Override
-            protected void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) {
+            protected synchronized void removeCallback(final PlayerChunkLoaderData parameter, final int chunkX, final int chunkZ) { // Canvas
                 final long chunk = CoordinateUtils.getChunkKey(chunkX, chunkZ);
                 // note: by the time this is called, the tick cleanup should have ran - so, if the chunk is at
                 // the tick stage it was deemed in range for loading. Thus, we need to move it to generated
@@ -620,7 +622,7 @@ public final class RegionizedPlayerChunkLoader {
             return Math.max(Math.abs(dx), Math.abs(dz)) <= this.lastTickDistance;
         }
 
-        private boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) {
+        private synchronized boolean areNeighboursGenerated(final int chunkX, final int chunkZ, final int radius) { // Canvas
             for (int dz = -radius; dz <= radius; ++dz) {
                 for (int dx = -radius; dx <= radius; ++dx) {
                     if ((dx | dz) == 0) {
@@ -639,7 +641,7 @@ public final class RegionizedPlayerChunkLoader {
             return true;
         }
 
-        void updateQueues(final long time) {
+        synchronized void updateQueues(final long time) { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
@@ -906,7 +908,7 @@ public final class RegionizedPlayerChunkLoader {
             );
         }
 
-        void update() {
+        synchronized void update() { // Canvas
             TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
@@ -1086,7 +1088,7 @@ public final class RegionizedPlayerChunkLoader {
         }
 
         public LongOpenHashSet getSentChunksRaw() {
-            return this.sentChunks;
+            return new LongOpenHashSet(this.sentChunks); // Canvas
         }
     }
 }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 3990834a41116682d6ae779a3bf24b0fd989d97d..773a0bc946b800a36953004fedac02fd762b2446 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -21,6 +21,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.util.ChunkSystemSortedArrayS
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.util.ConcurrentLinkedDequeTree;
 import it.unimi.dsi.fastutil.longs.Long2ByteLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -47,10 +48,12 @@ import java.text.DecimalFormat;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.PrimitiveIterator;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -81,27 +84,8 @@ public final class ChunkHolderManager {
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
-        }
-
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
-
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
-        }
-
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
-
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
-        }
-
-        return Long.compare(coord1, coord2);
-    });
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas - use concurrent equivalent
+    private final ConcurrentLinkedDequeTree<NewChunkHolder> autoSaveQueue = new ConcurrentLinkedDequeTree<>(); // Canvas - use our version
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -1034,7 +1018,7 @@ public final class ChunkHolderManager {
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final Deque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1042,7 +1026,7 @@ public final class ChunkHolderManager {
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1382,7 +1366,7 @@ public final class ChunkHolderManager {
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
diff --git a/src/main/java/io/github/dueris/canvas/Config.java b/src/main/java/io/github/dueris/canvas/Config.java
index b27d93400e3d8d7b81acea9784e1287f009d861a..7e6f124f120733114850d9e7058b946e2b245065 100644
--- a/src/main/java/io/github/dueris/canvas/Config.java
+++ b/src/main/java/io/github/dueris/canvas/Config.java
@@ -3,6 +3,7 @@ package io.github.dueris.canvas;
 import me.shedaniel.autoconfig.AutoConfig;
 import me.shedaniel.autoconfig.ConfigData;
 import me.shedaniel.autoconfig.serializer.JanksonConfigSerializer;
+import me.shedaniel.cloth.clothconfig.shadowed.blue.endless.jankson.Comment;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.jetbrains.annotations.NotNull;
@@ -16,6 +17,24 @@ public class Config implements ConfigData {
 	private static final Logger LOGGER = LogManager.getLogger("CanvasConfig");
 	public static Config INSTANCE = new Config();
 
+    // Threaded Dimensions
+    @Comment("Determines if the server should tick the playerlist assigned to each world on their own level threads, or if it should tick on the main thread(globally)")
+    public boolean runPlayerListTickOnIndependentLevel = true;
+    @Comment("Determines if the server should schedule auto-saves off-main, and have each level run its autosave on its own thread")
+    public boolean runAutoSaveThreaded = true;
+    @Comment("Amount of ticks until the level will resync time with the player")
+    public int timeResyncInterval = 20;
+    @Comment("Thread priority for level threads, must be a value between 1-10.")
+    public int levelThreadPriority = 9;
+    @Comment("In the ServerChunkCache, it schedules tasks to the main thread. Enabling this changes it to schedule to the level thread")
+    public boolean useLevelThreadsAsChunkSourceMain = true;
+    @Comment("Disables leaves from ticking")
+    public boolean disableLeafTicking = true;
+    @Comment("Enables each world to have the \"empty server\" logic per world introduced in Minecraft 1.21.4")
+    public boolean emptySleepPerWorlds = true;
+    @Comment("Enables the \"threadedtick\" command, which is an implementation of the vanilla \"tick\" command for the Canvas threaded context")
+    public boolean enableCanvasTickCommand = true;
+
 	public static Config init() {
 		AutoConfig.register(Config.class, JanksonConfigSerializer::new);
 		INSTANCE = AutoConfig.getConfigHolder(Config.class).getConfig();
diff --git a/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java b/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..7726d236aced7bac14bb9b50dbcc489b8bf20d73
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/command/CanvasCommands.java
@@ -0,0 +1,21 @@
+package io.github.dueris.canvas.command;
+
+import java.util.HashMap;
+import java.util.Map;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class CanvasCommands {
+
+    private static final Map<String, Command> COMMANDS = new HashMap<>();
+
+    private CanvasCommands() {
+    }
+
+    public static void registerCommands(final MinecraftServer server) {
+        COMMANDS.forEach((s, command) -> server.server.getCommandMap().register(s, "Canvas", command));
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java b/src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc2f5796c081c1c09731898f3a4cc8e2d33f182d
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/command/ThreadedTickDiagnosis.java
@@ -0,0 +1,161 @@
+package io.github.dueris.canvas.command;
+
+import ca.spottedleaf.moonrise.common.util.MoonriseCommon;
+import io.netty.util.Version;
+import io.papermc.paper.command.MSPTCommand;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Function;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.SpigotConfig;
+
+import static java.lang.String.valueOf;
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.TextColor.color;
+
+public class ThreadedTickDiagnosis {
+    private static final List<String> TPS_OPTIONS = Arrays.asList("tps5", "tps10", "tps60");
+    static int HEADER = 0x5FC3DD;
+    static int VALUE = 0x96D6F0;
+
+    public static @NotNull Double simplifyNumber(@NotNull Float num, boolean min) {
+        DecimalFormat df = new DecimalFormat("###.##");
+        double r = Double.parseDouble(df.format(num.doubleValue()).replace(",", "."));
+        return min ? Math.min(r, 20.00) : r;
+    }
+
+    public static boolean execute(@NotNull final CommandSender sender) {
+        CraftServer server = (CraftServer) sender.getServer();
+        float min;
+        float max;
+        float median;
+
+        List<Double> tpsValues = MinecraftServer.getThreadedServer().getThreadedWorlds().stream()
+            .map(level -> level.recentTps[1])
+            .sorted().toList();
+
+        if (!tpsValues.isEmpty()) {
+            min = tpsValues.getFirst().floatValue();
+            max = tpsValues.getLast().floatValue();
+            median = tpsValues.size() % 2 == 0
+                ? (float) ((tpsValues.get(tpsValues.size() / 2 - 1) + tpsValues.get(tpsValues.size() / 2)) / 2.0)
+                : tpsValues.get(tpsValues.size() / 2).floatValue();
+        } else {
+            min = max = median = 0.0f;
+        }
+
+        sendCollective((l) -> {
+            TextComponent base = text("").color(color(0x4EA2ED));
+            TextComponent header = text("==================================")
+                .color(color(0x2F8FE9));
+
+            l.add(header);
+            l.add(base.append(text("Server Status Report").color(color(HEADER))));
+
+            l.add(reportLine(" Online Players: ", valueOf(server.getOnlinePlayers().size()), 0x4EA2ED, 0x2F8FE9));
+            l.add(reportLine(" Lowest Thread TPS: ", createColoredComponent(simplifyNumber(min, true).toString(), min, 20F), 0x4EA2ED));
+            l.add(reportLine(" Median Thread TPS: ", createColoredComponent(simplifyNumber(median, true).toString(), median, 20F), 0x4EA2ED));
+            l.add(reportLine(" Highest Thread TPS: ", createColoredComponent(simplifyNumber(max, true).toString(), max, 20F), 0x4EA2ED));
+            l.add(reportLine(" MinecraftServer MSPT: ", MSPTCommand.getColor(MinecraftServer.getServer().tickTimes5s.getAverage()), 0x4EA2ED));
+
+            l.add(header);
+
+            l.add(base.append(text(" Thread Analysis").color(color(HEADER))));
+            l.add(reportLine(" Netty Version: ", valueOf(Version.identify().get("netty-common")), 0x4EA2ED, 0x2F8FE9));
+            l.add(reportLine(" MAX Available threads: ", valueOf(Runtime.getRuntime().availableProcessors()), 0x4EA2ED, 0x2F8FE9));
+            l.add(reportLine(" Current Available threads: ", valueOf(Runtime.getRuntime().availableProcessors() - usingThreads()), 0x4EA2ED, 0x2F8FE9));
+
+            l.add(base.append(text(" Util ThreadCount:").color(color(0x4EA2ED))));
+            l.add(subReportLine("NettyIO: ", valueOf(SpigotConfig.getInt("settings.netty-threads", 4)), 0x2F8FE9, VALUE));
+            l.add(subReportLine("Moonrise Workers: ", valueOf(MoonriseCommon.WORKER_POOL.getCoreThreads().length), 0x2F8FE9, VALUE));
+
+            l.add(header);
+
+            for (ServerLevel level : MinecraftServer.getThreadedServer().getThreadedWorlds()) {
+                int chunkCount = level.getChunkSource().getLoadedChunksCount();
+                int playerCount = level.players().size();
+                int entityCount = level.moonrise$getEntityLookup().getEntityCount();
+
+                l.add(base.append(text(" - ThreadedLevel [")
+                    .append(text(level.dimension().location().toString()).color(color(0x96D6F0)))
+                    .append(text("]").color(color(0x4EA2ED)))));
+
+                l.add(base.append(Component.text("   ")).append(MSPTCommand.getColor(level.getNanoSecondsFromLastTick() / 1_000_000)
+                    .append(text(" MSPT at "))
+                    .append(createColoredComponent(simplifyNumber((float) level.recentTps[0], true).toString(), (float) level.recentTps[0], 20F))
+                    .append(text(" TPS"))));
+
+                float threadUtil = (float) (((level.getNanoSecondsFromLastTick() / 1_000_000.0) / 50) * 100);
+                if (threadUtil > 100) threadUtil = 100;
+
+                l.add(base.append(text("   Chunks: ")
+                    .append(text(valueOf(chunkCount)).color(color(VALUE)))
+                    .append(text(" Players: ").append(text(valueOf(playerCount)).color(color(VALUE))))
+                    .append(text(" Entities: ").append(text(valueOf(entityCount)).color(color(VALUE))))
+                    .append(text(" Thread Utilization: ").append(createColoredUtilComponent(simplifyNumber(threadUtil, false) + "%", threadUtil)))));
+            }
+
+            l.add(header);
+            return l;
+        }, sender);
+        return true;
+    }
+
+    public static void sendCollective(@NotNull Function<List<TextComponent>, List<TextComponent>> builder, CommandSender sender) {
+        Component base = Component.text("").appendNewline();
+        for (final TextComponent textComponent : builder.apply(new ArrayList<>())) {
+            base = base.append(textComponent).appendNewline();
+        }
+        sender.sendMessage(base);
+    }
+
+    private static @NotNull TextComponent reportLine(String label, String value, int labelColor, int valueColor) {
+        return (text(label).color(color(labelColor))
+            .append(text(value).color(color(valueColor))));
+    }
+
+    private static @NotNull TextComponent reportLine(String label, Component value, int labelColor) {
+        return (text(label).color(color(labelColor)).append(value));
+    }
+
+    private static @NotNull TextComponent subReportLine(String label, String value, int labelColor, int valueColor) {
+        return (text("   " + label).color(color(labelColor))
+            .append(text(value).color(color(valueColor))));
+    }
+
+    public static int usingThreads() {
+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
+        return (int) java.util.Arrays.stream(threadMXBean.getAllThreadIds())
+            .mapToObj(threadMXBean::getThreadInfo)
+            .filter(threadInfo -> threadInfo != null && threadInfo.getThreadState() == Thread.State.RUNNABLE)
+            .count();
+    }
+
+    public static @NotNull Component createColoredUtilComponent(String text, float value) {
+        float ratio = Math.max(0, Math.min(100, value)) / 100.0f;
+        int red = (ratio <= 0.5) ? (int) (ratio * 510) : 255;
+        int green = (ratio <= 0.5) ? 255 : (int) ((1.0f - ratio) * 510);
+
+        return text(text).color(color(red, green, 0));
+    }
+
+    public static @NotNull Component createColoredComponent(String text, float value, float outOf) {
+        float ratio = Math.max(0, Math.min(outOf, value)) / outOf;
+        int red = (int) ((1 - ratio) * 255);
+        int green = (int) (ratio * 255);
+
+        return text(text).color(color(red, green, 0));
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/LevelTickProcessor.java b/src/main/java/io/github/dueris/canvas/server/LevelTickProcessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9fcab341e55a23f5a8196a260573ebbadc3ba50
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/LevelTickProcessor.java
@@ -0,0 +1,25 @@
+package io.github.dueris.canvas.server;
+
+import java.util.Objects;
+import java.util.function.BiConsumer;
+import java.util.function.BooleanSupplier;
+import org.jetbrains.annotations.NotNull;
+
+@FunctionalInterface
+public interface LevelTickProcessor {
+    void process(BooleanSupplier shouldKeepTicking, int tickCount);
+
+    default void processAndThen(BooleanSupplier shouldKeepTicking, int tickCount, @NotNull Runnable postTick) {
+        process(shouldKeepTicking, tickCount);
+        postTick.run();
+    }
+
+    default BiConsumer<BooleanSupplier, Integer> andThen(BiConsumer<? super BooleanSupplier, ? super Integer> after) {
+        Objects.requireNonNull(after);
+
+        return (l, r) -> {
+            process(l, r);
+            after.accept(l, r);
+        };
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java b/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..e903c0fb9c1824c0c4a7707cabbcaa4d2bd1b257
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/ThreadedServer.java
@@ -0,0 +1,173 @@
+package io.github.dueris.canvas.server;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import io.github.dueris.canvas.Config;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.BooleanSupplier;
+import java.util.function.Function;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportType;
+import net.minecraft.Util;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Basically an implementation that acts as a manager for everything in the server that is threaded
+ * using contexts
+ */
+public class ThreadedServer {
+    public static final Logger LOGGER = LoggerFactory.getLogger("ThreadedServer");
+    public static final long MAX_NANOSECONDS_FOR_TICK_FRAME = 50_000_000;
+    public static final ThreadGroup serverThreadGroup = new ThreadGroup("ServerThreadGroup");
+    public static BooleanSupplier shouldKeepTicking;
+    public static Function<CraftWorld, Thread> spinner = (threadedInstance) -> {
+        try {
+            Thread levelThread = new TickThread(serverThreadGroup, threadedInstance.getHandle()::spin, "levelThread:" + threadedInstance.getName());
+            levelThread.setPriority(Config.INSTANCE.levelThreadPriority);
+            levelThread.start();
+            return levelThread;
+        } catch (Throwable throwable) {
+            throw new RuntimeException("Unable to spin world '" + threadedInstance.getName() + "'!", throwable);
+        }
+    };
+    private final List<CraftWorld> craftWorlds = new CopyOnWriteArrayList<>();
+    private final MinecraftServer server;
+    private long tickSection;
+    private boolean started = false;
+
+    public ThreadedServer(MinecraftServer server) {
+        this.server = server;
+    }
+
+    public List<ServerLevel> getThreadedWorlds() {
+        return craftWorlds.stream().map(CraftWorld::getHandle).toList();
+    }
+
+    public boolean hasStarted() {
+        return started;
+    }
+
+    public long getTickSection() {
+        return tickSection;
+    }
+
+    public MinecraftServer getServer() {
+        return server;
+    }
+
+    public void spin() {
+        try {
+            if (!server.initServer()) {
+                throw new IllegalStateException("Failed to initialize server");
+            }
+
+            // Prepare world contexts
+            this.craftWorlds.forEach(spinner::apply);
+            started = true;
+
+            this.server.nextTickTimeNanos = Util.getNanos();
+            this.server.statusIcon = this.server.loadStatusIcon().orElse(null);
+            this.server.status = this.server.buildServerStatus();
+
+            LOGGER.info("Running delayed init tasks");
+            this.server.server.getScheduler().mainThreadHeartbeat();
+
+            final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli();
+            LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D));
+            this.server.server.spark.enableBeforePlugins();
+            org.spigotmc.WatchdogThread.tick();
+
+            org.spigotmc.WatchdogThread.hasStarted = true;
+            Arrays.fill(this.server.recentTps, 20);
+            tickSection = Util.getNanos();
+            if (io.papermc.paper.configuration.GlobalConfiguration.isFirstStart) {
+                LOGGER.info("*************************************************************************************");
+                LOGGER.info("This is the first time you're starting this server.");
+                LOGGER.info("It's recommended you read our 'Getting Started' documentation for guidance.");
+                LOGGER.info("View this and more helpful information here: https://docs.papermc.io/paper/next-steps");
+                LOGGER.info("*************************************************************************************");
+            }
+
+            if (org.purpurmc.purpur.configuration.transformation.VoidDamageHeightMigration.HAS_BEEN_REGISTERED) {
+                try {
+                    org.purpurmc.purpur.PurpurConfig.config.save((File) this.server.options.valueOf("purpur-settings"));
+                } catch (IOException ex) {
+                    Bukkit.getLogger().log(java.util.logging.Level.SEVERE, "Could not save " + this.server.options.valueOf("purpur-settings"), ex);
+                }
+            }
+
+            if (!Boolean.getBoolean("Purpur.IReallyDontWantStartupCommands") && !org.purpurmc.purpur.PurpurConfig.startupCommands.isEmpty()) {
+                LOGGER.info("Purpur: Running startup commands specified in purpur.yml.");
+                for (final String startupCommand : org.purpurmc.purpur.PurpurConfig.startupCommands) {
+                    LOGGER.info("Purpur: Running the following command: \"{}\"", startupCommand);
+                    ((DedicatedServer) this.server).handleConsoleInput(startupCommand, this.server.createCommandSourceStack());
+                }
+            }
+
+            while (this.server.isRunning()) {
+                tickSection = this.getServer().tick(tickSection);
+            }
+        } catch (Throwable throwable2) {
+            if (throwable2 instanceof ThreadDeath) {
+                MinecraftServer.LOGGER.error("Main thread terminated by WatchDog due to hard crash", throwable2);
+                return;
+            }
+            MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable2);
+            CrashReport crashreport = MinecraftServer.constructOrExtractCrashReport(throwable2);
+
+            this.server.fillSystemReport(crashreport.getSystemReport());
+            Path path = this.server.getServerDirectory().resolve("crash-reports").resolve("crash-" + Util.getFilenameFormattedDateTime() + "-server.txt");
+
+            if (crashreport.saveToFile(path, ReportType.CRASH)) {
+                MinecraftServer.LOGGER.error("This crash report has been saved to: {}", path.toAbsolutePath());
+            } else {
+                MinecraftServer.LOGGER.error("We were unable to save this crash report to disk.");
+            }
+
+            this.server.onServerCrash(crashreport);
+        } finally {
+            try {
+                this.server.stopped = true;
+                this.server.stopServer();
+            } catch (Throwable throwable3) {
+                MinecraftServer.LOGGER.error("Exception stopping the server", throwable3);
+            } finally {
+                if (this.server.services.profileCache() != null) {
+                    this.server.services.profileCache().clearExecutor();
+                }
+            }
+
+        }
+    }
+
+    public void loadLevel(@NotNull ServerLevel level) {
+        this.craftWorlds.add(level.getWorld());
+        LOGGER.info("Loaded level to threaded context: {}", level.dimension().location());
+    }
+
+    public String getName() {
+        return Thread.currentThread().getName();
+    }
+
+    public void stopLevel(@NotNull ServerLevel level) {
+        this.craftWorlds.removeIf(craftWorld -> craftWorld.getHandle().equals(level));
+        level.stopSpin();
+        LOGGER.info("Removed level from threaded context: {}", level.dimension().location());
+    }
+
+    public Collection<ServerLevel> getAllLevels() {
+        return MinecraftServer.getServer().levels.values();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/VisibleAfterSpin.java b/src/main/java/io/github/dueris/canvas/server/VisibleAfterSpin.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec5011421fe0d9b589742effb9fdededa4cad5f9
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/VisibleAfterSpin.java
@@ -0,0 +1,10 @@
+package io.github.dueris.canvas.server;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import org.jetbrains.annotations.UnknownNullability;
+
+@UnknownNullability
+@Retention(RetentionPolicy.SOURCE)
+public @interface VisibleAfterSpin {
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java b/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java
new file mode 100644
index 0000000000000000000000000000000000000000..5368a749fc0fdfbfd76c753f310cf5550df2ef0a
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/level/MinecraftServerWorld.java
@@ -0,0 +1,338 @@
+package io.github.dueris.canvas.server.level;
+
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.server.LevelTickProcessor;
+import io.github.dueris.canvas.server.VisibleAfterSpin;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.BooleanSupplier;
+import net.minecraft.CrashReport;
+import net.minecraft.ReportType;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.TickTask;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.util.debugchart.SampleLogger;
+import net.minecraft.util.debugchart.TpsDebugDimensions;
+import net.minecraft.util.thread.ReentrantBlockableEventLoop;
+import net.minecraft.world.entity.player.Player;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.WatchdogThread;
+
+public abstract class MinecraftServerWorld extends ReentrantBlockableEventLoop<TickTask> implements WatchdogWatcher, TickRateManagerInstance {
+    private static final Logger LOGGER = LogManager.getLogger("MinecraftServerWorld");
+    public final double[] recentTps = new double[4];
+    public final MinecraftServer.RollingAverage tps5s = new MinecraftServer.RollingAverage(5);
+    public final MinecraftServer.RollingAverage tps1 = new MinecraftServer.RollingAverage(60);
+    public final MinecraftServer.RollingAverage tps5 = new MinecraftServer.RollingAverage(60 * 5);
+    public final MinecraftServer.RollingAverage tps15 = new MinecraftServer.RollingAverage(60 * 15);
+    protected final ServerTickRateManager tickRateManager;
+    private final long catchupTime = 0;
+    public volatile long lastWatchdogTick;
+    public int tickCount;
+    public boolean waitingForNextTick;
+    public long nextTickTimeNanos;
+    public long idleTimeNanos;
+    public boolean mayHaveDelayedTasks;
+    public long delayedTasksMaxNextTickTimeNanos;
+    public boolean lagging = false;
+    public boolean running = false;
+    private Thread owner;
+    private long tickSection = 0;
+    private long lastOverloadWarningNanos;
+    private long taskExecutionStartNanos;
+    private long lastTick = 0;
+    private long lastNanoTickTime = 0L;
+    private long preTickNanos = 0L;
+    private long postTickNanos = 0L;
+    private long lastMidTickExecute;
+    private long lastMidTickExecuteFailure;
+    private volatile boolean ticking = false;
+    public int currentTick;
+
+    public MinecraftServerWorld(final String name) {
+        super(name);
+        this.tickRateManager = new ServerTickRateManager(this);
+    }
+
+
+    @Override
+    public @VisibleAfterSpin @NotNull Thread getRunningThread() {
+        return this.owner;
+    }
+
+    @Override
+    public void managedBlock(@NotNull BooleanSupplier stopCondition) {
+        super.managedBlock(() -> MinecraftServer.throwIfFatalException() && stopCondition.getAsBoolean());
+    }
+
+    public double getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    public void spin() {
+        try {
+            if (!(this instanceof ServerLevel serverLevel)) {
+                throw new RuntimeException("MinecraftServerWorld#spin() was called from a non-ServerLevel instance!");
+            }
+            LOGGER.info("[ThreadedServer] Spinning ServerLevel, {}", serverLevel.dimension().location());
+
+            this.running = true;
+            this.owner = Thread.currentThread();
+            WatchdogThread.tickLevel(serverLevel);
+            if (Config.INSTANCE.useLevelThreadsAsChunkSourceMain) serverLevel.chunkSource.mainThread = this.owner; // Point main thread executor to level threads
+            Arrays.fill(this.recentTps, 20);
+
+            // Block the current thread until the MinecraftServer has started the first tick.
+            this.managedBlock(() -> MinecraftServer.getServer().isTicking());
+            ticking = true;
+
+            tickSection = Util.getNanos();
+            nextTickTimeNanos = Util.getNanos();
+            while (running) {
+                this.tickSection = blockLevel(tickSection, serverLevel, serverLevel::tick);
+            }
+        } catch (Throwable throwable) {
+            //noinspection removal
+            if (throwable instanceof ThreadDeath) {
+                MinecraftServer.LOGGER.error("World thread terminated by WatchDog due to hard crash", throwable);
+                return;
+            }
+            MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
+            CrashReport crashreport = MinecraftServer.constructOrExtractCrashReport(throwable);
+
+            MinecraftServer.getServer().fillSystemReport(crashreport.getSystemReport());
+            Path path = MinecraftServer.getServer().getServerDirectory().resolve("crash-reports").resolve("crash-" + Util.getFilenameFormattedDateTime() + "-server.txt");
+
+            if (crashreport.saveToFile(path, ReportType.CRASH)) {
+                MinecraftServer.LOGGER.error("This crash report has been saved to: {}", path.toAbsolutePath());
+            } else {
+                MinecraftServer.LOGGER.error("We were unable to save this crash report to disk.");
+            }
+
+            MinecraftServer.getServer().onServerCrash(crashreport);
+
+            try {
+                MinecraftServer.getServer().stopped = true;
+                MinecraftServer.getServer().stopServer();
+            } catch (Throwable throwable3) {
+                MinecraftServer.LOGGER.error("Exception stopping the server(via level thread)", throwable3);
+            } finally {
+                if (MinecraftServer.getServer().services.profileCache() != null) {
+                    MinecraftServer.getServer().services.profileCache().clearExecutor();
+                }
+            }
+        } finally {
+            LOGGER.info("Successfully terminated level {}", this.level().dimension().location().toString());
+        }
+
+    }
+
+    public void stopSpin() {
+        running = false;
+    }
+
+    public long getTickSection() {
+        return tickSection;
+    }
+
+    public int getCurrentTick() {
+        return currentTick;
+    }
+
+    public long blockLevel(long tickSection, final ServerLevel serverLevel, final @NotNull LevelTickProcessor tickProcessor) {
+        long currentTime;
+        long i;
+
+        if (tickRateManager().isSprinting() && tickRateManager().checkShouldSprintThisTick()) {
+            i = 0L;
+            this.nextTickTimeNanos = Util.getNanos();
+            this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+        } else {
+            i = tickRateManager().nanosecondsPerTick();
+            long j = Util.getNanos() - this.nextTickTimeNanos;
+
+            if (j > MinecraftServer.OVERLOADED_THRESHOLD_NANOS + 20L * i && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * i) {
+                long k = j / i;
+
+                if (MinecraftServer.getServer().server.getWarnOnOverload()) {
+                    MinecraftServer.LOGGER.warn("Can't keep up! Is the level overloaded? Running {}ms or {} ticks behind on level-thread: {}", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k, serverLevel.dimension().location());
+                }
+                this.nextTickTimeNanos += k * i;
+                this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+            }
+        }
+
+        currentTime = Util.getNanos();
+        if (++currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+            final long diff = currentTime - tickSection;
+            final java.math.BigDecimal currentTps = MinecraftServer.TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+            tps5s.add(currentTps, diff);
+            tps1.add(currentTps, diff);
+            tps5.add(currentTps, diff);
+            tps15.add(currentTps, diff);
+
+            this.recentTps[0] = tps5s.getAverage();
+            this.recentTps[1] = tps1.getAverage();
+            this.recentTps[2] = tps5.getAverage();
+            this.recentTps[3] = tps15.getAverage();
+            lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+            tickSection = currentTime;
+        }
+
+        boolean flag = i == 0L;
+
+        lastTick = currentTime;
+        postTickNanos = i;
+        this.nextTickTimeNanos += i;
+
+        this.preTickNanos = Util.getNanos();
+        WatchdogThread.tickLevel(serverLevel);
+        tickProcessor.process(flag ? () -> false : this::haveTime, tickCount);
+
+        this.lastNanoTickTime = Util.getNanos() - preTickNanos;
+
+        this.mayHaveDelayedTasks = true;
+        this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + postTickNanos, this.nextTickTimeNanos);
+        if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+            this.nextTickTimeNanos = lastTick + postTickNanos;
+            this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+        }
+        this.startMeasuringTaskExecutionTime();
+        this.waitUntilNextTick();
+        this.finishMeasuringTaskExecutionTime();
+        return tickSection;
+    }
+
+    private void startMeasuringTaskExecutionTime() {
+        if (MinecraftServer.getServer().isTickTimeLoggingEnabled()) {
+            this.taskExecutionStartNanos = Util.getNanos();
+            this.idleTimeNanos = 0L;
+        }
+
+    }
+
+    private void finishMeasuringTaskExecutionTime() {
+        if (MinecraftServer.getServer().isTickTimeLoggingEnabled()) {
+            SampleLogger samplelogger = MinecraftServer.getServer().getTickTimeLogger();
+
+            samplelogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            samplelogger.logPartialSample(this.idleTimeNanos, TpsDebugDimensions.IDLE.ordinal());
+        }
+
+    }
+
+    protected void waitUntilNextTick() {
+        this.runAllTasks();
+        this.waitingForNextTick = true;
+
+        try {
+            this.managedBlock(() -> !this.haveTime());
+        } finally {
+            this.waitingForNextTick = false;
+        }
+
+    }
+
+    @Override
+    public void waitForTasks() {
+        boolean flag = MinecraftServer.getServer().isTickTimeLoggingEnabled();
+        long i = flag ? Util.getNanos() : 0L;
+        long j = this.waitingForNextTick ? this.nextTickTimeNanos - Util.getNanos() : 100000L;
+
+        LockSupport.parkNanos(level(), j);
+        if (flag) {
+            this.idleTimeNanos += Util.getNanos() - i;
+        }
+
+    }
+
+    @Override
+    public @NotNull TickTask wrapRunnable(@NotNull Runnable runnable) {
+        if (MinecraftServer.getServer().hasStopped && Thread.currentThread().equals(MinecraftServer.getServer().shutdownThread)) {
+            runnable.run();
+            runnable = () -> {
+            };
+        }
+        return new TickTask(this.tickCount, runnable);
+    }
+
+    protected boolean shouldRun(@NotNull TickTask ticktask) {
+        return ticktask.getTick() + 3 < this.tickCount || this.haveTime();
+    }
+
+    protected boolean haveTime() {
+        return MinecraftServer.getServer().forceTicks || this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+    }
+
+    @Override
+    public boolean pollTask() {
+        boolean flag = this.pollInternal();
+
+        this.mayHaveDelayedTasks = flag;
+        return flag;
+    }
+
+    public boolean pollInternal() {
+        if (super.pollTask()) {
+            return true;
+        } else {
+            boolean ret = false;
+            if (tickRateManager().isSprinting() || this.haveTime()) {
+                ServerLevel worldserver = level();
+
+                if (worldserver.getChunkSource().pollTask()) {
+                    ret = true;
+                }
+            }
+
+            return ret;
+        }
+    }
+
+    public ServerLevel level() {
+        return (ServerLevel) this;
+    }
+
+    @Override
+    public String getName() {
+        return "level(" + level().dimension().location().getPath() + ")";
+    }
+
+    public boolean isTicking() {
+        return ticking;
+    }
+
+    @Override
+    public CommandSourceStack createCommandSourceStack() {
+        return MinecraftServer.getServer().createCommandSourceStack();
+    }
+
+    @Override
+    public void onTickRateChanged() {
+        MinecraftServer.getServer().onTickRateChanged();
+    }
+
+    @Override
+    public void broadcastPacketsToPlayers(final Packet<?> packet) {
+        for (final Player player : this.level().players()) {
+            ((ServerPlayer) player).connection.send(packet);
+        }
+    }
+
+    @Override
+    public void skipTickWait() {
+        this.delayedTasksMaxNextTickTimeNanos = Util.getNanos();
+        this.nextTickTimeNanos = Util.getNanos();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java b/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java
new file mode 100644
index 0000000000000000000000000000000000000000..c59f6423f559e048ec2581f67adaf8566997447d
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/level/TickRateManagerInstance.java
@@ -0,0 +1,17 @@
+package io.github.dueris.canvas.server.level;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.ServerTickRateManager;
+
+public interface TickRateManagerInstance {
+    void broadcastPacketsToPlayers(Packet<?> packet);
+
+    CommandSourceStack createCommandSourceStack();
+
+    void onTickRateChanged();
+
+    ServerTickRateManager tickRateManager();
+
+    void skipTickWait();
+}
diff --git a/src/main/java/io/github/dueris/canvas/server/level/WatchdogWatcher.java b/src/main/java/io/github/dueris/canvas/server/level/WatchdogWatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..59ff3fbf26fddfaf8490bb82dc06ffd2cfcd0644
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/server/level/WatchdogWatcher.java
@@ -0,0 +1,18 @@
+package io.github.dueris.canvas.server.level;
+
+public interface WatchdogWatcher {
+    /**
+     * Name of the watchdog instance. Either "server" for the main thread
+     * or "level(<level id>)" for a level thread
+     *
+     * @return the name of the watcher
+     */
+    String getName();
+
+    /**
+     * Retrieves the running thread for watchdog to track
+     *
+     * @return The running thread.
+     */
+    Thread getRunningThread();
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/ConcurrentLinkedDequeTree.java b/src/main/java/io/github/dueris/canvas/util/ConcurrentLinkedDequeTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2cc438bb62bb5350edb4701d00a511a0a5c379a
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/ConcurrentLinkedDequeTree.java
@@ -0,0 +1,10 @@
+package io.github.dueris.canvas.util;
+
+import java.util.concurrent.ConcurrentLinkedDeque;
+
+public class ConcurrentLinkedDequeTree<E> extends ConcurrentLinkedDeque<E> {
+
+    public E first() {
+        return super.getFirst();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/QueuedTaskScheduler.java b/src/main/java/io/github/dueris/canvas/util/QueuedTaskScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..dcba946dca06c5cc31b4ccc6c040a8e239a34f52
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/QueuedTaskScheduler.java
@@ -0,0 +1,24 @@
+package io.github.dueris.canvas.util;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+public class QueuedTaskScheduler {
+    private final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<>();
+
+    public void schedule(Runnable task) {
+        taskQueue.add(task);
+    }
+
+    public void tick() {
+        Runnable task;
+        while ((task = taskQueue.poll()) != null) {
+            try {
+                task.run();
+            } catch (Throwable throwable) {
+                if (throwable instanceof ThreadDeath) throw throwable;
+                else throwable.printStackTrace();
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/MSPTCommand.java b/src/main/java/io/papermc/paper/command/MSPTCommand.java
index 8b5293b0c696ef21d0101493ffa41b60bf0bc86b..4d061ceba635ab6fc1563026f6f10e16555a1252 100644
--- a/src/main/java/io/papermc/paper/command/MSPTCommand.java
+++ b/src/main/java/io/papermc/paper/command/MSPTCommand.java
@@ -96,7 +96,7 @@ public final class MSPTCommand extends Command {
         return Arrays.asList(getColor(avgD), getColor(minD), getColor(maxD));
     }
 
-    private static Component getColor(double avg) {
+    public static Component getColor(double avg) { // Canvas - private -> public
         return text(DF.format(avg), avg >= 50 ? RED : avg >= 40 ? YELLOW : GREEN);
     }
 }
diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index 6714b4a39180affd101f1cab0d587cf2d3e6886a..09dc69502190ce2a6ba9317ee71b60cfaa6bce35 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -28,6 +28,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.Validate;
 import org.apache.commons.lang3.tuple.Pair;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 @Immutable
@@ -223,7 +224,7 @@ public class BlockPos extends Vec3i {
     }
 
     @Override
-    public BlockPos relative(Direction direction) {
+    public synchronized @NotNull BlockPos relative(Direction direction) { // Canvas
         // Paper start - Perf: Optimize BlockPosition
         switch(direction) {
             case UP:
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 8661c1b1cfe2b3db000e1f08814fd4409c4b7fab..f37c4e6be74c1f02cb4ed0556010ae8e94de7002 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -38,6 +38,7 @@ import java.nio.channels.ClosedChannelException;
 import java.util.Objects;
 import java.util.Queue;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -60,6 +61,7 @@ import net.minecraft.network.protocol.login.LoginProtocols;
 import net.minecraft.network.protocol.status.ClientStatusPacketListener;
 import net.minecraft.network.protocol.status.StatusProtocols;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
 import net.minecraft.util.debugchart.LocalSampleLogger;
 import org.apache.commons.lang3.Validate;
@@ -175,6 +177,23 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
 
     }
+    // Canvas start - threaded connections
+    private AtomicReference<ServerLevel> holdingLevel = new AtomicReference<>(null);
+
+    public void transferToLevel(ServerLevel level) {
+        if (holdingLevel.get() != null) {
+            // Player was on a diff world before, remove from previous context
+            level.removeConnection(this);
+        }
+        holdingLevel.set(level);
+        level.notifyNewConnection(this);
+    }
+
+    @Nullable
+    public ServerLevel getHoldingLevel() {
+        return holdingLevel.get();
+    }
+    // Canvas end
 
     public void channelInactive(ChannelHandlerContext channelhandlercontext) {
         this.disconnect((Component) Component.translatable("disconnect.endOfStream"));
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index 1f7f68aad97ee73763c042837f239bdc7167db55..28c318703a520e63672688e039a6710e9bfb5852 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -40,11 +40,7 @@ public class PacketUtils {
 
     public PacketUtils() {}
 
-    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T listener, ServerLevel world) throws RunningOnDifferentThreadException {
-        PacketUtils.ensureRunningOnSameThread(packet, listener, (BlockableEventLoop) world.getServer());
-    }
-
-    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T listener, BlockableEventLoop<?> engine) throws RunningOnDifferentThreadException {
+    public static <T extends PacketListener> void ensureRunningOnSameThread(Packet<T> packet, T listener, ServerLevel engine) throws RunningOnDifferentThreadException { // Canvas - run on ServerLevel
         if (!engine.isSameThread()) {
             engine.executeIfPossible(() -> {
                 packetProcessing.push(listener); // Paper - detailed watchdog information
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 1a37654aff9a9c86c9f7af10a1cf721371f0c5ec..4d5aff469934bd2b401b68d4d2db8a049936c8d4 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,7 @@ package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+import java.util.Set;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -18,14 +19,14 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public static final StreamCodec<FriendlyByteBuf, ClientboundSectionBlocksUpdatePacket> STREAM_CODEC = Packet.codec(ClientboundSectionBlocksUpdatePacket::write, ClientboundSectionBlocksUpdatePacket::new);
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
-    private final short[] positions;
+    private final Short[] positions; // Canvas
     private final BlockState[] states;
 
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section) {
         this.sectionPos = sectionPos;
         int i = positions.size();
 
-        this.positions = new short[i];
+        this.positions = new Short[i]; // Canvas
         this.states = new BlockState[i];
         int j = 0;
 
@@ -41,7 +42,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     // CraftBukkit start - Add constructor
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ShortSet shortset, BlockState[] states) {
         this.sectionPos = sectionposition;
-        this.positions = shortset.toShortArray();
+        this.positions = shortset.toArray(new Short[0]); // Canvas
         this.states = states;
     }
     // CraftBukkit end
@@ -50,7 +51,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
         this.sectionPos = SectionPos.of(buf.readLong());
         int i = buf.readVarInt();
 
-        this.positions = new short[i];
+        this.positions = new Short[i]; // Canvas
         this.states = new BlockState[i];
 
         for (int j = 0; j < i; ++j) {
@@ -63,9 +64,9 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     }
 
     // Paper start - Multi Block Change API
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<BlockState> blockChanges) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, java.util.Map<Short, BlockState> blockChanges) { // Canvas
         this.sectionPos = sectionPos;
-        this.positions = blockChanges.keySet().toShortArray();
+        this.positions = blockChanges.keySet().toArray(new Short[0]); // Canvas
         this.states = blockChanges.values().toArray(new BlockState[0]);
     }
     // Paper end - Multi Block Change API
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 115069f2bce9b7742d8d3fbf181a47cacf8b0046..ea6d15d01f6e1a77e1e2bbf80ad172cfc4b14989 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -3,9 +3,6 @@ package net.minecraft.server;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -16,6 +13,11 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.jtracy.DiscontinuousFrame;
 import com.mojang.jtracy.TracyClient;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.server.ThreadedServer;
+import io.github.dueris.canvas.server.level.TickRateManagerInstance;
+import io.github.dueris.canvas.server.level.WatchdogWatcher;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -79,6 +81,7 @@ import net.minecraft.gametest.framework.GameTestTicker;
 import net.minecraft.network.chat.ChatDecorator;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketType;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
@@ -204,17 +207,18 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer, WatchdogWatcher, TickRateManagerInstance { // Paper - rewrite chunk system // Canvas - Threaded Dimensions
 
     private static MinecraftServer SERVER; // Paper
+    private static ThreadedServer THREADED_SERVER; // Canvas
     public static final Logger LOGGER = LogUtils.getLogger();
     public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
-    private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
+    public static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit // Canvas - private -> public
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND; // Canvas - private -> public
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
     private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
@@ -239,19 +243,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private ServerConnectionListener connection;
     public final ChunkProgressListenerFactory progressListenerFactory;
     @Nullable
-    private ServerStatus status;
+    public ServerStatus status; // Canvas - private -> public
     @Nullable
-    private ServerStatus.Favicon statusIcon;
+    public ServerStatus.Favicon statusIcon; // Canvas - private -> public
     private final RandomSource random;
     public final DataFixer fixerUpper;
     private String localIp;
     private int port;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels;
+    public Map<ResourceKey<Level>, ServerLevel> levels; // Canvas - private -> public
     private PlayerList playerList;
     private volatile boolean running;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
-    private boolean stopped;
+    public boolean stopped; // Canvas - private -> public
     private int tickCount;
     private int ticksUntilAutosave;
     protected final Proxy proxy;
@@ -275,14 +279,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean isDemo;
     private volatile boolean isReady;
     private long lastOverloadWarningNanos;
-    protected final Services services;
+    public final Services services; // Canvas - protected -> public
     private long lastServerStatus;
     public final Thread serverThread;
     private long lastTickNanos;
     private long taskExecutionStartNanos;
     private long idleTimeNanos;
-    private long nextTickTimeNanos;
-    private boolean waitingForNextTick;
+    public long nextTickTimeNanos; // Canvas - private -> public
+    public boolean waitingForNextTick; // Canvas - private -> public
     private long delayedTasksMaxNextTickTimeNanos;
     private boolean mayHaveDelayedTasks;
     private final PackRepository packRepository;
@@ -323,13 +327,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Spigot start
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
-    private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
-    @Deprecated(forRemoval = true) // Paper
+    public static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop // Canvas - private -> public
+    // @Deprecated(forRemoval = true) // Paper // Canvas - nah
     public final double[] recentTps = new double[ 4 ]; // Purpur - Add 5 second tps average in /tps
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
-    private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
+    public final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping // Canvas - private -> public
     public boolean lagging = false; // Purpur - Lagging threshold
     protected boolean upnp = false; // Purpur - UPnP Port Forwarding
 
@@ -337,11 +341,27 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile boolean abnormalExit = false; // Paper
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
 
+    // Canvas start - Multithreaded Dimension Ticking
+    private volatile boolean isTicking = false;
+
+    public boolean isTicking() {
+        return isTicking;
+    }
+
+    @Override
+    public void broadcastPacketsToPlayers(final Packet<?> packet) {
+        this.playerList.broadcastAll(packet);
+    }
+
+    // Canvas end
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
         AtomicReference<S> atomicreference = new AtomicReference();
         Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> { // Paper - rewrite chunk system
-            ((MinecraftServer) atomicreference.get()).runServer();
+            // Canvas start - Multithreaded Dimension Ticking
+            THREADED_SERVER = new ThreadedServer(atomicreference.get());
+            THREADED_SERVER.spin();
+            // Canvas end
         }, "Server thread");
 
         thread.setUncaughtExceptionHandler((thread1, throwable) -> {
@@ -360,16 +380,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Paper start - rewrite chunk system
-    private volatile Throwable chunkSystemCrash;
+    private volatile @Nullable Throwable chunkSystemCrash; // Canvas - nullable
 
     @Override
     public final void moonrise$setChunkSystemCrash(final Throwable throwable) {
         this.chunkSystemCrash = throwable;
     }
 
-    private static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us
-    private static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
-    private static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
+    public static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us // Canvas - private -> public
+    public static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us // Canvas - private -> public
+    public static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us // Canvas - private -> public
 
     private long lastMidTickExecute;
     private long lastMidTickExecuteFailure;
@@ -521,7 +541,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         persistentStateManager.computeIfAbsent(this.getScoreboard().dataFactory(), "scoreboard");
     }
 
-    protected abstract boolean initServer() throws IOException;
+    public abstract boolean initServer() throws IOException; // Canvas - protected -> public
 
     protected void loadLevel(String s) { // CraftBukkit
         if (!JvmProfiler.INSTANCE.isRunning()) {
@@ -916,6 +936,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // CraftBukkit start
             // this.nextTickTimeNanos = SystemUtils.getNanos() + MinecraftServer.PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
             this.executeModerately();
+            break; // Canvas
         }
 
         // this.nextTickTimeNanos = SystemUtils.getNanos() + MinecraftServer.PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
@@ -1029,7 +1050,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // CraftBukkit start
-    private boolean hasStopped = false;
+    public boolean hasStopped = false; // Canvas - private -> public
     private boolean hasLoggedStop = false; // Paper - Debugging
     public volatile boolean hasFullyShutdown = false; // Paper
     private final Object stopLock = new Object();
@@ -1056,7 +1077,26 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.cancelRecordingMetrics();
         }
 
-        MinecraftServer.LOGGER.info("Stopping server");
+        // Canvas start
+        ThreadedServer.LOGGER.info("Halting level-threads");
+        long startNanos = Util.getNanos();
+        Thread currentThread = Thread.currentThread();
+        for (final ServerLevel level : this.getAllLevels()) {
+            if (level.running) {
+                level.stopSpin();
+                if (currentThread.equals(level.getRunningThread())) {
+                    continue;
+                }
+                try {
+                    level.getRunningThread().join();
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        long nanoTickTime = Util.getNanos() - startNanos;
+        ThreadedServer.LOGGER.info("Successfully halted levels in {}ms", (nanoTickTime / 1_000_000));
+        // Canvas end
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
         // Purpur start - UPnP Port Forwarding
         if (upnp) {
@@ -1210,7 +1250,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private final java.math.BigDecimal[] samples;
         private final long[] times;
 
-        RollingAverage(int size) {
+        public RollingAverage(int size) { // Canvas - public
             this.size = size;
             this.time = size * SEC_IN_NANO;
             this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
@@ -1241,11 +1281,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
         }
     }
-    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    public static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL)); // Canvas - private -> public
     // Paper end
     // Spigot End
 
+    @Deprecated(forRemoval = true) // Canvas - Multithreaded Dimension Ticking - mark deprecated because we dont even use this anymore
     protected void runServer() {
+        if (true) return; // Canvas - nope!
         try {
             long serverStartTime = Util.getNanos(); // Paper
             if (!this.initServer()) {
@@ -1463,6 +1505,121 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
     }
+    // Canvas start - Multithreaded Dimension Ticking
+
+    public long tick(long tickSection) {
+        if (!isTicking) {
+            // Mark ticking to unlock level threads, to allow them to begin runtime.
+            isTicking = true;
+        }
+        long currentTime;
+        long i;
+
+        if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+            i = 0L;
+            this.nextTickTimeNanos = Util.getNanos();
+            this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+        } else {
+            i = this.tickRateManager.nanosecondsPerTick();
+            long j = Util.getNanos() - this.nextTickTimeNanos;
+
+            if (j > MinecraftServer.OVERLOADED_THRESHOLD_NANOS + 20L * i && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * i) {
+                long k = j / i;
+
+                if (this.server.getWarnOnOverload()) {
+                    MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k);
+                }
+                this.nextTickTimeNanos += k * i;
+                this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+            }
+        }
+
+        currentTime = Util.getNanos();
+        if (++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+            final long diff = currentTime - tickSection;
+            final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+            tps5s.add(currentTps, diff);
+            tps1.add(currentTps, diff);
+            tps5.add(currentTps, diff);
+            tps15.add(currentTps, diff);
+
+            this.recentTps[0] = tps5s.getAverage();
+            this.recentTps[1] = tps1.getAverage();
+            this.recentTps[2] = tps5.getAverage();
+            this.recentTps[3] = tps15.getAverage();
+            lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+            tickSection = currentTime;
+        }
+
+        boolean flag = i == 0L;
+
+        if (this.debugCommandProfilerDelayStart) {
+            this.debugCommandProfilerDelayStart = false;
+            this.debugCommandProfiler = new TimeProfiler(Util.getNanos(), this.tickCount);
+        }
+
+        lastTick = currentTime;
+        this.nextTickTimeNanos += i;
+
+        try {
+            Profiler.Scope profiler_a = Profiler.use(this.createProfiler());
+
+            try {
+                ProfilerFiller gameprofilerfiller = Profiler.get();
+
+                gameprofilerfiller.push("tick");
+                this.tickFrame.start();
+                // We update it through here so that we can easily access this var throughout the lifecycle
+                ThreadedServer.shouldKeepTicking = flag ? () -> false : this::haveTime;
+                this.tickServer(ThreadedServer.shouldKeepTicking);
+
+                final Throwable crash = this.chunkSystemCrash;
+                if (crash != null) {
+                    this.chunkSystemCrash = null;
+                    throw new RuntimeException("Chunk system crash propagated to tick()", crash);
+                }
+
+                this.tickFrame.end();
+                gameprofilerfiller.popPush("nextTickWait");
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + i, this.nextTickTimeNanos);
+                if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup) {
+                    this.nextTickTimeNanos = currentTime + i;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+                if (flag) {
+                    this.tickRateManager.endTickWork();
+                }
+
+                gameprofilerfiller.pop();
+                this.logFullTickTime();
+            } catch (Throwable throwable) {
+                if (profiler_a != null) {
+                    try {
+                        profiler_a.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
+                    }
+                }
+
+                throw throwable;
+            }
+
+            if (profiler_a != null) {
+                profiler_a.close();
+            }
+        } finally {
+            this.endMetricsRecordingTick();
+        }
+
+        this.isReady = true;
+        JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
+        return tickSection;
+    }
+    // Canvas end
 
     private void logFullTickTime() {
         long i = Util.getNanos();
@@ -1492,7 +1649,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     }
 
-    private static CrashReport constructOrExtractCrashReport(Throwable throwable) {
+    public static CrashReport constructOrExtractCrashReport(Throwable throwable) { // Canvas - private -> public
         ReportedException reportedexception = null;
 
         for (Throwable throwable1 = throwable; throwable1 != null; throwable1 = throwable1.getCause()) {
@@ -1601,7 +1758,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (super.pollTask()) {
             this.moonrise$executeMidTickTasks(); // Paper - rewrite chunk system
             return true;
-        } else {
+        } else if (!getThreadedServer().hasStarted()) { // Canvas
             boolean ret = false; // Paper - force execution of all worlds, do not just bias the first
             if (this.tickRateManager.isSprinting() || this.haveTime()) {
                 Iterator iterator = this.getAllLevels().iterator();
@@ -1617,6 +1774,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             return ret; // Paper - force execution of all worlds, do not just bias the first
         }
+        return false; // Canvas
     }
 
     public void doRunTask(TickTask ticktask) { // CraftBukkit - decompile error
@@ -1624,7 +1782,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         super.doRunTask(ticktask);
     }
 
-    private Optional<ServerStatus.Favicon> loadStatusIcon() {
+    public Optional<ServerStatus.Favicon> loadStatusIcon() { // Canvas - private -> public
         Optional<Path> optional = Optional.of(this.getFile("server-icon.png")).filter((path) -> {
             return Files.isRegularFile(path, new LinkOption[0]);
         }).or(() -> {
@@ -1666,6 +1824,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
+    // Canvas start
+    private boolean emptyTickSleeping = false;
+
+    public boolean isEmptyTickSkipping() {
+        return emptyTickSleeping;
+    }
+
+    // Canvas end
     public void tickServer(BooleanSupplier shouldKeepTicking) {
         org.spigotmc.WatchdogThread.tick(); // Spigot
         long i = Util.getNanos();
@@ -1692,18 +1858,22 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 while ((task = this.processQueue.poll()) != null) {
                     task.run();
                 }
-                for (final ServerLevel level : this.levels.values()) {
+                // Canvas start - Multithreaded Dimension Ticking
+                // We tick the chunk source on the levels respective thread
+                /* for (final ServerLevel level : this.levels.values()) {
                     // process unloads
                     level.getChunkSource().tick(() -> true, false);
-                }
+                } */ // Canvas end
                 // Paper end - avoid issues with certain tasks not processing during sleep
                 this.server.spark.executeMainThreadTasks(); // Paper - spark
                 this.tickConnection();
                 this.server.spark.tickEnd(((double)(System.nanoTime() - lastTick) / 1000000D)); // Paper - spark
+                emptyTickSleeping = true; // Canvas
                 return;
             }
         }
 
+        emptyTickSleeping = false; // Canvas
         this.server.spark.tickStart(); // Paper - spark
         new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper - Server Tick Events
         ++this.tickCount;
@@ -1726,11 +1896,38 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         try {
             this.isSaving = true;
             if (playerSaveInterval > 0) {
+                // Canvas start
+                if (Config.INSTANCE.runAutoSaveThreaded) {
+                    for (final ServerLevel level : this.getAllLevels()) {
+                        final int finalPlayerSaveInterval = playerSaveInterval;
+                        level.scheduleOnMain(() -> {
+                            int numSaved = 0;
+                            long now = level.currentTick;
+                            for (int ia = 0; ia < level.players().size(); ++ia) {
+                                final ServerPlayer player = level.players().get(ia);
+                                if (finalPlayerSaveInterval == -1 || now - player.lastSave >= finalPlayerSaveInterval) {
+                                    this.playerList.save(player);
+                                    if (finalPlayerSaveInterval != -1 && ++numSaved >= GlobalConfiguration.get().playerAutoSave.maxPerTick()) {
+                                        break;
+                                    }
+                                }
+                            }
+                        });
+                    }
+                } else {
                 this.playerList.saveAll(playerSaveInterval);
+                }
             }
             for (final ServerLevel level : this.getAllLevels()) {
                 if (level.paperConfig().chunks.autoSaveInterval.value() > 0) {
+                    if (!Config.INSTANCE.runAutoSaveThreaded) {
                     level.saveIncrementally(fullSave);
+                    } else {
+                        level.scheduleOnMain(() -> {
+                            level.saveIncrementally(fullSave);
+                        });
+                    }
+                // Canvas end
                 }
             }
         } finally {
@@ -1809,11 +2006,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     }
 
-    protected abstract SampleLogger getTickTimeLogger();
+    public abstract SampleLogger getTickTimeLogger(); // Canvas - protected -> public
 
     public abstract boolean isTickTimeLoggingEnabled();
 
-    private ServerStatus buildServerStatus() {
+    public ServerStatus buildServerStatus() { // Canvas - private -> public
         ServerStatus.Players serverping_serverpingplayersample = this.buildPlayerStatus();
 
         return new ServerStatus(io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), Optional.of(serverping_serverpingplayersample), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile()); // Paper - Adventure
@@ -1844,13 +2041,23 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     protected void tickChildren(BooleanSupplier shouldKeepTicking) {
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
-        this.getPlayerList().getPlayers().forEach((entityplayer) -> {
+        // Canvas start
+        /* this.getPlayerList().getPlayers().forEach((entityplayer) -> {
             entityplayer.connection.suspendFlushing();
-        });
+        }); */
+        for (final ServerPlayer player : this.playerList.players) {
+            if (player.connection.connection.getHoldingLevel() == null
+                /*holding level is null, meaning they havent been moved
+                    to a level thread yet, so we handle on main*/) {
+                player.connection.suspendFlushing();
+            }
+        }
+        // Canvas end
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
+        // Canvas start - move to level threads
+        /* getAllLevels().forEach(level -> {
             for (final Entity entity : level.getEntities().getAll()) {
                 if (entity.isRemoved()) {
                     continue;
@@ -1860,7 +2067,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     bukkit.taskScheduler.executeTick();
                 }
             }
-        });
+        }); */
+        // Canvas end
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         gameprofilerfiller.push("commandFunctions");
@@ -1876,7 +2084,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        // Canvas start - Multithreaded Dimension Ticking - moved to ServerLevel
+        /* for (final ServerLevel level : this.getAllLevels()) {
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1892,9 +2101,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 entityplayer.connection.send(packet); // Add support for per player time
                 // Paper end - Perf: Optimize time updates
             }
-        }
+        } */ // Canvas end
 
-        this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
+        /* this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked // Canvas start - Multithreaded Dimension Ticking
         Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
@@ -1915,7 +2124,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.synchronizeTime(worldserver);
                 gameprofilerfiller.pop();
             }
-            // CraftBukkit end */
+            // CraftBukkit end // Canvas - compile error with craftbukkit comment
 
             gameprofilerfiller.push("tick");
 
@@ -1932,7 +2141,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             gameprofilerfiller.pop();
             worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
-        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked */ // Canvas end
 
         gameprofilerfiller.popPush("connection");
         this.tickConnection();
@@ -1949,13 +2158,22 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         gameprofilerfiller.popPush("send chunks");
-        iterator = this.playerList.getPlayers().iterator();
+        // Iterator<ServerPlayer> iterator = this.playerList.getPlayers().iterator(); // Canvas - dont use anymore
 
-        while (iterator.hasNext()) {
+        // Canvas start
+        /* while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
 
             entityplayer.connection.chunkSender.sendNextChunks(entityplayer);
             entityplayer.connection.resumeFlushing();
+        } */
+        for (final ServerPlayer player : this.playerList.players) {
+            if (player.connection.connection.getHoldingLevel() == null
+                /*holding level is null, meaning they havent been moved
+                    to a level thread yet, so we handle on main*/) {
+                player.connection.chunkSender.sendNextChunks(player);
+                player.connection.resumeFlushing();
+            }
         }
 
         gameprofilerfiller.pop();
@@ -1966,6 +2184,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private void synchronizeTime(ServerLevel world) {
+        // Canvas start - not all worlds have the same time anymore due to tick isolation
+        if (true) {
+            world.syncTimeToPlayers();
+            return;
+        }
+        // Canvas end
         this.playerList.broadcastAll(new ClientboundSetTimePacket(world.getGameTime(), world.getDayTime(), world.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)), world.dimension());
     }
 
@@ -1973,13 +2197,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         gameprofilerfiller.push("timeSync");
-        Iterator iterator = this.getAllLevels().iterator();
-
-        while (iterator.hasNext()) {
-            ServerLevel worldserver = (ServerLevel) iterator.next();
-
-            this.synchronizeTime(worldserver);
+        // Canvas start
+        for (final ServerLevel level : this.getAllLevels()) {
+            level.syncTimeToPlayers();
         }
+        // Canvas end
 
         gameprofilerfiller.pop();
     }
@@ -2019,6 +2241,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        getThreadedServer().loadLevel(level); // Canvas - add level to threaded context
     }
 
     public void removeLevel(ServerLevel level) {
@@ -2026,6 +2249,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        getThreadedServer().stopLevel(level); // Canvas - remove level from threaded context
     }
     // CraftBukkit end
 
@@ -2378,6 +2602,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public Thread getRunningThread() {
         return this.serverThread;
     }
+    // Canvas start - Threaded Dimensions - Improve Watchdog
+
+    @Override
+    public String getName() {
+        return "server";
+    }
+    // Canvas end
 
     public int getCompressionThreshold() {
         return 256;
@@ -2669,7 +2900,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.smoothedTickTimeMillis;
     }
 
+    // Canvas start
+
+    @Override
+    public void skipTickWait() {
+        this.delayedTasksMaxNextTickTimeNanos = Util.getNanos();
+        this.nextTickTimeNanos = Util.getNanos();
+    }
+
+    @Override
     public ServerTickRateManager tickRateManager() {
+    // Canvas end
         return this.tickRateManager;
     }
 
@@ -2926,6 +3167,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static MinecraftServer getServer() {
         return SERVER; // Paper
     }
+    // Canvas start
+
+    public static ThreadedServer getThreadedServer() {
+        return THREADED_SERVER;
+    }
+    // Canvas end
 
     @Deprecated
     public static RegistryAccess getDefaultRegistryAccess() {
@@ -3146,7 +3393,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return ServerLinks.EMPTY;
     }
 
-    protected int pauseWhileEmptySeconds() {
+    public int pauseWhileEmptySeconds() { // Canvas - protected -> public
         return 0;
     }
 
diff --git a/src/main/java/net/minecraft/server/ServerTickRateManager.java b/src/main/java/net/minecraft/server/ServerTickRateManager.java
index 37dcf3dc3e50afd85912a7496c828576a38a4e9c..dd32d97752d4d78abafcaecfd28842c116a2bbe9 100644
--- a/src/main/java/net/minecraft/server/ServerTickRateManager.java
+++ b/src/main/java/net/minecraft/server/ServerTickRateManager.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import io.github.dueris.canvas.server.level.TickRateManagerInstance;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.game.ClientboundTickingStatePacket;
 import net.minecraft.network.protocol.game.ClientboundTickingStepPacket;
@@ -14,9 +15,9 @@ public class ServerTickRateManager extends TickRateManager {
     private long sprintTimeSpend = 0L;
     private long scheduledCurrentSprintTicks = 0L;
     private boolean previousIsFrozen = false;
-    private final MinecraftServer server;
+    private final TickRateManagerInstance server; // Canvas
 
-    public ServerTickRateManager(MinecraftServer server) {
+    public ServerTickRateManager(TickRateManagerInstance server) { // Canvas
         this.server = server;
     }
 
@@ -31,11 +32,11 @@ public class ServerTickRateManager extends TickRateManager {
     }
 
     private void updateStateToClients() {
-        this.server.getPlayerList().broadcastAll(ClientboundTickingStatePacket.from(this));
+        this.server.broadcastPacketsToPlayers(ClientboundTickingStatePacket.from(this)); // Canvas
     }
 
     private void updateStepTicks() {
-        this.server.getPlayerList().broadcastAll(ClientboundTickingStepPacket.from(this));
+        this.server.broadcastPacketsToPlayers(ClientboundTickingStepPacket.from(this)); // Canvas
     }
 
     public boolean stepGameIfPaused(int ticks) {
@@ -132,4 +133,15 @@ public class ServerTickRateManager extends TickRateManager {
         player.connection.send(ClientboundTickingStatePacket.from(this));
         player.connection.send(ClientboundTickingStepPacket.from(this));
     }
+    // Canvas start
+
+    private boolean unlocked = false;
+
+    public void toggleUnlockTickRate(boolean unlocked) {
+        this.unlocked = unlocked;
+    }
+
+    public boolean isUnlockedTickRate() {
+        return unlocked;
+    }
 }
diff --git a/src/main/java/net/minecraft/server/commands/FillCommand.java b/src/main/java/net/minecraft/server/commands/FillCommand.java
index 0509e28f79d13615b5baefc34799b0ad2df071be..568c24ebd3fc98bef7a7b9865b675aa828dbe3e9 100644
--- a/src/main/java/net/minecraft/server/commands/FillCommand.java
+++ b/src/main/java/net/minecraft/server/commands/FillCommand.java
@@ -161,6 +161,8 @@ public class FillCommand {
         } else {
             List<BlockPos> list = Lists.newArrayList();
             ServerLevel serverLevel = source.getLevel();
+            // Canvas start - move to level-main
+            serverLevel.schedule(serverLevel.wrapRunnable(() -> {
             int k = 0;
 
             for (BlockPos blockPos : BlockPos.betweenClosed(range.minX(), range.minY(), range.minZ(), range.maxX(), range.maxY(), range.maxZ())) {
@@ -183,12 +185,19 @@ public class FillCommand {
             }
 
             if (k == 0) {
-                throw ERROR_FAILED.create();
+                try {
+                    throw ERROR_FAILED.create();
+                } catch (CommandSyntaxException e) {
+                    source.sendFailure(Component.literal(ERROR_FAILED.create().getMessage()));
+                    throw new RuntimeException("Unable to execute command", e);
+                }
             } else {
                 int l = k;
                 source.sendSuccess(() -> Component.translatable("commands.fill.success", l), true);
-                return k;
             }
+            }));
+            return 0;
+            // Canvas end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/commands/TickCommand.java b/src/main/java/net/minecraft/server/commands/TickCommand.java
index 13d96b54f48d60b098b80e04ba6168762c335c75..f8380522eb3e4ef7c4e0b41236fc3c27ac9a259f 100644
--- a/src/main/java/net/minecraft/server/commands/TickCommand.java
+++ b/src/main/java/net/minecraft/server/commands/TickCommand.java
@@ -1,23 +1,161 @@
 package net.minecraft.server.commands;
 
 import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.Message;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.command.ThreadedTickDiagnosis;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.commands.SharedSuggestionProvider;
 import net.minecraft.commands.arguments.TimeArgument;
+import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.TimeUtil;
+import org.jetbrains.annotations.NotNull;
 
 public class TickCommand {
     private static final float MAX_TICKRATE = 10000.0F;
     private static final String DEFAULT_TICKRATE = String.valueOf(20);
+    // Canvas start
+    private static final String UNCAPPED_TICKRATE = String.valueOf(-1);
+    private static final String[] RATE_SUGGESTIONS = new String[]{DEFAULT_TICKRATE, UNCAPPED_TICKRATE};
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        if (Config.INSTANCE.enableCanvasTickCommand) {
+            dispatcher.register(
+                Commands.literal("threadedtick")
+                    .requires(source -> source.hasPermission(3))
+                    .then(Commands.literal("diagnosis").executes(context -> {
+                        CommandSourceStack commandSourceStack = context.getSource();
+                        ThreadedTickDiagnosis.execute(commandSourceStack.getBukkitSender());
+                        return 1;
+                    }))
+                    .then(
+                        Commands.argument("threadstate", StringArgumentType.word())
+                            .suggests((_, builder) -> SharedSuggestionProvider.suggest(getThreadStates(), builder))
+                            .then(Commands.literal("rate")
+                                .then(Commands.argument("rate", FloatArgumentType.floatArg(-1.0F, 10000.0F))
+                                    .suggests((_, suggestionsBuilder) -> SharedSuggestionProvider.suggest(RATE_SUGGESTIONS, suggestionsBuilder)).executes(context -> {
+                                        float rate = FloatArgumentType.getFloat(context, "rate");
+                                        execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                            if (rate == -1) {
+                                                serverTickRateManager.toggleUnlockTickRate(true);
+                                            } else if (rate > 0) {
+                                                serverTickRateManager.setTickRate(rate);
+                                            }
+                                        });
+                                        if (rate == -1) {
+                                            context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate."), true);
+                                        } else if (rate > 0) {
+                                            String string = String.format(Locale.ROOT, "%.1f", rate);
+                                            context.getSource().sendSuccess(() -> Component.translatable("commands.tick.rate.success", string), true);
+                                        }
+                                        return 1;
+                                    })
+                                )
+                            )
+                            .then(Commands.literal("unbind").executes(context -> {
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.toggleUnlockTickRate(true);
+                                });
+                                context.getSource().sendSuccess(() -> Component.literal("Toggled unbound tickrate on thread(s)."), true);
+                                return 1;
+                            }))
+                            .then(Commands.literal("rebind").executes(context -> {
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.toggleUnlockTickRate(false);
+                                });
+                                context.getSource().sendSuccess(() -> Component.literal("Rebound tickrate to thread(s)."), true);
+                                return 1;
+                            }))
+                            .then(Commands.literal("unfreeze").executes(context -> {
+                                boolean frozen = false;
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    serverTickRateManager.setFrozen(frozen);
+                                    context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.running"), true);
+                                });
+                                return 1;
+                            }))
+                            .then(Commands.literal("freeze").executes(context -> {
+                                boolean frozen = true;
+                                execute(StringArgumentType.getString(context, "threadstate"), (serverTickRateManager) -> {
+                                    if (serverTickRateManager.isSprinting()) {
+                                        serverTickRateManager.stopSprinting();
+                                    }
+
+                                    if (serverTickRateManager.isSteppingForward()) {
+                                        serverTickRateManager.stopStepping();
+                                    }
+
+                                    serverTickRateManager.setFrozen(frozen);
+                                    context.getSource().sendSuccess(() -> Component.translatable("commands.tick.status.frozen"), true);
+                                });
+                                return 1;
+                            }))
+                    )
+            );
+        }
+        tickCommand(dispatcher);
+    }
+
+    public static void execute(@NotNull String state, Consumer<ServerTickRateManager> action) throws CommandSyntaxException {
+        if (state.equalsIgnoreCase("global")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+            for (final ServerLevel level : MinecraftServer.getThreadedServer().getAllLevels()) {
+                action.accept((ServerTickRateManager) level.tickRateManager());
+            }
+        } else if (state.equalsIgnoreCase("main")) {
+            action.accept(MinecraftServer.getServer().tickRateManager());
+        } else {
+            if (!state.contains(":")) {
+                Message message = Component.literal("State isn't valid or known: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            ResourceLocation location = ResourceLocation.parse(state);
+            ServerLevel level = MinecraftServer.getServer().getLevel(ResourceKey.create(Registries.DIMENSION, location));
+            if (level == null) {
+                Message message = Component.literal("Couldn't build level: " + state);
+                throw new CommandSyntaxException(new SimpleCommandExceptionType(message), message);
+            }
+            action.accept((ServerTickRateManager) level.tickRateManager());
+        }
+    }
+
+    private static String[] getThreadStates() {
+        List<String> states = new ArrayList<>();
+        states.add("global");
+        states.add("main");
+        states.addAll(MinecraftServer.getThreadedServer().getAllLevels()
+            .stream()
+            .map(ServerLevel::dimension)
+            .map(ResourceKey::location)
+            .map(ResourceLocation::toString).collect(Collectors.toSet()));
+        return states.toArray(new String[0]);
+    }
+
+    /**
+     * @deprecated Use threadedtick command instead of this. This runs on a global
+     * state, while threadedtick can be more powerful for specific contexts.
+     */
+    @Deprecated(forRemoval = true)
+    private static void tickCommand(CommandDispatcher<CommandSourceStack> dispatcher) {
+        // Canvas end
         dispatcher.register(
             Commands.literal("tick")
                 .requires(source -> source.hasPermission(3))
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index df035169ea89c4078e9a9226ac6e752f29d585a1..128ee3ff8457bb7c62b81436502f258421d95f98 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -1,24 +1,20 @@
 package net.minecraft.server.dedicated;
 
-import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
 import javax.annotation.Nullable;
+
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
@@ -64,8 +60,6 @@ import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.io.IoBuilder;
 import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.util.TerminalCompletionHandler;
-import org.bukkit.craftbukkit.util.TerminalConsoleWriterThread;
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 // CraftBukkit end
@@ -243,6 +237,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash); // Paper - start watchdog thread
         thread.start(); // Paper - Enhance console tab completions for brigadier commands; start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
+        io.github.dueris.canvas.command.CanvasCommands.registerCommands(this); // Canvas - register commands
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         // Purpur start - Purpur config files
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 8dd9375f2ad2c65a773a3195aeff1f977e09e7e0..85bed17924071fc73d42e44778b103ae5e01410e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -9,6 +9,7 @@ import java.util.concurrent.Executor;
 import java.util.function.IntConsumer;
 import java.util.function.IntSupplier;
 import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.shorts.ShortSets;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -318,7 +319,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
                                 this.broadcastBlockEntityIfNeeded(list, world, blockposition, iblockdata);
                             } else {
                                 LevelChunkSection chunksection = chunk.getSection(i);
-                                ClientboundSectionBlocksUpdatePacket packetplayoutmultiblockchange = new ClientboundSectionBlocksUpdatePacket(sectionposition, shortset, chunksection);
+                                ClientboundSectionBlocksUpdatePacket packetplayoutmultiblockchange = new ClientboundSectionBlocksUpdatePacket(sectionposition, ShortSets.synchronize(shortset), chunksection); // Canvas
 
                                 this.broadcast(list, packetplayoutmultiblockchange);
                                 // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index cfeeddf2cb4ff50dbc29c6913e78ca1dee076790..4c477ab3529a423cc8fb752c58e3b702c19bc2b6 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -8,6 +8,9 @@ import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.github.dueris.canvas.util.fastutil.Long2ByteConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -38,6 +41,7 @@ import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
@@ -131,7 +135,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final ChunkGeneratorStructureState chunkGeneratorState;
     private final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop;
+    public final ConcurrentSet<Long> toDrop;
     private boolean modified;
     // Paper - rewrite chunk system
     public final ChunkProgressListener progressListener;
@@ -183,11 +187,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new RegionStorageInfo(session.getLevelId(), world.dimension(), "chunk"), session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - rewrite chunk system
-        this.toDrop = new LongOpenHashSet();
+        this.toDrop = new ConcurrentSet<>(); // Canvas
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
-        this.chunkTypeCache = new Long2ByteOpenHashMap();
+        // Canvas start
+        this.entityMap = new Int2ObjectConcurrentHashMap<>();
+        this.chunkTypeCache = new Long2ByteConcurrentHashMap();
+        // Canvas end
         // Paper - rewrite chunk system
         Path path = session.getDimensionPath(world.dimension());
 
@@ -917,7 +923,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
                         while (objectiterator.hasNext()) {
                             ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -937,7 +943,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer entityplayer) {
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -963,13 +969,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) continue; // Canvas - NPE
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkData().nearbyPlayers);
+            ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity cse =  ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity); ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(cse.moonrise$getChunkData() == null ? null : cse.moonrise$getChunkData().nearbyPlayers);
+            @Nullable FullChunkStatus chunkStatus = ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus(); // Canvas
             if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$hasPlayers()
-                || ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$getChunkStatus().isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+                || (chunkStatus != null && chunkStatus.isOrAfter(FullChunkStatus.ENTITY_TICKING))) { // Canvas
                 tracker.serverEntity.sendChanges();
             }
         }
@@ -987,7 +995,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 1c87904bb99cc40bafc9357fb2fc1703b759c3df..621abfb5d9790a823d4580d138b793732b79d597 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -3,6 +3,7 @@ package net.minecraft.server.level;
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import java.io.IOException;
 import java.nio.file.Path;
@@ -57,7 +58,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private static final Logger LOGGER = LogUtils.getLogger();
     private final DistanceManager distanceManager;
     private final ServerLevel level;
-    public final Thread mainThread;
+    public Thread mainThread; // Canvas - mutable
     final ThreadedLevelLightEngine lightEngine;
     public final ServerChunkCache.MainThreadExecutor mainThreadProcessor;
     public final ChunkMap chunkMap;
@@ -70,7 +71,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
     private final List<LevelChunk> tickingChunks = new ArrayList();
-    private final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceOpenHashSet();
+    private final Set<ChunkHolder> chunkHoldersToBroadcast = new ConcurrentSet<>(); // Canvas - use concurrent equivalent
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
@@ -414,7 +415,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return this.mainThreadProcessor.pollTask();
     }
 
-    public boolean runDistanceManagerUpdates() { // Paper - public
+    public synchronized boolean runDistanceManagerUpdates() { // Paper - public
         return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
@@ -470,9 +471,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         this.runDistanceManagerUpdates();
         gameprofilerfiller.popPush("chunks");
         if (tickChunks) {
+            synchronized (this) { // Canvas - Multithreaded Dimension Ticking - only 1 thread can tick this instance at a time
             ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
             this.tickChunks();
             this.chunkMap.tick();
+            } // Canvas
         }
 
         gameprofilerfiller.popPush("unload");
@@ -542,6 +545,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         for (int i = 0; i < size; ++i) {
             final ServerChunkCache.ChunkAndHolder chunkAndHolder = raw[i];
+            if (chunkAndHolder == null) continue; // Canvas - NPE
             final LevelChunk levelChunk = chunkAndHolder.chunk();
 
             if (!this.isChunkNearPlayer(chunkMap, levelChunk.getPos(), levelChunk)) {
@@ -820,6 +824,16 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             super.doRunTask(task);
         }
 
+        @Override
+        public void execute(final Runnable runnable) {
+            ServerLevel level = ServerChunkCache.this.level;
+            if (level.isTicking()) {
+                level.execute(runnable);
+            } else {
+                super.execute(runnable);
+            }
+        }
+
         @Override
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1b647544ebd578d1f8fbb6b65a2c27ac07761683..2ba14ee3f72bf7b3c826968eee381cd65d402c2a 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -5,6 +5,11 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.server.ThreadedServer;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.util.QueuedTaskScheduler;
+import io.github.dueris.canvas.util.fastutil.Int2ObjectConcurrentHashMap;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -16,20 +21,28 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.io.BufferedWriter;
+import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -41,6 +54,7 @@ import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -50,9 +64,12 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
@@ -60,7 +77,9 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundExplodePacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -68,7 +87,10 @@ import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.network.ServerConnectionListener;
 import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
@@ -82,6 +104,7 @@ import net.minecraft.util.Unit;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.DifficultyInstance;
@@ -196,7 +219,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = Lists.newCopyOnWriteArrayList(); // Canvas
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -211,22 +234,23 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet();
+    final Set<Mob> navigatingMobs = new ConcurrentSet<>(); // Canvas
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet();
-    private final List<BlockEventData> blockEventsToReschedule = new ArrayList(64);
+    private final List<BlockEventData> blockEvents = new CopyOnWriteArrayList<>(); // Canvas
+    private final Queue<BlockEventData> blockEventsToReschedule = new ConcurrentLinkedQueue<>(); // Canvas
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap();
+    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectConcurrentHashMap<>(); // Canvas
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private double preciseTime; // Purpur - Configurable daylight cycle
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
+    public final QueuedTaskScheduler taskScheduler = new QueuedTaskScheduler(); // Canvas
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess convertable;
@@ -235,6 +259,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
+    private int emptyTicks; // Canvas
+    private int sendAllPlayerInfoIn; // Canvas
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -730,11 +756,136 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public StructureManager structureManager() {
         return this.structureManager;
     }
+    // Canvas start - Multithreaded Dimension Ticking
 
-    public void tick(BooleanSupplier shouldKeepTicking) {
-        ProfilerFiller gameprofilerfiller = Profiler.get();
+        private final List<Connection> activeConnections = new ObjectArrayList<>();
+    private final Object lock = new Object();
+
+    public void notifyNewConnection(Connection connection) {
+        synchronized (lock) {
+            activeConnections.add(connection);
+        }
+    }
+
+    public void removeConnection(Connection connection) {
+        synchronized (lock)  {
+            activeConnections.remove(connection);
+        }
+    }
+
+    private boolean tickEmptyLevel() {
+        if (this.server.isEmptyTickSkipping()) {
+            return true;
+        }
+        int serverEmptySecondsLimit = this.server.pauseWhileEmptySeconds() * 20;
+        if (serverEmptySecondsLimit > 0 && Config.INSTANCE.emptySleepPerWorlds) {
+            if (this.players.isEmpty() && !this.tickRateManager.isSprinting() && this.server.pluginsBlockingSleep.isEmpty()) {
+                ++this.emptyTicks;
+            } else {
+                this.emptyTicks = 0;
+            }
+
+            if (this.emptyTicks >= serverEmptySecondsLimit) {
+                if (this.emptyTicks == serverEmptySecondsLimit) {
+                    MinecraftServer.LOGGER.info("Level empty for {} seconds, pausing", this.server.pauseWhileEmptySeconds());
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    protected void tickConnection() {
+        for (ServerPlayer player : this.players) {
+            player.connection.suspendFlushing();
+        }
+        Iterator<Connection> iterator = this.activeConnections.iterator();
+        while (iterator.hasNext()) {
+            Connection networkmanager = iterator.next();
+
+            if (!networkmanager.isConnecting()) {
+                if (networkmanager.isConnected()) {
+                    try {
+                        networkmanager.tick();
+                    } catch (Exception exception) {
+                        if (networkmanager.isMemoryConnection()) {
+                            throw new ReportedException(CrashReport.forThrowable(exception, "Ticking memory connection"));
+                        }
+
+                        LOGGER.warn("Failed to handle packet for {}", networkmanager.getLoggableAddress(this.server.logIPs()), exception);
+                        MutableComponent ichatmutablecomponent = Component.literal("Internal server error");
 
+                        networkmanager.send(new ClientboundDisconnectPacket(ichatmutablecomponent), PacketSendListener.thenRun(() -> {
+                            networkmanager.disconnect(ichatmutablecomponent);
+                        }));
+                        networkmanager.setReadOnly();
+                    }
+                } else {
+                    if (networkmanager.preparing) continue;
+                    iterator.remove();
+                    networkmanager.handleDisconnection();
+                }
+            }
+        }
+    }
+
+    public void syncTimeToPlayers() {
+        ClientboundSetTimePacket timePacket = new ClientboundSetTimePacket(getGameTime(), getDayTime(), getGameRules().getBoolean(GameRules.RULE_DAYLIGHT));
+        for (final ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.connection.send(timePacket);
+            }
+        }
+    }
+
+    public void tickPlayerList() {
+        if (!Config.INSTANCE.runPlayerListTickOnIndependentLevel) return;
+        if (++this.sendAllPlayerInfoIn > 600) {
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = this.players.get(i);
+
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.getServer().getPlayerList().
+                    players.stream().filter(input -> target.getBukkitEntity().canSee(input.getBukkitEntity())).collect(Collectors.toList())));
+            }
+            this.sendAllPlayerInfoIn = 0;
+        }
+
+    }
+
+    public void tick(BooleanSupplier shouldKeepTicking, int tickCount) {
+        this.tickRateManager.tick();
+        this.tickConnection();
+
+        if (this.tickEmptyLevel()) {
+            return;
+        }
+        // Mark handling tick AFTER ticking empty level check
         this.handlingTick = true;
+
+        for (final Entity entity : this.getEntities().getAll()) {
+            if (entity.isRemoved()) {
+                continue;
+            }
+            final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+            if (bukkit != null) {
+                bukkit.taskScheduler.executeTick();
+            }
+        }
+        chunkSource.tick(() -> true, false);
+
+        if (this.tickCount % Config.INSTANCE.timeResyncInterval == 0) {
+            // Resync time every configurable amount of ticks
+            syncTimeToPlayers();
+        }
+
+        hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+        hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+        net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+        updateLagCompensationTick();
+        hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+    // Canvas end
+        ProfilerFiller gameprofilerfiller = Profiler.get();
+
         TickRateManager tickratemanager = this.tickRateManager();
         boolean flag = tickratemanager.runsNormally();
 
@@ -844,6 +995,14 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         gameprofilerfiller.push("entityManagement");
         // Paper - rewrite chunk system
         gameprofilerfiller.pop();
+        // Canvas start - Threaded Dimensions
+        tickPlayerList();
+        for (ServerPlayer player : this.players) {
+            player.connection.chunkSender.sendNextChunks(player);
+            player.connection.resumeFlushing();
+        }
+        explosionDensityCache.clear();
+        // Canvas end
     }
 
     @Override
@@ -910,6 +1069,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         (this.players.stream().filter(LivingEntity::isSleeping).collect(Collectors.toList())).forEach((entityplayer) -> { // CraftBukkit - decompile error
             entityplayer.stopSleepInBed(false, false);
         });
+        this.syncTimeToPlayers(); // Canvas - ensure time resync
     }
 
     // Paper start - optimise random ticking
@@ -1256,25 +1416,28 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.server.getPlayerList().broadcastAll(new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.THUNDER_LEVEL_CHANGE, this.thunderLevel));
         }
         // */
-        for (int idx = 0; idx < this.players.size(); ++idx) {
-            if (((ServerPlayer) this.players.get(idx)).level() == this) {
-                ((ServerPlayer) this.players.get(idx)).tickWeather();
+        // Canvas start
+        for (ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.tickWeather();
             }
         }
 
         if (flag != this.isRaining()) {
             // Only send weather packets to those affected
-            for (int idx = 0; idx < this.players.size(); ++idx) {
-                if (((ServerPlayer) this.players.get(idx)).level() == this) {
-                    ((ServerPlayer) this.players.get(idx)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+            for (ServerPlayer player : this.players) {
+                if (player.level() == this) {
+                    player.setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
                 }
             }
         }
-        for (int idx = 0; idx < this.players.size(); ++idx) {
-            if (((ServerPlayer) this.players.get(idx)).level() == this) {
-                ((ServerPlayer) this.players.get(idx)).updateWeather(this.oRainLevel, this.rainLevel, this.oThunderLevel, this.thunderLevel);
+
+        for (ServerPlayer player : this.players) {
+            if (player.level() == this) {
+                player.updateWeather(this.oRainLevel, this.rainLevel, this.oThunderLevel, this.thunderLevel);
             }
         }
+        // Canvas end
         // CraftBukkit end
 
     }
@@ -2143,8 +2306,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     @Override
-    public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+    public ServerTickRateManager tickRateManager() { // Canvas
+        return this.tickRateManager; // Canvas
     }
 
     @Override
@@ -2616,7 +2779,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public void onStructureStartsAvailable(ChunkAccess chunk) {
-        this.server.execute(() -> {
+        ((BlockableEventLoop<?>) (MinecraftServer.getThreadedServer().hasStarted() ? this : this.server)).execute(() -> { // Canvas - run on our own thread if possible
             this.structureCheck.onStructureLoad(chunk.getPos(), chunk.getAllStarts());
         });
     }
@@ -2626,7 +2789,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     @Override
-    public void close() throws IOException {
+    public void close() { // Canvas
         super.close();
         // Paper - rewrite chunk system
     }
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index df48c2754dc1ebd52addd8ae768cba5916ce3969..97821960dd297892f97fa001a0000a6b3fe08b36 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -4,6 +4,7 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.logging.LogUtils;
 import java.util.Objects;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -237,7 +238,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
     @Override
     public void handleResourcePackResponse(ServerboundResourcePackPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, (BlockableEventLoop) this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (packet.action() == ServerboundResourcePackPacket.Action.DECLINED && this.server.isResourcePackRequired()) {
             ServerCommonPacketListenerImpl.LOGGER.info("Disconnecting {} due to resource pack {} rejection", this.playerProfile().getName(), packet.id());
             this.disconnect((Component) Component.translatable("multiplayer.requiredTexturePrompt.disconnect"), PlayerKickEvent.Cause.RESOURCE_PACK_REJECTION); // Paper - kick event cause
@@ -265,7 +266,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     @Override
     public void handleCookieResponse(ServerboundCookieResponsePacket packet) {
         // CraftBukkit start
-        PacketUtils.ensureRunningOnSameThread(packet, this, (BlockableEventLoop) this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.player.getBukkitEntity().handleCookieResponse(packet)) {
             return;
         }
diff --git a/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
index 880e5c52746e9e3a9a1f42ec6461be54e3ee136c..a4bc2a915399356365c8bd8c21db8ba60c37b64b 100644
--- a/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerConfigurationPacketListenerImpl.java
@@ -138,7 +138,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
 
     @Override
     public void handleSelectKnownPacks(ServerboundSelectKnownPacks packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, (BlockableEventLoop) this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.synchronizeRegistriesTask == null) {
             throw new IllegalStateException("Unexpected response from client: received pack selection, but no negotiation ongoing");
         } else {
@@ -149,7 +149,7 @@ public class ServerConfigurationPacketListenerImpl extends ServerCommonPacketLis
 
     @Override
     public void handleConfigurationFinished(ServerboundFinishConfigurationPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, (BlockableEventLoop) this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         this.finishCurrentTask(JoinWorldTask.TYPE);
         this.connection.setupOutboundProtocol(GameProtocols.CLIENTBOUND_TEMPLATE.bind(RegistryFriendlyByteBuf.decorator(this.server.registryAccess())));
 
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 3a9e25b436f366fffe08c3b0c1fce11ed42ee646..95956dc19ac6ed55fb3038a3996643cb7afa3025 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -4,6 +4,7 @@ import com.google.common.base.Suppliers;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.Config;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
@@ -29,6 +30,7 @@ import io.netty.util.Timer;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.SocketAddress;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -238,9 +240,19 @@ public class ServerConnectionListener {
             }
             // Spigot End
             Iterator<Connection> iterator = this.connections.iterator();
-
+            List<Connection> pendingRemoval = new ArrayList<>(); // Canvas
             while (iterator.hasNext()) {
-                Connection networkmanager = (Connection) iterator.next();
+                // Canvas start
+                Connection networkmanager = iterator.next();
+                if (networkmanager.getPlayer() != null && networkmanager.getPlayer().serverLevel() != null) {
+                    // Player is ready to be transferred off main
+                    networkmanager.transferToLevel(networkmanager.getPlayer().serverLevel());
+                    pendingRemoval.add(networkmanager);
+                    continue;
+                }
+                if (networkmanager.getHoldingLevel() != null)
+                    continue;
+                // Canvas end
 
                 if (!networkmanager.isConnecting()) {
                     if (networkmanager.isConnected()) {
@@ -269,6 +281,7 @@ public class ServerConnectionListener {
                     }
                 }
             }
+            pendingRemoval.forEach(this.connections::remove); // Canvas
 
         }
     }
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 5b33034f01c05b29cd1a90847aa27b356a02264f..4ac648ad65ff54243799c78464430de04ad38e0e 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1924,6 +1924,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handlePlayerAction(ServerboundPlayerActionPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        // Canvas start - ensure level main
+        if (!this.player.serverLevel().isSameThread()) {
+            throw new RuntimeException("Unable to process action packet off-level!");
+        }
+        // Canvas end
         if (this.player.isImmobile()) return; // CraftBukkit
         if (this.player.hasClientLoaded()) {
             BlockPos blockposition = packet.getPos();
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 16069b9cbf6c7679c28a2e9a54e77d23cd10e541..79be4bf61e2ae13920b170ffbd0c1eec6c58f224 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -455,7 +455,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     @Override
     public void handleLoginAcknowledgement(ServerboundLoginAcknowledgedPacket packet) {
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server); // CraftBukkit
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // CraftBukkit // Canvas
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.PROTOCOL_SWITCHING, "Unexpected login acknowledgement packet", new Object[0]);
         this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
         CommonListenerCookie commonlistenercookie = CommonListenerCookie.createInitial((GameProfile) Objects.requireNonNull(this.authenticatedProfile), this.transferred);
@@ -476,7 +476,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     @Override
     public void handleCookieResponse(ServerboundCookieResponsePacket packet) {
         // CraftBukkit start
-        PacketUtils.ensureRunningOnSameThread(packet, this, this.server);
+        PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Canvas
         if (this.player != null && this.player.getBukkitEntity().handleCookieResponse(packet)) {
             return;
         }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 5b1705794a8c3914cb11fdd35f75c8e0c128ecd0..0eb0818368deacc31861b397b4cdb2b7a021661a 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -12,6 +12,7 @@ import java.net.SocketAddress;
 import java.nio.file.Path;
 import java.text.SimpleDateFormat;
 import java.time.Instant;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
@@ -24,6 +25,7 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -364,7 +366,7 @@ public abstract class PlayerList {
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
 
-        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
+        final List<ServerPlayer> onlinePlayers = new ArrayList<>(); // Paper - Use single player info update packet on join // Canvas - don't use expected size
         for (int i = 0; i < this.players.size(); ++i) {
             ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
 
@@ -517,7 +519,7 @@ public abstract class PlayerList {
         return optional;
     }
 
-    protected void save(ServerPlayer player) {
+    public void save(ServerPlayer player) { // Canvas - protected -> public
         if (!player.getBukkitEntity().isPersistent()) return; // CraftBukkit
         player.lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
         this.playerIo.save(player);
@@ -945,6 +947,7 @@ public abstract class PlayerList {
     }
 
     public void tick() {
+        if (Config.INSTANCE.runPlayerListTickOnIndependentLevel) return; // Canvas - moved to level threads
         if (++this.sendAllPlayerInfoIn > 600) {
             // CraftBukkit start
             for (int i = 0; i < this.players.size(); ++i) {
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 9b706276dc5b5f55b966c5472c6c4e864342b916..e985b6bdaabfe26b1ca675d5c704544392a8e773 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -6,6 +6,7 @@ import com.mojang.jtracy.TracyClient;
 import com.mojang.jtracy.Zone;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -13,8 +14,11 @@ import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import javax.annotation.CheckReturnValue;
+import io.github.dueris.canvas.server.level.MinecraftServerWorld;
+import io.github.dueris.canvas.server.level.TickRateManagerInstance;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.util.profiling.metrics.MetricSampler;
 import net.minecraft.util.profiling.metrics.MetricsRegistry;
@@ -125,18 +129,42 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            // Canvas start - Multithreaded Dimension Ticking
+            // This can technically throw a NSE now, so we catch and ignore
+            try {
+                R a = this.pendingRunnables.remove();
+                this.doRunTask(a);
+            } catch (NoSuchElementException ignored) {
+                return false;
+            }
+            // Canvas end
             return true;
         }
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
         this.blockingCount++;
+        /* // Canvas start
+        if (this instanceof MinecraftServer && !Thread.currentThread().equals(getRunningThread())) {
+            throw new RuntimeException("Unable to block main thread from off-main");
+        }
+        if (this instanceof MinecraftServerWorld && !Thread.currentThread().equals(getRunningThread())) {
+            throw new RuntimeException("Unable to block level thread from off-level");
+        }
+        */ // Canvas end
 
         try {
             while (!stopCondition.getAsBoolean()) {
                 if (!this.pollTask()) {
+                    // Canvas start
+                    if (this instanceof TickRateManagerInstance tickRateManagerInstance && !tickRateManagerInstance.tickRateManager().isUnlockedTickRate()) {
                     this.waitForTasks();
+                    } else if (this instanceof TickRateManagerInstance tickRateManagerInstance) {
+                        // Skipping because unlocked
+                        tickRateManagerInstance.skipTickWait();
+                        break;
+                    }
+                    // Canvas end
                 }
             }
         } finally {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c00a48fef499bc3b18a92010d88b32f10c839898..84c28d8f4fd4c9f1f415035c98181f1fede4d79c 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -7,6 +7,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 import it.unimi.dsi.fastutil.doubles.DoubleListIterator;
 import it.unimi.dsi.fastutil.floats.FloatArraySet;
@@ -26,6 +27,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -354,7 +356,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     private BlockState inBlockState;
     private final List<Entity.Movement> movementThisTick;
     private final Set<BlockState> blocksInside;
-    private final LongSet visitedBlocks;
+    private final Set<Long> visitedBlocks; // Canvas
     // CraftBukkit start
     public boolean forceDrops;
     public boolean persist = true;
@@ -614,9 +616,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.mainSupportingBlockPos = Optional.empty();
         this.onGroundNoBlocks = false;
         this.inBlockState = null;
-        this.movementThisTick = new ArrayList();
-        this.blocksInside = new ReferenceArraySet();
-        this.visitedBlocks = new LongOpenHashSet();
+        // Canvas start
+        this.movementThisTick = new CopyOnWriteArrayList<>();
+        this.blocksInside = new ConcurrentSet<>();
+        this.visitedBlocks = new ConcurrentSet<>();
+        // Canvas end
         this.type = type;
         this.level = world;
         this.dimensions = type.getDimensions();
@@ -1484,8 +1488,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     protected BlockPos getOnPos(float offset) {
+        // Canvas start
+        int i = Mth.floor(this.position.x);
+        int j = Mth.floor(this.position.y - (double) offset);
+        int k = Mth.floor(this.position.z);
+        BlockPos fallback = new BlockPos(i, j, k);
+        // Canvas end
         if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
-            BlockPos blockposition = (BlockPos) this.mainSupportingBlockPos.get();
+            BlockPos blockposition = this.mainSupportingBlockPos.orElse(fallback); // Canvas - fallback
 
             if (offset <= 1.0E-5F) {
                 return blockposition;
@@ -1495,11 +1505,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 return ((double) offset > 0.5D || !iblockdata.is(BlockTags.FENCES)) && !iblockdata.is(BlockTags.WALLS) && !(iblockdata.getBlock() instanceof FenceGateBlock) ? blockposition.atY(Mth.floor(this.position.y - (double) offset)) : blockposition;
             }
         } else {
-            int i = Mth.floor(this.position.x);
-            int j = Mth.floor(this.position.y - (double) offset);
-            int k = Mth.floor(this.position.z);
-
-            return new BlockPos(i, j, k);
+            return fallback; // Canvas - fallback
         }
     }
 
@@ -1759,7 +1765,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     private void checkInsideBlocks(List<Entity.Movement> queuedCollisionChecks, Set<BlockState> collidedBlocks) {
         if (this.isAffectedByBlocks()) {
-            LongSet longset = this.visitedBlocks;
+            Set<Long> longset = this.visitedBlocks; // Canvas
             Iterator iterator = queuedCollisionChecks.iterator();
 
             while (iterator.hasNext()) {
@@ -4069,6 +4075,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     private Entity teleportCrossDimension(ServerLevel world, TeleportTransition teleportTarget) {
+        if (this instanceof ServerPlayer player) {
+            player.serverLevel().notifyNewConnection(player.connection.connection);
+        }
         List<Entity> list = this.getPassengers();
         List<Entity> list1 = new ArrayList(list.size());
 
@@ -4998,6 +5007,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         if (this.inBlockState == null) {
             this.inBlockState = this.level().getBlockState(this.blockPosition());
         }
+        // Canvas start -- why is it still null... - iirc this only happens when the player is in an ungenerated/generating chunk, fallback to air
+
+        if (this.inBlockState == null) {
+            this.inBlockState = Blocks.AIR.defaultBlockState();
+        }
+        // Canvas end
 
         return this.inBlockState;
     }
@@ -5095,6 +5110,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.setPosRaw(x, y, z, false);
     }
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
+        // Canvas start - ensure section status is caught
+        if (this.updatingSectionStatus) {
+            final double fx = x;
+            final double fy = y;
+            final double fz = z;
+            ((ServerLevel)this.level()).chunkSource.mainThreadProcessor.execute(() -> {
+                this.setPosRaw(fx, fy, fz, forceBoundingBoxUpdate);
+            });
+            return;
+        }
+        // Canvas end
+        // Paper end - Block invalid positions and bounding box
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
@@ -5237,7 +5264,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public final void setRemoved(Entity.RemovalReason entity_removalreason, EntityRemoveEvent.Cause cause) {
         // Paper start - rewrite chunk system
         if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
-            LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
+            // LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable()); // Canvas - its fine, we try again on the next tick and it works out
             return;
         }
         // Paper end - rewrite chunk system
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 1aa251cfdf941027f529ce02f0c16c815ade296f..e2044af130738a64f327c4be8b85fb673175d4c4 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -10,9 +10,9 @@ import java.util.Objects;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.server.level.MinecraftServerWorld;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -25,14 +25,13 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.StringRepresentable;
@@ -44,7 +43,6 @@ import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -106,7 +104,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions
+public abstract class Level extends MinecraftServerWorld implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions // Canvas - Multithreaded Dimension Ticking
 
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
@@ -875,7 +873,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
     // Paper end - optimise random ticking
 
-    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray
+    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) {
+        super(resourcekey.location().toString()); // Paper - create paper world config & Anti-Xray
         // Paper start - getblock optimisations - cache world height/sections
         final DimensionType dimType = holder.value();
         this.minY = dimType.minY();
@@ -1685,8 +1684,15 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     }
 
-    public void close() throws IOException {
-        this.getChunkSource().close();
+    // Canvas start - Multithreaded Dimension Ticking
+    @Override
+    public void close() {
+        try {
+            this.getChunkSource().close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    // Canvas end
     }
 
     @Nullable
@@ -1851,7 +1857,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.levelData;
     }
 
-    public abstract TickRateManager tickRateManager();
+    public abstract ServerTickRateManager tickRateManager(); // Canvas
 
     public float getThunderLevel(float delta) {
         return Mth.lerp(delta, this.oThunderLevel, this.thunderLevel) * this.getRainLevel(delta);
diff --git a/src/main/java/net/minecraft/world/level/block/LeavesBlock.java b/src/main/java/net/minecraft/world/level/block/LeavesBlock.java
index de9cbe4868276011d69536a0532ff57fe7a77bf3..d856f527f0132be383b557fa9619c275a087d976 100644
--- a/src/main/java/net/minecraft/world/level/block/LeavesBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LeavesBlock.java
@@ -2,6 +2,7 @@ package net.minecraft.world.level.block;
 
 import com.mojang.serialization.MapCodec;
 import java.util.OptionalInt;
+import io.github.dueris.canvas.Config;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.particles.ParticleTypes;
@@ -80,7 +81,7 @@ public class LeavesBlock extends Block implements SimpleWaterloggedBlock {
 
     @Override
     protected void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
-        world.setBlock(pos, LeavesBlock.updateDistance(state, world, pos), 3);
+        if (!Config.INSTANCE.disableLeafTicking) world.setBlock(pos, LeavesBlock.updateDistance(state, world, pos), 3); // Canvas
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 97937e3bd211997f0a0a3e9e671a1c59712d0003..d29edaacf0faeea968fd14794e75d33ee8b5a201 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -679,7 +679,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
 
     // CraftBukkit start
     public void loadCallback() {
-        if (this.loadedTicketLevel) { LOGGER.error("Double calling chunk load!", new Throwable()); } // Paper
+        if (this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         // Paper start
         this.loadedTicketLevel = true;
         // Paper end
@@ -720,7 +720,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
     }
 
     public void unloadCallback() {
-        if (!this.loadedTicketLevel) { LOGGER.error("Double calling chunk unload!", new Throwable()); } // Paper
+        if (!this.loadedTicketLevel) { return; } // Paper // Canvas - shhhhh
         org.bukkit.Server server = this.level.getCraftServer();
         org.bukkit.craftbukkit.event.CraftEventFactory.callEntitiesUnloadEvent(this.level, this.chunkPos, ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(this.locX, this.locZ).getEntityChunk().getAllEntities()); // Paper - rewrite chunk system
         org.bukkit.Chunk bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index d8b4196adf955f8d414688dc451caac2d9c609d9..29e6c7ff750ff9e9f6ea6ac17e77d50f4011cfe8 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -4,12 +4,14 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    public final ConcurrentLinkedQueue<Entity> entities = new ConcurrentLinkedQueue<>(); // Paper - rewrite chunk system // Canvas
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
@@ -33,13 +35,13 @@ public class EntityTickList {
         // Paper start - rewrite chunk system
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
-        final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+        final Iterator<Entity> iterator = this.entities.iterator(); // Canvas
         try {
             while (iterator.hasNext()) {
                 action.accept(iterator.next());
             }
         } finally {
-            iterator.finishedIterating();
+            // iterator.finishedIterating(); // Canvas
         }
         // Paper end - rewrite chunk system
     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
index 99dfa36a4f00217c7f9566af988b5210d99a273c..13ebd2367b540f184104fde2859ad6ae636a5859 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
@@ -30,22 +30,21 @@ public class LegacyRandomSource implements BitRandomSource {
 
     @Override
     public void setSeed(long seed) {
-        if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", null);
-        } else {
-            this.gaussianSource.reset();
-        }
+        this.seed.set((seed ^ 25214903917L) & 281474976710655L); // Canvas - Multithreaded Dimension Ticking
     }
 
     @Override
     public int next(int bits) {
-        long l = this.seed.get();
-        long m = l * 25214903917L + 11L & 281474976710655L;
-        if (!this.seed.compareAndSet(l, m)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", null);
-        } else {
-            return (int)(m >> 48 - bits);
-        }
+        // Canvas start - Multithreaded Dimension Ticking
+        long l;
+        long m;
+        do {
+            l = this.seed.get();
+            m = l * 25214903917L + 11L & 281474976710655L;
+        } while (!this.seed.compareAndSet(l, m));
+
+        return (int)(m >>> 48 - bits);
+        // Canvas end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 3a95e3236eafd14baed035e53503b58c2e21b68a..7b84d3e78bc57b3eab6aaeb87362e29978950c7b 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -3,7 +3,9 @@ package net.minecraft.world.level.redstone;
 import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -17,7 +19,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
+    private final Deque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>(); // Canvas - fix CME/NPE
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
     private int count = 0;
 
@@ -69,8 +71,10 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
 
     private void runUpdates() {
         try {
+            synchronized (this.stack) { // Canvas
             while (!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
                 for (int i = this.addedThisLayer.size() - 1; i >= 0; i--) {
+                    if (this.addedThisLayer.get(i) == null) continue; // Canvas
                     this.stack.push(this.addedThisLayer.get(i));
                 }
 
@@ -83,7 +87,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
                         break;
                     }
                 }
-            }
+            }} // Canvas
         } finally {
             this.stack.clear();
             this.addedThisLayer.clear();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index badf280a6b01b06e8148c552330872d64e6256b7..bb3fb23318becb502682c881130312c14de168e2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -13,6 +13,7 @@ import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
+import io.github.dueris.canvas.server.ThreadedServer;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayOutputStream;
@@ -1468,6 +1469,12 @@ public final class CraftServer implements Server {
         // Paper - rewrite chunk system
 
         this.pluginManager.callEvent(new WorldLoadEvent(internal.getWorld()));
+        // Canvas start
+        if (MinecraftServer.getThreadedServer().hasStarted()) {
+            // only spin it here if the server already started
+            ThreadedServer.spinner.apply(internal.getWorld());
+        }
+        // Canvas end
         return internal.getWorld();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index c2df3c38f58d8dcb5e3d62077655af56a3bffd65..99501ebc1e45b1502556f2d112bb4ae3f5d06436 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -33,10 +33,12 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.shorts.ShortSets;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -1009,7 +1011,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             SectionPos sectionPos = entry.getKey();
             it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState> blockData = entry.getValue();
 
-            net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket packet = new net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket(sectionPos, blockData);
+            net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket packet = new net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket(sectionPos, new ConcurrentHashMap<>(blockData)); // Canvas
             this.getHandle().connection.send(packet);
         }
     }
@@ -1054,7 +1056,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private record ChunkSectionChanges(ShortSet positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
 
         public ChunkSectionChanges() {
-            this(new ShortArraySet(), new ArrayList<>());
+            this(ShortSets.synchronize(new ShortArraySet()), new ArrayList<>()); // Canvas
         }
     }
 
diff --git a/src/main/java/org/purpurmc/purpur/task/TPSBarTask.java b/src/main/java/org/purpurmc/purpur/task/TPSBarTask.java
index 8769993e7ca59da309087051a3cd38fc562c15d1..9d66807c6b7a1bf2b934a9a5e6833f6d65a671fb 100644
--- a/src/main/java/org/purpurmc/purpur/task/TPSBarTask.java
+++ b/src/main/java/org/purpurmc/purpur/task/TPSBarTask.java
@@ -4,14 +4,20 @@ import net.kyori.adventure.bossbar.BossBar;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.minimessage.MiniMessage;
 import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import org.purpurmc.purpur.PurpurConfig;
-import org.bukkit.Bukkit;
 import org.bukkit.entity.Player;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
 
 public class TPSBarTask extends BossBarTask {
     private static TPSBarTask instance;
-    private double tps = 20.0D;
-    private double mspt = 0.0D;
+    // Canvas start - Replaced doubles (tps and mspt) with maps to get data of player current world
+    private final Map<UUID, Double> tps = new HashMap<>(0);
+    private final Map<UUID, Double> mspt = new HashMap<>(0);
+    // Canvas end
     private int tick = 0;
 
     public static TPSBarTask instance() {
@@ -23,18 +29,22 @@ public class TPSBarTask extends BossBarTask {
 
     @Override
     BossBar createBossBar() {
-        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(), PurpurConfig.commandTPSBarProgressOverlay);
+        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(null), PurpurConfig.commandTPSBarProgressOverlay); // Canvas - Pass null because we need to know where's player right now to show proper data
     }
 
     @Override
     void updateBossBar(BossBar bossbar, Player player) {
-        bossbar.progress(getBossBarProgress());
-        bossbar.color(getBossBarColor());
+        // Canvas start - get player's current world UUID and pass it to some of the methods for showing TPS and MSPT of current world
+        UUID playerWorldUID = player.getWorld().getUID();
+
+        bossbar.progress(getBossBarProgress(playerWorldUID));
+        bossbar.color(getBossBarColor(playerWorldUID));
         bossbar.name(MiniMessage.miniMessage().deserialize(PurpurConfig.commandTPSBarTitle,
-                Placeholder.component("tps", getTPSColor()),
-                Placeholder.component("mspt", getMSPTColor()),
-                Placeholder.component("ping", getPingColor(player.getPing()))
+            Placeholder.component("tps", getTPSColor(playerWorldUID)),
+            Placeholder.component("mspt", getMSPTColor(playerWorldUID)),
+            Placeholder.component("ping", getPingColor(player.getPing()))
         ));
+        // Canvas end
     }
 
     @Override
@@ -44,39 +54,47 @@ public class TPSBarTask extends BossBarTask {
         }
         tick = 0;
 
-        this.tps = Math.max(Math.min(Bukkit.getTPS()[0], 20.0D), 0.0D);
-        this.mspt = Bukkit.getAverageTickTime();
+        // Canvas start - Per level TPS and MSPT
+        for (ServerLevel level : MinecraftServer.getThreadedServer().getThreadedWorlds()) {
+            tps.put(level.uuid, Math.max(Math.min(level.recentTps[0], 20.0D), 0.0D));
+            mspt.put(level.uuid, level.getNanoSecondsFromLastTick() / 1_000_000);
+        }
+        // Canvas end
 
         super.run();
     }
 
-    private float getBossBarProgress() {
+    private float getBossBarProgress(UUID playerWorldUID) {  // Canvas - Add UUID as an argument
         if (PurpurConfig.commandTPSBarProgressFillMode == FillMode.MSPT) {
-            return Math.max(Math.min((float) mspt / 50.0F, 1.0F), 0.0F);
+            return Math.max(Math.min(mspt.get(playerWorldUID).floatValue() / 50.0F, 1.0F), 0.0F); // Canvas - get MSPT from map
         } else {
-            return Math.max(Math.min((float) tps / 20.0F, 1.0F), 0.0F);
+            return Math.max(Math.min(tps.get(playerWorldUID).floatValue() / 20.0F, 1.0F), 0.0F); // Canvas - get TPS from map
         }
     }
 
-    private BossBar.Color getBossBarColor() {
-        if (isGood(PurpurConfig.commandTPSBarProgressFillMode)) {
+    private BossBar.Color getBossBarColor(UUID playerWorldUID) {  // Canvas - Add UUID as an argument
+        if(playerWorldUID == null) return PurpurConfig.commandTPSBarProgressColorGood; // Canvas - It's required to not get NPE on bossbar creation
+
+        // Canvas start - Pass world UUID to isGood() and isMedium() as we need it to get proper bossbar color
+        if (isGood(PurpurConfig.commandTPSBarProgressFillMode, playerWorldUID)) {
             return PurpurConfig.commandTPSBarProgressColorGood;
-        } else if (isMedium(PurpurConfig.commandTPSBarProgressFillMode)) {
+        } else if (isMedium(PurpurConfig.commandTPSBarProgressFillMode, playerWorldUID)) {
+            // Canvas end
             return PurpurConfig.commandTPSBarProgressColorMedium;
         } else {
             return PurpurConfig.commandTPSBarProgressColorLow;
         }
     }
 
-    private boolean isGood(FillMode mode) {
-        return isGood(mode, 0);
+    private boolean isGood(FillMode mode, UUID playerWorldUID) {  // Canvas - Add UUID as an argument
+        return isGood(mode, 0, playerWorldUID); // Canvas - Pass UUID
     }
 
-    private boolean isGood(FillMode mode, int ping) {
+    private boolean isGood(FillMode mode, int ping, UUID playerWorldUID) {  // Canvas - Add UUID as an argument
         if (mode == FillMode.MSPT) {
-            return mspt < 40;
+            return mspt.get(playerWorldUID) < 40; // Canvas - get MSPT from map
         } else if (mode == FillMode.TPS) {
-            return tps >= 19;
+            return tps.get(playerWorldUID) >= 19; // Canvas - get TPS from map
         } else if (mode == FillMode.PING) {
             return ping < 100;
         } else {
@@ -84,15 +102,15 @@ public class TPSBarTask extends BossBarTask {
         }
     }
 
-    private boolean isMedium(FillMode mode) {
-        return isMedium(mode, 0);
+    private boolean isMedium(FillMode mode, UUID playerWorldUID) {  // Canvas - Add UUID as an argument
+        return isMedium(mode, 0, playerWorldUID); // Canvas - Pass UUID
     }
 
-    private boolean isMedium(FillMode mode, int ping) {
+    private boolean isMedium(FillMode mode, int ping, UUID playerWorldUID) {  // Canvas - Add UUID as an argument
         if (mode == FillMode.MSPT) {
-            return mspt < 50;
+            return mspt.get(playerWorldUID) < 50; // Canvas - get MSPT from map
         } else if (mode == FillMode.TPS) {
-            return tps >= 15;
+            return tps.get(playerWorldUID) >= 15; // Canvas - get TPS from map
         } else if (mode == FillMode.PING) {
             return ping < 200;
         } else {
@@ -100,35 +118,41 @@ public class TPSBarTask extends BossBarTask {
         }
     }
 
-    private Component getTPSColor() {
+    private Component getTPSColor(UUID playerWorldUID) {  // Canvas - Add UUID as an argument
         String color;
-        if (isGood(FillMode.TPS)) {
+        // Canvas start - Pass world UUID to isGood() and isMedium() as we need it to get TPS
+        if (isGood(FillMode.TPS, playerWorldUID)) {
             color = PurpurConfig.commandTPSBarTextColorGood;
-        } else if (isMedium(FillMode.TPS)) {
+        } else if (isMedium(FillMode.TPS, playerWorldUID)) {
+            // Canvas end
             color = PurpurConfig.commandTPSBarTextColorMedium;
         } else {
             color = PurpurConfig.commandTPSBarTextColorLow;
         }
-        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps)));
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps.get(playerWorldUID)))); // Canvas - get TPS from map
     }
 
-    private Component getMSPTColor() {
+    private Component getMSPTColor(UUID playerWorldUID) {  // Canvas - Add UUID as an argument
         String color;
-        if (isGood(FillMode.MSPT)) {
+        // Canvas start - Pass world UUID to isGood() and isMedium() as we need it to get MSPT
+        if (isGood(FillMode.MSPT, playerWorldUID)) {
             color = PurpurConfig.commandTPSBarTextColorGood;
-        } else if (isMedium(FillMode.MSPT)) {
+        } else if (isMedium(FillMode.MSPT, playerWorldUID)) {
+            // Canvas end
             color = PurpurConfig.commandTPSBarTextColorMedium;
         } else {
             color = PurpurConfig.commandTPSBarTextColorLow;
         }
-        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt)));
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt.get(playerWorldUID)))); // Canvas - get MSPT from map
     }
 
     private Component getPingColor(int ping) {
         String color;
-        if (isGood(FillMode.PING, ping)) {
+        // Canvas start - Pass null to isGood() and isMedium() as we don't need world UUID for ping
+        if (isGood(FillMode.PING, ping, null)) {
             color = PurpurConfig.commandTPSBarTextColorGood;
-        } else if (isMedium(FillMode.PING, ping)) {
+        } else if (isMedium(FillMode.PING, ping, null)) {
+            // Canvas end
             color = PurpurConfig.commandTPSBarTextColorMedium;
         } else {
             color = PurpurConfig.commandTPSBarTextColorLow;
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 4dbb109d0526afee99b9190fc256585121aac9b5..51daba58ca02fb7d82f8603799538bdaccf21432 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -141,7 +141,7 @@ public class SpigotConfig
         return SpigotConfig.config.getBoolean( path, SpigotConfig.config.getBoolean( path ) );
     }
 
-    private static int getInt(String path, int def)
+    public static int getInt(String path, int def) // Canvas - private -> public
     {
         SpigotConfig.config.addDefault( path, def );
         return SpigotConfig.config.getInt( path, SpigotConfig.config.getInt( path ) );
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index e808e2b76dde5047d44fbb8550634c1295ff5385..e1560e988d3555630adc9daf94e4dd25c5ac33e3 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -3,10 +3,16 @@ package org.spigotmc;
 import java.lang.management.ManagementFactory;
 import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
+import java.util.Locale;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import io.github.dueris.canvas.server.level.WatchdogWatcher;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
 
 public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThread // Paper - rewrite chunk system
 {
@@ -126,6 +132,13 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
     {
         WatchdogThread.instance.lastTick = WatchdogThread.monotonicMillis();
     }
+    // Canvas start
+
+    public static void tickLevel(@NotNull ServerLevel level)
+    {
+        level.lastWatchdogTick = WatchdogThread.monotonicMillis();
+    }
+    // Canvas end
 
     public static void doStop()
     {
@@ -145,18 +158,28 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
             Logger log = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
             MinecraftServer server = MinecraftServer.getServer();
-            if ( this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG) )) // Paper - add property to disable
-            {
-                boolean isLongTimeout = currentTime > lastTick + timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > lastTick + 1000);
+            // Canvas start
+            final AtomicBoolean shouldBreak = new AtomicBoolean(false);
+            // if ( this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG) )) // Paper - add property to disable
+            Consumer<WatchdogWatcher> laggingConsume = (levelOrServer) -> {
+                long lt = levelOrServer instanceof MinecraftServer ? lastTick : ((ServerLevel)levelOrServer).lastWatchdogTick;
+                String capitalized = levelOrServer.getName().substring(0, 1).toUpperCase() + levelOrServer.getName().substring(1).toLowerCase();
+                boolean isLongTimeout = currentTime > lt + timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > lt + 1000);
+                if (levelOrServer instanceof ServerLevel level) {
+                    if (!level.isTicking()) {
+                        return;
+                    }
+                }
                 // Don't spam early warning dumps
-                if ( !isLongTimeout && (earlyWarningEvery <= 0 || !hasStarted || currentTime < lastEarlyWarning + earlyWarningEvery || currentTime < lastTick + earlyWarningDelay)) continue;
-                if ( !isLongTimeout && server.hasStopped()) continue; // Don't spam early watchdog warnings during shutdown, we'll come back to this...
+                if ( !isLongTimeout && (earlyWarningEvery <= 0 || !hasStarted || currentTime < lastEarlyWarning + earlyWarningEvery || currentTime < lt + earlyWarningDelay)) return;
+                if ( !isLongTimeout && server.hasStopped()) return; // Don't spam early watchdog warnings during shutdown, we'll come back to this...
+            // Canvas end
                 lastEarlyWarning = currentTime;
                 if (isLongTimeout) {
                 // Paper end
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Canvas bug." ); // Paper // Purpur - Rebrand // Canvas
-                log.log( Level.SEVERE, "If you see a plugin in the Server thread dump below, then please report it to that author" );
+                log.log( Level.SEVERE, "The " + levelOrServer.getName() + " has stopped responding! This is (probably) not a Canvas bug." ); // Paper // Purpur - Rebrand // Canvas
+                log.log( Level.SEVERE, "If you see a plugin in the " + capitalized + " thread dump below, then please report it to that author" ); // Canvas
                 log.log( Level.SEVERE, "\t *Especially* if it looks like HTTP or MySQL operations are occurring" );
                 log.log( Level.SEVERE, "If you see a world save or edit, then it means you did far more than your server can handle at once" );
                 log.log( Level.SEVERE, "\t If this is the case, consider increasing timeout-time in spigot.yml but note that this will replace the crash with LARGE lag spikes" );
@@ -185,14 +208,14 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
                 } else
                 {
                     log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO CANVAS - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---"); // Purpur - Rebrand // Canvas
-                    log.log(Level.SEVERE, "The server has not responded for " + (currentTime - lastTick) / 1000 + " seconds! Creating thread dump");
+                    log.log(Level.SEVERE, "The " + levelOrServer.getName() + " has not responded for " + (currentTime - lt) / 1000 + " seconds! Creating thread dump"); // Canvas
                 }
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Canvas!):" ); // Paper // Purpur - Rebrand // Canvas
+                log.log( Level.SEVERE, capitalized + " thread dump (Look for plugins here before reporting to Canvas!):" ); // Paper // Purpur - Rebrand // Canvas
                 ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(MinecraftServer.getServer(), isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
-                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( levelOrServer.getRunningThread().getId(), Integer.MAX_VALUE ), log ); // Canvas
                 log.log( Level.SEVERE, "------------------------------" );
                 //
                 // Paper start - Only print full dump on long timeouts
@@ -231,9 +254,28 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
                         server.close();
                     }
                 }
-                break;
+            // Canvas start
+                shouldBreak.set(true);
                 } // Paper end
+            };
+
+            if (checkMainThread(server, currentTime))
+            {
+                laggingConsume.accept(server);
+                if (shouldBreak.get()) {
+                    break;
+                }
             }
+            for (ServerLevel level : server.getAllLevels())
+            {
+                if (checkLevelThread(level, currentTime)) {
+                    laggingConsume.accept(level);
+                    if (shouldBreak.get()) {
+                        break;
+                    }
+                }
+            }
+            // Canvas end
 
             try
             {
@@ -244,6 +286,16 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
             }
         }
     }
+    // Canvas start
+
+    private boolean checkMainThread(MinecraftServer server, long currentTime) {
+        return this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG));
+    }
+
+    private boolean checkLevelThread(@NotNull ServerLevel level, long currentTime) {
+        return level.lastWatchdogTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!level.running || (currentTime > level.lastWatchdogTick + this.earlyWarningEvery && !DISABLE_WATCHDOG));
+    }
+    // Canvas end
 
     private static void dumpThread(ThreadInfo thread, Logger log)
     {
