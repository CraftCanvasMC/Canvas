From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Sun, 22 Dec 2024 10:25:42 -0800
Subject: [PATCH] Async Pathfinding


diff --git a/src/main/java/io/github/dueris/canvas/Config.java b/src/main/java/io/github/dueris/canvas/Config.java
index a1b0d8203632b2de5291d2df1934f7f396292fdc..e6a2a12ea3a38c2f755f4910753f61bce58380a2 100644
--- a/src/main/java/io/github/dueris/canvas/Config.java
+++ b/src/main/java/io/github/dueris/canvas/Config.java
@@ -15,6 +15,7 @@ public class Config implements JsonConfig {
     public boolean emptySleepPerWorlds = true;
     public boolean allowPacketsThreadCheckOffMain = true;
     public ChunkGeneration chunkgen = new ChunkGeneration();
+    public Pathfinding pathfinding = new Pathfinding();
 
     public static Config init() {
         final JsonConfigAPI jsonConfigAPI = new JsonConfigAPI(true);
@@ -45,4 +46,11 @@ public class Config implements JsonConfig {
         public boolean allowAVX512 = false;
         public boolean nativeAccelerationEnabled = true;
     }
+
+    public static class Pathfinding {
+        public boolean enableThreadedPathfinding = true;
+        public boolean useThreadedWorldForScheduling = true;
+        public int maxProcessors = 2;
+        public int keepAlive = 60;
+    }
 }
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPath.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPath.java
new file mode 100644
index 0000000000000000000000000000000000000000..c54d9dc8d8080fe4287df25c630fbec7fe0bc5a1
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPath.java
@@ -0,0 +1,286 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Supplier;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.pathfinder.Node;
+import net.minecraft.world.level.pathfinder.Path;
+import net.minecraft.world.phys.Vec3;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class AsyncPath extends Path {
+    /**
+     * runnables waiting for this to be processed
+     */
+    private final List<Runnable> postProcessing = new ArrayList<>(0);
+    /**
+     * a list of positions that this path could path towards
+     */
+    private final Set<BlockPos> positions;
+    /**
+     * the supplier of the real processed path
+     */
+    private final Supplier<Path> pathSupplier;
+    /**
+     * this is a reference to the nodes list in the parent `Path` object
+     */
+    private final List<Node> nodes;
+
+    /*
+     * Processed values
+     */
+    /**
+     * marks whether this async path has been processed
+     */
+    private volatile PathProcessState processState = PathProcessState.WAITING;
+    /**
+     * the block we're trying to path to
+     * <p>
+     * while processing, we have no idea where this is so consumers of `Path` should check that the path is processed before checking the target block
+     */
+    private @Nullable BlockPos target;
+    /**
+     * how far we are to the target
+     * <p>
+     * while processing, the target could be anywhere but theoretically we're always "close" to a theoretical target so default is 0
+     */
+    private float distToTarget = 0;
+    /**
+     * whether we can reach the target
+     * <p>
+     * while processing, we can always theoretically reach the target so default is true
+     */
+    private boolean canReach = true;
+
+    public AsyncPath(@NotNull List<Node> emptyNodeList, @NotNull Set<BlockPos> positions, @NotNull Supplier<Path> pathSupplier) {
+        //noinspection ConstantConditions
+        super(emptyNodeList, null, false);
+
+        this.nodes = emptyNodeList;
+        this.positions = positions;
+        this.pathSupplier = pathSupplier;
+
+        AsyncPathProcessor.queue(this);
+    }
+
+    @Override
+    public boolean isProcessed() {
+        return this.processState == PathProcessState.COMPLETED;
+    }
+
+    /**
+     * returns the future representing the processing state of this path
+     */
+    public synchronized void postProcessing(@NotNull Runnable runnable) {
+        if (isProcessed()) {
+            runnable.run();
+        } else {
+            this.postProcessing.add(runnable);
+        }
+    }
+
+    /**
+     * an easy way to check if this processing path is the same as an attempted new path
+     *
+     * @param positions - the positions to compare against
+     * @return true if we are processing the same positions
+     */
+    public boolean hasSameProcessingPositions(final Set<BlockPos> positions) {
+        if (this.positions.size() != positions.size()) {
+            return false;
+        }
+
+        return this.positions.containsAll(positions);
+    }
+
+    /**
+     * starts processing this path
+     */
+    public synchronized void process() {
+        if (this.processState == PathProcessState.COMPLETED ||
+            this.processState == PathProcessState.PROCESSING) {
+            return;
+        }
+
+        processState = PathProcessState.PROCESSING;
+
+        final Path bestPath = this.pathSupplier.get();
+
+        this.nodes.addAll(bestPath.nodes); // we mutate this list to reuse the logic in Path
+        this.target = bestPath.getTarget();
+        this.distToTarget = bestPath.getDistToTarget();
+        this.canReach = bestPath.canReach();
+
+        processState = PathProcessState.COMPLETED;
+
+        for (Runnable runnable : this.postProcessing) {
+            runnable.run();
+        } // Run tasks after processing
+    }
+
+    /**
+     * if this path is accessed while it hasn't processed, just process it in-place
+     */
+    private void checkProcessed() {
+        if (this.processState == PathProcessState.WAITING ||
+            this.processState == PathProcessState.PROCESSING) { // Block if we are on processing
+            this.process();
+        }
+    }
+
+    /*
+     * overrides we need for final fields that we cannot modify after processing
+     */
+
+    @Override
+    public @NotNull BlockPos getTarget() {
+        this.checkProcessed();
+
+        return this.target;
+    }
+
+    @Override
+    public float getDistToTarget() {
+        this.checkProcessed();
+
+        return this.distToTarget;
+    }
+
+    @Override
+    public boolean canReach() {
+        this.checkProcessed();
+
+        return this.canReach;
+    }
+
+    /*
+     * overrides to ensure we're processed first
+     */
+
+    @Override
+    public boolean isDone() {
+        return this.processState == PathProcessState.COMPLETED && super.isDone();
+    }
+
+    @Override
+    public void advance() {
+        this.checkProcessed();
+
+        super.advance();
+    }
+
+    @Override
+    public boolean notStarted() {
+        this.checkProcessed();
+
+        return super.notStarted();
+    }
+
+    @Nullable
+    @Override
+    public Node getEndNode() {
+        this.checkProcessed();
+
+        return super.getEndNode();
+    }
+
+    @Override
+    public Node getNode(int index) {
+        this.checkProcessed();
+
+        return super.getNode(index);
+    }
+
+    @Override
+    public void truncateNodes(int length) {
+        this.checkProcessed();
+
+        super.truncateNodes(length);
+    }
+
+    @Override
+    public void replaceNode(int index, Node node) {
+        this.checkProcessed();
+
+        super.replaceNode(index, node);
+    }
+
+    @Override
+    public int getNodeCount() {
+        this.checkProcessed();
+
+        return super.getNodeCount();
+    }
+
+    @Override
+    public int getNextNodeIndex() {
+        this.checkProcessed();
+
+        return super.getNextNodeIndex();
+    }
+
+    @Override
+    public void setNextNodeIndex(int nodeIndex) {
+        this.checkProcessed();
+
+        super.setNextNodeIndex(nodeIndex);
+    }
+
+    @Override
+    public Vec3 getEntityPosAtNode(Entity entity, int index) {
+        this.checkProcessed();
+
+        return super.getEntityPosAtNode(entity, index);
+    }
+
+    @Override
+    public BlockPos getNodePos(int index) {
+        this.checkProcessed();
+
+        return super.getNodePos(index);
+    }
+
+    @Override
+    public Vec3 getNextEntityPos(Entity entity) {
+        this.checkProcessed();
+
+        return super.getNextEntityPos(entity);
+    }
+
+    @Override
+    public BlockPos getNextNodePos() {
+        this.checkProcessed();
+
+        return super.getNextNodePos();
+    }
+
+    @Override
+    public Node getNextNode() {
+        this.checkProcessed();
+
+        return super.getNextNode();
+    }
+
+    @Nullable
+    @Override
+    public Node getPreviousNode() {
+        this.checkProcessed();
+
+        return super.getPreviousNode();
+    }
+
+    @Override
+    public boolean hasNext() {
+        this.checkProcessed();
+
+        return super.hasNext();
+    }
+
+    public PathProcessState getProcessState() {
+        return processState;
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPathProcessor.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPathProcessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6af788153b087a53fac8df6bc1471cf26b80d29
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/AsyncPathProcessor.java
@@ -0,0 +1,60 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.github.dueris.canvas.Config;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.pathfinder.Path;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * used to handle the scheduling of async path processing
+ */
+public class AsyncPathProcessor {
+    private static final Executor pathProcessingExecutor = new ThreadPoolExecutor(
+        1,
+        Config.INSTANCE.pathfinding.maxProcessors,
+        Config.INSTANCE.pathfinding.keepAlive, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<>(),
+        new ThreadFactoryBuilder()
+            .setNameFormat("pathfinding")
+            .setPriority(Thread.NORM_PRIORITY - 2)
+            .build()
+    );
+
+    protected static CompletableFuture<Void> queue(@NotNull AsyncPath path) {
+        return CompletableFuture.runAsync(path::process, pathProcessingExecutor);
+    }
+
+    /**
+     * takes a possibly unprocessed path, and waits until it is completed
+     * the consumer will be immediately invoked if the path is already processed
+     * the consumer will always be called on the main thread
+     *
+     * @param path            a path to wait on
+     * @param afterProcessing a consumer to be called
+     */
+    public static void awaitProcessing(@Nullable Path path, final @NotNull Level level, Consumer<@Nullable Path> afterProcessing) {
+        if (!(level instanceof ServerLevel serverLevel)) throw new IllegalArgumentException("Level must be a ServerLevel to execute processing.");
+        if (path != null && !path.isProcessed() && path instanceof AsyncPath asyncPath) {
+            asyncPath.postProcessing(() -> {
+                if (Config.INSTANCE.pathfinding.useThreadedWorldForScheduling && MinecraftServer.getThreadedServer().isBooted()) {
+                    // Schedule on level instead of main.
+                    serverLevel.schedule(serverLevel.wrapRunnable(() -> afterProcessing.accept(path)));
+                    return;
+                }
+                MinecraftServer.getServer().scheduleOnMain(() -> afterProcessing.accept(path));
+            });
+        } else {
+            afterProcessing.accept(path);
+        }
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorCache.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad31678eb6d6156a6dae905bcd1d605604794784
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorCache.java
@@ -0,0 +1,43 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import net.minecraft.world.level.pathfinder.NodeEvaluator;
+import org.apache.commons.lang.Validate;
+import org.jetbrains.annotations.NotNull;
+
+public class NodeEvaluatorCache {
+    private static final Map<NodeEvaluatorFeatures, ConcurrentLinkedQueue<NodeEvaluator>> threadLocalNodeEvaluators = new ConcurrentHashMap<>();
+    private static final Map<NodeEvaluator, NodeEvaluatorGenerator> nodeEvaluatorToGenerator = new ConcurrentHashMap<>();
+
+    private static @NotNull Queue<NodeEvaluator> getQueueForFeatures(@NotNull NodeEvaluatorFeatures nodeEvaluatorFeatures) {
+        return threadLocalNodeEvaluators.computeIfAbsent(nodeEvaluatorFeatures, key -> new ConcurrentLinkedQueue<>());
+    }
+
+    public static @NotNull NodeEvaluator takeNodeEvaluator(@NotNull NodeEvaluatorGenerator generator, @NotNull NodeEvaluator localNodeEvaluator) {
+        final NodeEvaluatorFeatures nodeEvaluatorFeatures = NodeEvaluatorFeatures.fromNodeEvaluator(localNodeEvaluator);
+        NodeEvaluator nodeEvaluator = getQueueForFeatures(nodeEvaluatorFeatures).poll();
+
+        if (nodeEvaluator == null) {
+            nodeEvaluator = generator.generate(nodeEvaluatorFeatures);
+        }
+
+        nodeEvaluatorToGenerator.put(nodeEvaluator, generator);
+
+        return nodeEvaluator;
+    }
+
+    public static void returnNodeEvaluator(@NotNull NodeEvaluator nodeEvaluator) {
+        final NodeEvaluatorGenerator generator = nodeEvaluatorToGenerator.remove(nodeEvaluator);
+        Validate.notNull(generator, "NodeEvaluator already returned");
+
+        final NodeEvaluatorFeatures nodeEvaluatorFeatures = NodeEvaluatorFeatures.fromNodeEvaluator(nodeEvaluator);
+        getQueueForFeatures(nodeEvaluatorFeatures).offer(nodeEvaluator);
+    }
+
+    public static void removeNodeEvaluator(@NotNull NodeEvaluator nodeEvaluator) {
+        nodeEvaluatorToGenerator.remove(nodeEvaluator);
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorFeatures.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorFeatures.java
new file mode 100644
index 0000000000000000000000000000000000000000..bdf33745c5d572fea5b4fb660a0dfd22803a3b93
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorFeatures.java
@@ -0,0 +1,23 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import net.minecraft.world.level.pathfinder.NodeEvaluator;
+import net.minecraft.world.level.pathfinder.SwimNodeEvaluator;
+
+public record NodeEvaluatorFeatures(
+    NodeEvaluatorType type,
+    boolean canPassDoors,
+    boolean canFloat,
+    boolean canWalkOverFences,
+    boolean canOpenDoors,
+    boolean allowBreaching
+) {
+    public static NodeEvaluatorFeatures fromNodeEvaluator(NodeEvaluator nodeEvaluator) {
+        NodeEvaluatorType type = NodeEvaluatorType.fromNodeEvaluator(nodeEvaluator);
+        boolean canPassDoors = nodeEvaluator.canPassDoors();
+        boolean canFloat = nodeEvaluator.canFloat();
+        boolean canWalkOverFences = nodeEvaluator.canWalkOverFences();
+        boolean canOpenDoors = nodeEvaluator.canOpenDoors();
+        boolean allowBreaching = nodeEvaluator instanceof SwimNodeEvaluator swimNodeEvaluator && swimNodeEvaluator.allowBreaching;
+        return new NodeEvaluatorFeatures(type, canPassDoors, canFloat, canWalkOverFences, canOpenDoors, allowBreaching);
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorGenerator.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b6cb7c331f1a39ad80030ab50dae7af68d7aa26
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorGenerator.java
@@ -0,0 +1,9 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import net.minecraft.world.level.pathfinder.NodeEvaluator;
+import org.jetbrains.annotations.NotNull;
+
+public interface NodeEvaluatorGenerator {
+    @NotNull
+    NodeEvaluator generate(NodeEvaluatorFeatures nodeEvaluatorFeatures);
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorType.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorType.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec92be167fe3129596c4222e766fd12f4d9dbd7c
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/NodeEvaluatorType.java
@@ -0,0 +1,20 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+import net.minecraft.world.level.pathfinder.AmphibiousNodeEvaluator;
+import net.minecraft.world.level.pathfinder.FlyNodeEvaluator;
+import net.minecraft.world.level.pathfinder.NodeEvaluator;
+import net.minecraft.world.level.pathfinder.SwimNodeEvaluator;
+
+public enum NodeEvaluatorType {
+    WALK,
+    SWIM,
+    AMPHIBIOUS,
+    FLY;
+
+    public static NodeEvaluatorType fromNodeEvaluator(NodeEvaluator nodeEvaluator) {
+        if (nodeEvaluator instanceof SwimNodeEvaluator) return SWIM;
+        if (nodeEvaluator instanceof FlyNodeEvaluator) return FLY;
+        if (nodeEvaluator instanceof AmphibiousNodeEvaluator) return AMPHIBIOUS;
+        return WALK;
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/entity/pathfinding/PathProcessState.java b/src/main/java/io/github/dueris/canvas/entity/pathfinding/PathProcessState.java
new file mode 100644
index 0000000000000000000000000000000000000000..fca0e8fa249b8c2ce00e5b26d2a5c9d2e55ab0ce
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/entity/pathfinding/PathProcessState.java
@@ -0,0 +1,7 @@
+package io.github.dueris.canvas.entity.pathfinding;
+
+public enum PathProcessState {
+    WAITING,
+    PROCESSING,
+    COMPLETED,
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index 273ba657926ce72a7c82861e880a82bf7f322a0b..93cb3ad3dfc1108c379638b3586291ca3bbf6db7 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.entity.ai.behavior;
 
 import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPathProcessor;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.HashSet;
@@ -8,7 +10,6 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.GlobalPos;
@@ -94,23 +95,56 @@ public class AcquirePoi {
                                         }
                                     }
                                     // Paper end - optimise POI access
-                                    Path path = findPathToPois(entity, set);
-                                    if (path != null && path.canReach()) {
-                                        BlockPos blockPos = path.getTarget();
-                                        poiManager.getType(blockPos).ifPresent(poiType -> {
-                                            poiManager.take(poiPredicate, (holder, blockPos2) -> blockPos2.equals(blockPos), blockPos, 1);
-                                            queryResult.set(GlobalPos.of(world.dimension(), blockPos));
-                                            entityStatus.ifPresent(status -> world.broadcastEntityEvent(entity, status));
-                                            long2ObjectMap.clear();
-                                            DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                    // Canvas start - Async path processing
+                                    if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                                        // await on path async
+                                        Path possiblePath = findPathToPois(entity, set);
+
+                                        // wait on the path to be processed
+                                        AsyncPathProcessor.awaitProcessing(possiblePath, world, path -> {
+                                            // read canReach check
+                                            if (path == null || !path.canReach()) {
+                                                for (Pair<Holder<PoiType>, BlockPos> pair : set) {
+                                                    long2ObjectMap.computeIfAbsent(
+                                                            pair.getSecond().asLong(),
+                                                            m -> new JitteredLinearRetry(entity.level().random, time)
+                                                    );
+                                                }
+                                                return;
+                                            }
+                                            BlockPos blockPos = path.getTarget();
+                                            poiManager.getType(blockPos).ifPresent(poiType -> {
+                                                poiManager.take(poiPredicate,
+                                                        (holder, blockPos2) -> blockPos2.equals(blockPos),
+                                                        blockPos,
+                                                        1
+                                                );
+                                                queryResult.set(GlobalPos.of(world.dimension(), blockPos));
+                                                entityStatus.ifPresent(status -> world.broadcastEntityEvent(entity, status));
+                                                long2ObjectMap.clear();
+                                                DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                            });
                                         });
                                     } else {
-                                        for (Pair<Holder<PoiType>, BlockPos> pair : set) {
-                                            long2ObjectMap.computeIfAbsent(
-                                                pair.getSecond().asLong(), m -> new AcquirePoi.JitteredLinearRetry(world.random, time)
-                                            );
+                                        Path path = findPathToPois(entity, set);
+                                        if (path != null && path.canReach()) {
+                                            BlockPos blockPos = path.getTarget();
+                                            poiManager.getType(blockPos).ifPresent(poiType -> {
+                                                poiManager.take(poiPredicate, (holder, blockPos2) -> blockPos2.equals(blockPos), blockPos, 1);
+                                                queryResult.set(GlobalPos.of(world.dimension(), blockPos));
+                                                entityStatus.ifPresent(status -> world.broadcastEntityEvent(entity, status));
+                                                long2ObjectMap.clear();
+                                                DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                            });
+                                        } else {
+                                            for (Pair<Holder<PoiType>, BlockPos> pair : set) {
+                                                long2ObjectMap.computeIfAbsent(
+                                                        pair.getSecond().asLong(), m -> new AcquirePoi.JitteredLinearRetry(world.random, time)
+                                                );
+                                            }
                                         }
                                     }
+                                    // Canvas end
 
                                     return true;
                                 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java b/src/main/java/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
index 2a7a26ca447cc78f24e61a2bf557411c31eb16b2..451c5fe1d442005bad26ef7bf82a65f89d98e669 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
@@ -3,6 +3,7 @@ package net.minecraft.world.entity.ai.behavior;
 import com.google.common.collect.ImmutableMap;
 import java.util.Optional;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Mob;
@@ -21,6 +22,7 @@ public class MoveToTargetSink extends Behavior<Mob> {
     private int remainingCooldown;
     @Nullable
     private Path path;
+    private boolean finishedProcessing; // Canvas
     @Nullable
     private BlockPos lastTargetPos;
     private float speedModifier;
@@ -53,9 +55,11 @@ public class MoveToTargetSink extends Behavior<Mob> {
             Brain<?> brain = entity.getBrain();
             WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
             boolean bl = this.reachedTarget(entity, walkTarget);
-            if (!bl && this.tryComputePath(entity, walkTarget, world.getGameTime())) {
+            if (!Config.INSTANCE.pathfinding.enableThreadedPathfinding && !bl && this.tryComputePath(entity, walkTarget, world.getGameTime())) { // Canvas
                 this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
                 return true;
+            } else if (Config.INSTANCE.pathfinding.enableThreadedPathfinding && !bl) { // Canvas
+                   return true;
             } else {
                 brain.eraseMemory(MemoryModuleType.WALK_TARGET);
                 if (bl) {
@@ -69,6 +73,7 @@ public class MoveToTargetSink extends Behavior<Mob> {
 
     @Override
     protected boolean canStillUse(ServerLevel world, Mob entity, long time) {
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding && !this.finishedProcessing) return true; // Canvas
         if (this.path != null && this.lastTargetPos != null) {
             Optional<WalkTarget> optional = entity.getBrain().getMemory(MemoryModuleType.WALK_TARGET);
             boolean bl = optional.map(MoveToTargetSink::isWalkTargetSpectator).orElse(false);
@@ -95,28 +100,97 @@ public class MoveToTargetSink extends Behavior<Mob> {
 
     @Override
     protected void start(ServerLevel serverLevel, Mob mob, long l) {
+        // Canvas start
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            Brain<?> brain = mob.getBrain();
+            WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+
+            this.finishedProcessing = false;
+            this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
+            this.path = this.computePath(mob, walkTarget);
+            return;
+        }
+        // Canvas end
         mob.getBrain().setMemory(MemoryModuleType.PATH, this.path);
         mob.getNavigation().moveTo(this.path, (double)this.speedModifier);
     }
 
     @Override
     protected void tick(ServerLevel serverLevel, Mob mob, long l) {
-        Path path = mob.getNavigation().getPath();
-        Brain<?> brain = mob.getBrain();
-        if (this.path != path) {
-            this.path = path;
-            brain.setMemory(MemoryModuleType.PATH, path);
-        }
+        // Canvas start
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            if (this.path != null && !this.path.isProcessed()) return;
 
-        if (path != null && this.lastTargetPos != null) {
-            WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
-            if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0
-                && this.tryComputePath(mob, walkTarget, serverLevel.getGameTime())) {
-                this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
-                this.start(serverLevel, mob, l);
+            if (!this.finishedProcessing) {
+                this.finishedProcessing = true;
+
+                Brain<?> brain = mob.getBrain();
+                boolean canReach = this.path != null && this.path.canReach();
+                if (canReach) {
+                    brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+                } else if (!brain.hasMemoryValue(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE)) {
+                    brain.setMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, l);
+                }
+
+                if (!canReach) {
+                    Optional<WalkTarget> walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET);
+
+                    if (!walkTarget.isPresent()) return;
+
+                    BlockPos blockPos = walkTarget.get().getTarget().currentBlockPosition();
+                    Vec3 vec3 = DefaultRandomPos.getPosTowards((PathfinderMob) mob, 10, 7, Vec3.atBottomCenterOf(blockPos), (float) Math.PI / 2F);
+                    if (vec3 != null) {
+                        this.path = mob.getNavigation().createPath(vec3.x, vec3.y, vec3.z, 0);
+                        this.finishedProcessing = false;
+                        return;
+                    }
+                }
+
+                mob.getBrain().setMemory(MemoryModuleType.PATH, this.path);
+                mob.getNavigation().moveTo(this.path, this.speedModifier);
+            }
+
+            Path path = mob.getNavigation().getPath();
+            Brain<?> brain = mob.getBrain();
+
+            if (path != null && this.lastTargetPos != null && brain.hasMemoryValue(MemoryModuleType.WALK_TARGET)) {
+                WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+                if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0D) {
+                    this.start(serverLevel, mob, l);
+                }
+            }
+        } else {
+            Path path = mob.getNavigation().getPath();
+            Brain<?> brain = mob.getBrain();
+            if (this.path != path) {
+                this.path = path;
+                brain.setMemory(MemoryModuleType.PATH, path);
             }
+
+            if (path != null && this.lastTargetPos != null) {
+                WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+                if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0
+                        && this.tryComputePath(mob, walkTarget, serverLevel.getGameTime())) {
+                    this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
+                    this.start(serverLevel, mob, l);
+                }
+            }
+        }
+        // Canvas end
+    }
+
+    // Canvas start
+    @Nullable
+    private Path computePath(Mob entity, WalkTarget walkTarget){
+        BlockPos blockPos = walkTarget.getTarget().currentBlockPosition();
+        this.speedModifier = walkTarget.getSpeedModifier();
+        Brain<?> brain = entity.getBrain();
+        if (this.reachedTarget(entity, walkTarget)) {
+            brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
         }
+        return entity.getNavigation().createPath(blockPos, 0);
     }
+    // Canvas end
 
     private boolean tryComputePath(Mob entity, WalkTarget walkTarget, long time) {
         BlockPos blockPos = walkTarget.getTarget().currentBlockPosition();
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java b/src/main/java/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
index 6802e0c4d331c7125114dd86409f6a110465ab82..bddaf4d60cd86db19765f235298a0af7dda73a4c 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.entity.ai.behavior;
 
 import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPathProcessor;
 import it.unimi.dsi.fastutil.longs.Long2LongMap;
 import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
 import java.util.Optional;
@@ -60,17 +62,36 @@ public class SetClosestHomeAsWalkTarget {
                                                 poiType -> poiType.is(PoiTypes.HOME), predicate, entity.blockPosition(), 48, PoiManager.Occupancy.ANY
                                             )
                                             .collect(Collectors.toSet());
-                                        Path path = AcquirePoi.findPathToPois(entity, set);
-                                        if (path != null && path.canReach()) {
-                                            BlockPos blockPos = path.getTarget();
-                                            Optional<Holder<PoiType>> optional2 = poiManager.getType(blockPos);
-                                            if (optional2.isPresent()) {
-                                                walkTarget.set(new WalkTarget(blockPos, speed, 1));
-                                                DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                        // Canvas start
+                                        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                                            Path possiblePath = AcquirePoi.findPathToPois(entity, set);
+
+                                            AsyncPathProcessor.awaitProcessing(possiblePath, world, path -> {
+                                                if (path == null || !path.canReach() || mutableInt.getValue() < 5) { // read canReach check
+                                                    long2LongMap.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.getValue());
+                                                    return;
+                                                }
+                                                BlockPos blockPos = path.getTarget();
+                                                Optional<Holder<PoiType>> optional2 = poiManager.getType(blockPos);
+                                                if (optional2.isPresent()) {
+                                                    walkTarget.set(new WalkTarget(blockPos, speed, 1));
+                                                    DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                                }
+                                            });
+                                        } else {
+                                            Path path = AcquirePoi.findPathToPois(entity, set);
+                                            if (path != null && path.canReach()) {
+                                                BlockPos blockPos = path.getTarget();
+                                                Optional<Holder<PoiType>> optional2 = poiManager.getType(blockPos);
+                                                if (optional2.isPresent()) {
+                                                    walkTarget.set(new WalkTarget(blockPos, speed, 1));
+                                                    DebugPackets.sendPoiTicketCountPacket(world, blockPos);
+                                                }
+                                            } else if (mutableInt.getValue() < 5) {
+                                                long2LongMap.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.getValue());
                                             }
-                                        } else if (mutableInt.getValue() < 5) {
-                                            long2LongMap.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.getValue());
                                         }
+                                        // Canvas end
 
                                         return true;
                                     } else {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
index 2846790fcd00788cf0284c348161ee1aee415f13..0ccebdcd16ba99047625fb95bd1478cd4a891ba2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
@@ -56,7 +56,7 @@ public abstract class DoorInteractGoal extends Goal {
         } else {
             GroundPathNavigation groundPathNavigation = (GroundPathNavigation)this.mob.getNavigation();
             Path path = groundPathNavigation.getPath();
-            if (path != null && !path.isDone()) {
+            if (path != null && path.isProcessed() && !path.isDone()) { // Canvas
                 for (int i = 0; i < Math.min(path.getNextNodeIndex() + 2, path.getNodeCount()); i++) {
                     Node node = path.getNode(i);
                     this.doorPos = new BlockPos(node.x, node.y + 1, node.z);
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
index 29b852c3262c9cd0d2c77a93c01a386a2c184742..cad1dde4eed195b4b3c3cb4788ff2f87699c0ce5 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.entity.ai.navigation;
 
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.Level;
@@ -12,9 +15,25 @@ public class AmphibiousPathNavigation extends PathNavigation {
         super(mob, world);
     }
 
+    // Canvas start
+    private static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        AmphibiousNodeEvaluator nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Canvas end
+
     @Override
     protected PathFinder createPathFinder(int range) {
         this.nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        // Canvas start
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+        }
+        // Canvas end
         return new PathFinder(this.nodeEvaluator, range);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
index 2bd66da93227d4e4fc2ec4df47ae94b17f4d39d3..a911adc305f4d4003d0cf0764aa6c75d816fcc51 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.entity.ai.navigation;
 
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.util.Mth;
@@ -16,9 +19,25 @@ public class FlyingPathNavigation extends PathNavigation {
         super(entity, world);
     }
 
+    // Canvas start
+    private static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        FlyNodeEvaluator nodeEvaluator = new FlyNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Canvas end
+
     @Override
     protected PathFinder createPathFinder(int range) {
         this.nodeEvaluator = new FlyNodeEvaluator();
+        // Canvas start - async path processing
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+        }
+        // Canvas end
         return new PathFinder(this.nodeEvaluator, range);
     }
 
@@ -48,6 +67,7 @@ public class FlyingPathNavigation extends PathNavigation {
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
+        if (this.path != null && !this.path.isProcessed()) return; // Canvas
 
         if (!this.isDone()) {
             if (this.canUpdatePath()) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
index 2796df7af365c452b28373adfd7daf1d6730bac5..cad21c89b677e60f0338eaa22479b2dc8c035be0 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.entity.ai.navigation;
 
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.SectionPos;
@@ -24,9 +27,25 @@ public class GroundPathNavigation extends PathNavigation {
         super(entity, world);
     }
 
+    // Canvas start
+    protected static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Canvas end
+
     @Override
     protected PathFinder createPathFinder(int range) {
         this.nodeEvaluator = new WalkNodeEvaluator();
+        // Canvas start
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+        }
+        // Canvas end
         return new PathFinder(this.nodeEvaluator, range);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 48c0de870a5bbf647309e69361dfb10ab56c65ab..5c4b35b660b894a849fc0014cdbe074bcc646841 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -5,6 +5,9 @@ import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPath;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPathProcessor;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -168,6 +171,10 @@ public abstract class PathNavigation {
             return null;
         } else if (!this.canUpdatePath()) {
             return null;
+            // Canvas start
+        } else if (this.path instanceof AsyncPath asyncPath && !asyncPath.isProcessed() && asyncPath.hasSameProcessingPositions(positions)) {
+            return this.path;
+            // Canvas end
         } else if (this.path != null && !this.path.isDone() && positions.contains(this.targetPos)) {
             return this.path;
         } else {
@@ -194,12 +201,28 @@ public abstract class PathNavigation {
             int i = (int)(followRange + (float)range);
             PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(this.level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
             Path path = this.pathFinder.findPath(pathNavigationRegion, this.mob, positions, followRange, distance, this.maxVisitedNodesMultiplier);
-            profilerFiller.pop();
-            if (path != null && path.getTarget() != null) {
-                this.targetPos = path.getTarget();
-                this.reachRange = distance;
-                this.resetStuckTimeout();
+            // Canvas start
+            if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                if (!positions.isEmpty()) this.targetPos = positions.iterator().next();
+
+                AsyncPathProcessor.awaitProcessing(path, this.mob.level(), processedPath -> {
+                    if (processedPath != this.path) return;
+
+                    if (processedPath != null && processedPath.getTarget() != null) {
+                        this.targetPos = processedPath.getTarget();
+                        this.reachRange = distance;
+                        this.resetStuckTimeout();
+                    }
+                });
+            } else {
+                profilerFiller.pop();
+                if (path != null && path.getTarget() != null) {
+                    this.targetPos = path.getTarget();
+                    this.reachRange = distance;
+                    this.resetStuckTimeout();
+                }
             }
+            // Canvas end
 
             return path;
         }
@@ -250,8 +273,8 @@ public abstract class PathNavigation {
             if (this.isDone()) {
                 return false;
             } else {
-                this.trimPath();
-                if (this.path.getNodeCount() <= 0) {
+                if (path.isProcessed()) this.trimPath(); // Canvas
+                if (path.isProcessed() && this.path.getNodeCount() <= 0) { // Canvas
                     return false;
                 } else {
                     this.speedModifier = speed;
@@ -274,6 +297,7 @@ public abstract class PathNavigation {
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
+        if (this.path != null && !this.path.isProcessed()) return; // Canvas
 
         if (!this.isDone()) {
             if (this.canUpdatePath()) {
@@ -300,6 +324,7 @@ public abstract class PathNavigation {
     }
 
     protected void followThePath() {
+        if (!this.path.isProcessed()) return; // Canvas
         Vec3 vec3 = this.getTempMobPos();
         this.maxDistanceToWaypoint = this.mob.getBbWidth() > 0.75F ? this.mob.getBbWidth() / 2.0F : 0.75F - this.mob.getBbWidth() / 2.0F;
         Vec3i vec3i = this.path.getNextNodePos();
@@ -456,7 +481,7 @@ public abstract class PathNavigation {
     public boolean shouldRecomputePath(BlockPos pos) {
         if (this.hasDelayedRecomputation) {
             return false;
-        } else if (this.path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
+        } else if (this.path != null && this.path.isProcessed() && !this.path.isDone() && this.path.getNodeCount() != 0) { // Canvas
             Node node = this.path.getEndNode();
             Vec3 vec3 = new Vec3(((double)node.x + this.mob.getX()) / 2.0, ((double)node.y + this.mob.getY()) / 2.0, ((double)node.z + this.mob.getZ()) / 2.0);
             return pos.closerToCenterThan(vec3, (double)(this.path.getNodeCount() - this.path.getNextNodeIndex()));
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
index 943c9944ae17fa7cd72e437cce61beaf3fc9505e..465b3492e61a28bfe505f630d4f2c2d9b8ee6b6b 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.entity.ai.navigation;
 
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.Mob;
@@ -15,11 +18,27 @@ public class WaterBoundPathNavigation extends PathNavigation {
         super(entity, world);
     }
 
+    // Canvas start
+    private static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        SwimNodeEvaluator nodeEvaluator = new SwimNodeEvaluator(nodeEvaluatorFeatures.allowBreaching());
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Canvas end
+
     @Override
     protected PathFinder createPathFinder(int range) {
         this.allowBreaching = this.mob.getType() == EntityType.DOLPHIN;
         this.nodeEvaluator = new SwimNodeEvaluator(this.allowBreaching);
         this.nodeEvaluator.setCanPassDoors(false);
+        // Canvas start
+        if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+            return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+        }
+        // Canvas end
         return new PathFinder(this.nodeEvaluator, range);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
index 9104d7010bda6f9f73b478c11490ef9c53f76da2..8f38480f6c8110bf111ed49248077e4553b41a5a 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
@@ -2,12 +2,13 @@ package net.minecraft.world.entity.ai.sensing;
 
 import com.google.common.collect.ImmutableSet;
 import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPathProcessor;
 import it.unimi.dsi.fastutil.longs.Long2LongMap;
 import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.server.level.ServerLevel;
@@ -57,17 +58,37 @@ public class NearestBedSensor extends Sensor<Mob> {
             java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
             // don't ask me why it's unbounded. ask mojang.
             io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), world.purpurConfig.villagerNearestBedSensorSearchRadius, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes); // Purpur
-            Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
-            // Paper end - optimise POI access
-            if (path != null && path.canReach()) {
-                BlockPos blockPos = path.getTarget();
-                Optional<Holder<PoiType>> optional = poiManager.getType(blockPos);
-                if (optional.isPresent()) {
-                    entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, blockPos);
+            // Canvas start
+            if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                Path possiblePath = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                AsyncPathProcessor.awaitProcessing(possiblePath, world, path -> {
+                    // read canReach check
+                    if ((path == null || !path.canReach()) && this.triedCount < 5) {
+                        this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
+                        return;
+                    }
+                    if (path == null) return;
+
+                    BlockPos blockPos = path.getTarget();
+                    Optional<Holder<PoiType>> optional = poiManager.getType(blockPos);
+                    if (optional.isPresent()) {
+                        entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, blockPos);
+                    }
+                });
+            } else {
+                Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                // Paper end - optimise POI access
+                if (path != null && path.canReach()) {
+                    BlockPos blockPos = path.getTarget();
+                    Optional<Holder<PoiType>> optional = poiManager.getType(blockPos);
+                    if (optional.isPresent()) {
+                        entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, blockPos);
+                    }
+                } else if (this.triedCount < 5) {
+                    this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
                 }
-            } else if (this.triedCount < 5) {
-                this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
             }
+            // Canvas end
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Bee.java b/src/main/java/net/minecraft/world/entity/animal/Bee.java
index d2ac2c3a2481ee216a491333b173625da3881737..e72c6f456b5681ab19098eda3bd8483f54f607f4 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Bee.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Bee.java
@@ -1243,7 +1243,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                         } else {
                             Bee.this.pathfindRandomlyTowards(Bee.this.hivePos);
                         }
-                    } else {
+                    } else if (navigation.getPath() != null && navigation.getPath().isProcessed()) { // Canvas
                         boolean flag = this.pathfindDirectlyTowards(Bee.this.hivePos);
 
                         if (!flag) {
@@ -1302,7 +1302,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             } else {
                 Path pathentity = Bee.this.navigation.getPath();
 
-                return pathentity != null && pathentity.getTarget().equals(pos) && pathentity.canReach() && pathentity.isDone();
+                return pathentity != null && pathentity.isProcessed() && pathentity.getTarget().equals(pos) && pathentity.canReach() && pathentity.isDone(); // Canvas
             }
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
index e862803b38aceec149da8deddb9c88c46e916ad6..f80b0d245fa80ba90e491ba2e03fb7dc463d44d3 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
@@ -6,6 +6,10 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import javax.annotation.Nullable;
+
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -46,7 +50,6 @@ import net.minecraft.world.entity.VariantHolder;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
-import net.minecraft.world.entity.ai.control.LookControl;
 import net.minecraft.world.entity.ai.control.SmoothSwimmingMoveControl;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.navigation.AmphibiousPathNavigation;
@@ -483,6 +486,17 @@ public class Frog extends Animal implements VariantHolder<Holder<FrogVariant>> {
             super(frog, world);
         }
 
+        // Canvas start
+        private static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            Frog.FrogNodeEvaluator nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Canvas end
+
         @Override
         public boolean canCutCorner(PathType nodeType) {
             return nodeType != PathType.WATER_BORDER && super.canCutCorner(nodeType);
@@ -491,6 +505,11 @@ public class Frog extends Animal implements VariantHolder<Holder<FrogVariant>> {
         @Override
         protected PathFinder createPathFinder(int range) {
             this.nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            // Canvas start - async path processing
+            if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+                }
+            // Canvas end
             return new PathFinder(this.nodeEvaluator, range);
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Drowned.java b/src/main/java/net/minecraft/world/entity/monster/Drowned.java
index 76db5a2d27ab435fdfd1e0ec0c77ef5012e128d4..917fb62d59c610a998e88a821dbcda08e9b90992 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Drowned.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Drowned.java
@@ -309,7 +309,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
 
     protected boolean closeToNextPos() {
         Path path = this.getNavigation().getPath();
-        if (path != null) {
+        if (path != null && path.isProcessed()) { // Canvas
             BlockPos blockPos = path.getTarget();
             if (blockPos != null) {
                 double d = this.distanceToSqr((double)blockPos.getX(), (double)blockPos.getY(), (double)blockPos.getZ());
diff --git a/src/main/java/net/minecraft/world/entity/monster/Strider.java b/src/main/java/net/minecraft/world/entity/monster/Strider.java
index df44d9fbb71ff252cd261fc8da6de14383e054de..8de847bf4b3802d0bcd8cb709b1af74154b94c40 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Strider.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Strider.java
@@ -5,6 +5,10 @@ import com.google.common.collect.UnmodifiableIterator;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.Nullable;
+
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorFeatures;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
@@ -611,9 +615,25 @@ public class Strider extends Animal implements ItemSteerable, Saddleable {
             super(entity, world);
         }
 
+        // Canvas start
+        private static final NodeEvaluatorGenerator nodeEvaluatorGenerator = (NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Canvas end
+
         @Override
         protected PathFinder createPathFinder(int range) {
             this.nodeEvaluator = new WalkNodeEvaluator();
+            // Canvas start
+            if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                return new PathFinder(this.nodeEvaluator, range, nodeEvaluatorGenerator);
+            }
+            // Canvas end
             return new PathFinder(this.nodeEvaluator, range);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 19f7a6d55144adb5217fbea590d8f23d79ed05e0..b06d207620247bb5fc195b44f2ddd4484d2a820b 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -7,6 +7,7 @@ import java.util.Collections;
 import java.util.Optional;
 import java.util.function.BiConsumer;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.particles.BlockParticleOption;
@@ -616,6 +617,16 @@ public class Warden extends Monster implements VibrationSystem {
             @Override
             protected PathFinder createPathFinder(int range) {
                 this.nodeEvaluator = new WalkNodeEvaluator();
+                // Canvas start
+                if (Config.INSTANCE.pathfinding.enableThreadedPathfinding) {
+                    return new PathFinder(this.nodeEvaluator, range, GroundPathNavigation.nodeEvaluatorGenerator) {
+                        @Override
+                        protected float distance(Node a, Node b) {
+                            return a.distanceToXZ(b);
+                        }
+                    };
+                }
+                // Canvas end
                 return new PathFinder(this.nodeEvaluator, range) { // CraftBukkit - decompile error
                     @Override
                     protected float distance(Node a, Node b) {
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/Path.java b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
index d9d0fff9962131808d54cca20f209df50b8e4af1..c8b467410ab410a8ec532ad66bb1af76197835e6 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/Path.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
@@ -27,6 +27,12 @@ public class Path {
         this.reached = reachesTarget;
     }
 
+    // Canvas start
+    public boolean isProcessed() {
+        return true;
+    }
+    // Canvas end
+
     public void advance() {
         this.nextNodeIndex++;
     }
@@ -100,6 +106,7 @@ public class Path {
     }
 
     public boolean sameAs(@Nullable Path o) {
+        if (o == this) return true; // Canvas
         if (o == null) {
             return false;
         } else if (o.nodes.size() != this.nodes.size()) {
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
index cc7d94144e39f7dace7b569b4567def98396e8f9..08cbbc3d9021e5efde41afdeaf61a3c24a379af2 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -1,16 +1,15 @@
 package net.minecraft.world.level.pathfinder;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
-import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.Config;
+import io.github.dueris.canvas.entity.pathfinding.AsyncPath;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorCache;
+import io.github.dueris.canvas.entity.pathfinding.NodeEvaluatorGenerator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -25,11 +24,19 @@ public class PathFinder {
     public final NodeEvaluator nodeEvaluator;
     private static final boolean DEBUG = false;
     private final BinaryHeap openSet = new BinaryHeap();
+    private final @Nullable NodeEvaluatorGenerator nodeEvaluatorGenerator; // Canvas
 
-    public PathFinder(NodeEvaluator pathNodeMaker, int range) {
+    public PathFinder(NodeEvaluator pathNodeMaker, int range, @Nullable NodeEvaluatorGenerator nodeEvaluatorGenerator) { // Canvas
         this.nodeEvaluator = pathNodeMaker;
         this.maxVisitedNodes = range;
+        // Canvas start - support nodeEvaluatorgenerators
+        this.nodeEvaluatorGenerator = nodeEvaluatorGenerator;
+    }
+
+    public PathFinder(NodeEvaluator pathNodeMaker, int range) {
+        this(pathNodeMaker, range, null);
     }
+    // Canvas end
 
     public void setMaxVisitedNodes(int range) {
         this.maxVisitedNodes = range;
@@ -37,27 +44,63 @@ public class PathFinder {
 
     @Nullable
     public Path findPath(PathNavigationRegion world, Mob mob, Set<BlockPos> positions, float followRange, int distance, float rangeMultiplier) {
-        this.openSet.clear();
-        this.nodeEvaluator.prepare(world, mob);
-        Node node = this.nodeEvaluator.getStart();
+        if (!Config.INSTANCE.pathfinding.enableThreadedPathfinding)
+            this.openSet.clear(); // Canvas
+        // Canvas start
+        NodeEvaluator nodeEvaluator = this.nodeEvaluatorGenerator == null
+                ? this.nodeEvaluator
+                : NodeEvaluatorCache.takeNodeEvaluator(this.nodeEvaluatorGenerator, this.nodeEvaluator);
+        nodeEvaluator.prepare(world, mob);
+        Node node = nodeEvaluator.getStart();
+        // Canvas end
         if (node == null) {
+            NodeEvaluatorCache.removeNodeEvaluator(nodeEvaluator); // Canvas
             return null;
         } else {
             // Paper start - Perf: remove streams and optimize collection
             List<Map.Entry<Target, BlockPos>> map = Lists.newArrayList();
             for (final BlockPos pos : positions) {
-                map.add(new java.util.AbstractMap.SimpleEntry<>(this.nodeEvaluator.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos));
+                map.add(new java.util.AbstractMap.SimpleEntry<>(nodeEvaluator.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos)); // Canvas
             }
             // Paper end - Perf: remove streams and optimize collection
-            Path path = this.findPath(node, map, followRange, distance, rangeMultiplier);
-            this.nodeEvaluator.done();
-            return path;
+            // Canvas start
+            if (this.nodeEvaluatorGenerator == null) {
+                NodeEvaluatorCache.removeNodeEvaluator(nodeEvaluator);
+                return this.findPath(node, map, followRange, distance, rangeMultiplier);
+            }
+
+            return new AsyncPath(Lists.newArrayList(), positions, () -> {
+                try {
+                    return this.processPath(nodeEvaluator, node, map, followRange, distance, rangeMultiplier);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    return null;
+                } finally {
+                    nodeEvaluator.done();
+                    NodeEvaluatorCache.returnNodeEvaluator(nodeEvaluator);
+                }
+            });
+            // Canvas end
         }
     }
 
     @Nullable
     // Paper start - Perf: remove streams and optimize collection
     private Path findPath(Node startNode, List<Map.Entry<Target, BlockPos>> positions, float followRange, int distance, float rangeMultiplier) {
+        // Canvas start
+        try {
+            return this.processPath(this.nodeEvaluator, startNode, positions, followRange, distance, rangeMultiplier);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
+        } finally {
+            this.nodeEvaluator.done();
+        }
+    }
+
+    private synchronized @org.jetbrains.annotations.NotNull Path processPath(NodeEvaluator nodeEvaluator, Node startNode, List<Map.Entry<Target, BlockPos>> positions, float followRange, int distance, float rangeMultiplier) { // sync to only use the caching functions in this class on a single thread
+        org.apache.commons.lang3.Validate.isTrue(!positions.isEmpty());
+        // Canvas end
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("find_path");
         profilerFiller.markForCharting(MetricCategory.PATH_FINDING);
@@ -96,7 +139,7 @@ public class PathFinder {
             }
 
             if (!(node.distanceTo(startNode) >= followRange)) {
-                int k = this.nodeEvaluator.getNeighbors(this.neighbors, node);
+                int k = nodeEvaluator.getNeighbors(this.neighbors, node); // Canvas
 
                 for (int l = 0; l < k; l++) {
                     Node node2 = this.neighbors[l];
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
index 6308822f819d7cb84c8070c8a7eec1a3f822114b..148188e5d24c17142b51e40a74632900937810ae 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
@@ -15,7 +15,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
 
 public class SwimNodeEvaluator extends NodeEvaluator {
-    private final boolean allowBreaching;
+    public final boolean allowBreaching; // Canvas - private -> public
     private final Long2ObjectMap<PathType> pathTypesByPosCache = new Long2ObjectOpenHashMap<>();
 
     public SwimNodeEvaluator(boolean canJumpOutOfWater) {
