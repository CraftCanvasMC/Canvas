From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Thu, 5 Dec 2024 09:38:57 -0800
Subject: [PATCH] Concurrent Utils


diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentCollections.java b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentCollections.java
new file mode 100644
index 0000000000000000000000000000000000000000..02155de40de9805bbd9bd0ecff07a942b6e085db
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentCollections.java
@@ -0,0 +1,152 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+/**
+ * Factory methods for creating thread-safe collection instances.
+ * Provides convenient methods to create concurrent collections with standard interfaces.
+ */
+public final class ConcurrentCollections {
+
+    private static final Logger LOGGER = LogManager.getLogger(ConcurrentCollections.class);
+    
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    private ConcurrentCollections() {
+        throw new AssertionError("Utility class should not be instantiated");
+    }
+
+    /**
+     * Creates a new thread-safe set
+     *
+     * @param <T> the type of elements maintained by this set
+     * @return a new concurrent hash set
+     */
+    public static <T> Set<T> newHashSet() {
+        return newHashSet(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Creates a new thread-safe set with the specified initial capacity
+     *
+     * @param <T> the type of elements maintained by this set
+     * @param initialCapacity initial capacity of the set
+     * @return a new concurrent hash set
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public static <T> Set<T> newHashSet(int initialCapacity) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        return Collections.newSetFromMap(new ConcurrentHashMap<>(initialCapacity));
+    }
+
+    /**
+     * Creates a new thread-safe map
+     *
+     * @param <K> the type of keys maintained by this map
+     * @param <V> the type of mapped values
+     * @return a new concurrent hash map
+     */
+    public static <K, V> Map<K, V> newHashMap() {
+        return new ConcurrentHashMap<>(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Creates a new thread-safe map with the specified initial capacity
+     *
+     * @param <K> the type of keys maintained by this map
+     * @param <V> the type of mapped values
+     * @param initialCapacity initial capacity of the map
+     * @return a new concurrent hash map
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public static <K, V> Map<K, V> newHashMap(int initialCapacity) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        return new ConcurrentHashMap<>(initialCapacity);
+    }
+
+    /**
+     * Creates a collector that accumulates elements into a thread-safe list
+     *
+     * @param <T> the type of elements in the list
+     * @return a collector that accumulates elements into a CopyOnWriteArrayList
+     */
+    public static <T> Collector<T, ?, List<T>> toList() {
+        return Collectors.toCollection(CopyOnWriteArrayList::new);
+    }
+
+    /**
+     * Creates a new thread-safe deque
+     *
+     * @param <T> the type of elements maintained by this deque
+     * @return a new concurrent linked deque
+     */
+    public static <T> Queue<T> newArrayDeque() {
+        if (LOGGER.isDebugEnabled()) {
+            LOGGER.debug("Creating new concurrent linked deque");
+        }
+        return new ConcurrentLinkedDeque<>();
+    }
+
+    /**
+     * Creates a new thread-safe list
+     *
+     * @param <T> the type of elements maintained by this list
+     * @return a new copy-on-write array list
+     */
+    public static <T> List<T> newArrayList() {
+        return new CopyOnWriteArrayList<>();
+    }
+
+    /**
+     * Creates a new thread-safe list with the specified initial elements
+     *
+     * @param <T> the type of elements maintained by this list
+     * @param elements collection containing elements to be placed in the list
+     * @return a new copy-on-write array list containing the specified elements
+     * @throws NullPointerException if elements is null
+     */
+    public static <T> List<T> newArrayList(Collection<? extends T> elements) {
+        Objects.requireNonNull(elements, "Elements collection cannot be null");
+        return new CopyOnWriteArrayList<>(elements);
+    }
+
+    /**
+     * Creates an unmodifiable view of the specified concurrent map
+     *
+     * @param <K> the type of keys maintained by this map
+     * @param <V> the type of mapped values
+     * @param map the map for which an unmodifiable view is to be created
+     * @return an unmodifiable view of the specified map
+     * @throws NullPointerException if map is null
+     */
+    public static <K, V> Map<K, V> unmodifiableMap(ConcurrentHashMap<K, V> map) {
+        Objects.requireNonNull(map, "Map cannot be null");
+        return Collections.unmodifiableMap(map);
+    }
+
+    /**
+     * Creates a synchronized (thread-safe) view of the specified collection
+     *
+     * @param <T> the type of elements in the collection
+     * @param collection the collection for which a synchronized view is to be created
+     * @return a synchronized view of the specified collection
+     * @throws NullPointerException if collection is null
+     */
+    public static <T> Collection<T> synchronizedCollection(Collection<T> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return Collections.synchronizedCollection(collection);
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongLinkedOpenHashSet.java b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..34c158bdbb20af68476ed26fc84c181b439d2210
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongLinkedOpenHashSet.java
@@ -0,0 +1,255 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+import java.io.Serial;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+/**
+ * Thread-safe implementation of LongLinkedOpenHashSet using ConcurrentSkipListSet as backing storage.
+ * This implementation provides concurrent access and maintains elements in sorted order.
+ */
+public class ConcurrentLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    @Serial
+    private static final long serialVersionUID = -5532128240738069111L;
+    
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    
+    private final ConcurrentSkipListSet<Long> backing;
+
+    /**
+     * Constructs an empty set with default initial capacity
+     */
+    public ConcurrentLongLinkedOpenHashSet() {
+        this(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Constructs an empty set with the specified initial capacity
+     *
+     * @param initial the initial capacity
+     */
+    public ConcurrentLongLinkedOpenHashSet(final int initial) {
+        backing = new ConcurrentSkipListSet<>();
+    }
+
+    /**
+     * Constructs an empty set with the specified initial capacity and load factor
+     *
+     * @param initial initial capacity
+     * @param loadFactor load factor (ignored in this implementation)
+     */
+    public ConcurrentLongLinkedOpenHashSet(final int initial, final float loadFactor) {
+        this(initial);
+    }
+
+    /**
+     * Constructs a new set with the elements from the specified iterator
+     *
+     * @param iterator the iterator providing elements
+     */
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<Long> iterator) {
+        this();
+        addAll(iterator);
+    }
+
+    /**
+     * Constructs a new set with the elements from the specified iterator
+     *
+     * @param iterator the iterator providing elements
+     */
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator iterator) {
+        this();
+        addAll(iterator);
+    }
+
+    /**
+     * Constructs a new set with elements from array segment
+     *
+     * @param array source array
+     * @param offset starting position
+     * @param length number of elements
+     */
+    public ConcurrentLongLinkedOpenHashSet(final long[] array, final int offset, final int length) {
+        this(Math.max(length, 0));
+        Objects.requireNonNull(array, "Source array cannot be null");
+        LongArrays.ensureOffsetLength(array, offset, length);
+        
+        for (int i = 0; i < length; i++) {
+            add(array[offset + i]);
+        }
+    }
+
+    /**
+     * Constructs a new set with all elements from the array
+     *
+     * @param array source array
+     */
+    public ConcurrentLongLinkedOpenHashSet(final long[] array) {
+        this(array, 0, array.length);
+    }
+
+    // Private helper methods for adding elements from iterators
+    private void addAll(LongIterator iterator) {
+        Objects.requireNonNull(iterator, "Iterator cannot be null");
+        iterator.forEachRemaining(this::add);
+    }
+
+    private void addAll(Iterator<Long> iterator) {
+        Objects.requireNonNull(iterator, "Iterator cannot be null");
+        iterator.forEachRemaining(this::add);
+    }
+
+    @Override
+    public boolean add(final long k) {
+        return backing.add(k);
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return addAll((Collection<Long>) c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Long> c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean addAndMoveToFirst(final long k) {
+        return add(k); // Order is maintained by ConcurrentSkipListSet
+    }
+
+    @Override
+    public boolean addAndMoveToLast(final long k) {
+        return add(k); // Order is maintained by ConcurrentSkipListSet
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public LongLinkedOpenHashSet clone() {
+        return new ConcurrentLongLinkedOpenHashSet(backing.iterator());
+    }
+
+    @Override
+    public boolean contains(final long k) {
+        return backing.contains(k);
+    }
+
+    @Override
+    public long firstLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        return backing.first();
+    }
+
+    @Override
+    public long lastLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        return backing.last();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public LongListIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public boolean remove(final long k) {
+        return backing.remove(k);
+    }
+
+    @Override
+    public long removeFirstLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        long first = firstLong();
+        remove(first);
+        return first;
+    }
+
+    @Override
+    public long removeLastLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        long last = lastLong();
+        remove(last);
+        return last;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public LongSortedSet subSet(long from, long to) {
+        throw new UnsupportedOperationException("subSet operation is not supported");
+    }
+
+    @Override
+    public LongSortedSet headSet(long to) {
+        throw new UnsupportedOperationException("headSet operation is not supported");
+    }
+
+    @Override
+    public LongListIterator iterator(long from) {
+        throw new UnsupportedOperationException("Iterator from position is not supported");
+    }
+
+    @Override
+    public LongSortedSet tailSet(long from) {
+        throw new UnsupportedOperationException("tailSet operation is not supported");
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null; // Natural ordering is used
+    }
+
+    @Override
+    public boolean trim() {
+        return true; // No-op since ConcurrentSkipListSet handles its own memory
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true; // No-op since ConcurrentSkipListSet handles its own memory
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (!(obj instanceof ConcurrentLongLinkedOpenHashSet other)) return false;
+        return backing.equals(other.backing);
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongSortedSet.java b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongSortedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..15ddb9e1ef78a3e2a70922202d07c31d1b3495c7
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentLongSortedSet.java
@@ -0,0 +1,213 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+/**
+ * A thread-safe implementation of LongSortedSet backed by ConcurrentSkipListSet.
+ * Provides concurrent access and maintains elements in sorted order.
+ */
+public final class ConcurrentLongSortedSet implements LongSortedSet {
+    
+    private final ConcurrentSkipListSet<Long> backing;
+
+    /**
+     * Creates a new empty concurrent sorted set
+     */
+    public ConcurrentLongSortedSet() {
+        this.backing = new ConcurrentSkipListSet<>();
+    }
+
+    /**
+     * Creates a new concurrent sorted set containing elements from the given collection
+     *
+     * @param collection initial elements
+     * @throws NullPointerException if collection is null
+     */
+    public ConcurrentLongSortedSet(Collection<Long> collection) {
+        this();
+        addAll(Objects.requireNonNull(collection, "Initial collection cannot be null"));
+    }
+
+    @Override
+    public LongBidirectionalIterator iterator(long fromElement) {
+        return FastUtilHackUtil.wrap(backing.tailSet(fromElement).iterator());
+    }
+
+    @Override
+    public LongBidirectionalIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T> T[] toArray(@NotNull T[] array) {
+        Objects.requireNonNull(array, "Array cannot be null");
+        return backing.toArray(array);
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Long> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public boolean add(long key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean contains(long key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public long[] toLongArray() {
+        return backing.stream()
+                .mapToLong(Long::longValue)
+                .toArray();
+    }
+
+    @Override
+    public long[] toArray(long[] array) {
+        Objects.requireNonNull(array, "Array cannot be null");
+        long[] result = toLongArray();
+        if (array.length < result.length) {
+            return result;
+        }
+        System.arraycopy(result, 0, array, 0, result.length);
+        if (array.length > result.length) {
+            array[result.length] = 0L; // Set terminating null as per Collection convention
+        }
+        return array;
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return c.stream().map(backing::add).reduce(false, (a, b) -> a || b);
+    }
+
+    @Override
+    public boolean containsAll(LongCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return c.stream().allMatch(this::contains);
+    }
+
+    @Override
+    public boolean removeAll(LongCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return c.stream().map(this::remove).reduce(false, (a, b) -> a || b);
+    }
+
+    @Override
+    public boolean retainAll(LongCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(long k) {
+        return backing.remove(k);
+    }
+
+@Override
+public LongSortedSet subSet(long fromElement, long toElement) {
+    // Используем min/max для определения правильного диапазона
+    long actualFromElement = Math.min(fromElement, toElement);
+    long actualToElement = Math.max(fromElement, toElement);
+    return new ConcurrentLongSortedSet(backing.subSet(actualFromElement, actualToElement));
+}
+
+    @Override
+    public LongSortedSet headSet(long toElement) {
+        return new ConcurrentLongSortedSet(backing.headSet(toElement));
+    }
+
+    @Override
+    public LongSortedSet tailSet(long fromElement) {
+        return new ConcurrentLongSortedSet(backing.tailSet(fromElement));
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null; // Natural ordering is used
+    }
+
+    @Override
+    public long firstLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        return backing.first();
+    }
+
+    @Override
+    public long lastLong() {
+        if (isEmpty()) {
+            throw new IllegalStateException("Set is empty");
+        }
+        return backing.last();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof LongSortedSet that)) return false;
+        return backing.equals(that);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentShortHashSet.java b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentShortHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c15894fbe5274a2fd1c51d64fab3f6d3a25be19
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/ConcurrentShortHashSet.java
@@ -0,0 +1,206 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import it.unimi.dsi.fastutil.shorts.ShortSet;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A thread-safe implementation of ShortSet using ConcurrentHashMap.KeySetView as backing storage.
+ * This implementation provides concurrent access and high performance for concurrent operations.
+ */
+public final class ConcurrentShortHashSet implements ShortSet {
+    
+    private final ConcurrentHashMap.KeySetView<Short, Boolean> backing;
+    
+    /**
+     * Creates a new empty concurrent short set
+     */
+    public ConcurrentShortHashSet() {
+        this.backing = ConcurrentHashMap.newKeySet();
+    }
+
+    /**
+     * Creates a new concurrent short set containing all elements from the given collection
+     *
+     * @param collection initial elements
+     * @throws NullPointerException if collection is null
+     */
+    public ConcurrentShortHashSet(Collection<Short> collection) {
+        this();
+        addAll(Objects.requireNonNull(collection, "Initial collection cannot be null"));
+    }
+
+    /**
+     * Creates a new concurrent short set with the specified initial capacity
+     *
+     * @param initialCapacity the initial capacity of the set
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public ConcurrentShortHashSet(int initialCapacity) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        this.backing = ConcurrentHashMap.newKeySet(initialCapacity);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public ShortIterator iterator() {
+        return FastUtilHackUtil.itrShortWrap(backing);
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @NotNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T[] toArray(@NotNull T[] array) {
+        Objects.requireNonNull(array, "Array cannot be null");
+        return backing.toArray(array);
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Short> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        Objects.requireNonNull(collection, "Collection cannot be null");
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public boolean add(short key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean contains(short key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public short[] toShortArray() {
+        Object[] objects = backing.toArray();
+        short[] result = new short[objects.length];
+        for (int i = 0; i < objects.length; i++) {
+            result[i] = (Short) objects[i];
+        }
+        return result;
+    }
+
+    @Override
+    public short[] toArray(short[] array) {
+        Objects.requireNonNull(array, "Array cannot be null");
+        short[] result = toShortArray();
+        if (array.length < result.length) {
+            return result;
+        }
+        System.arraycopy(result, 0, array, 0, result.length);
+        if (array.length > result.length) {
+            array[result.length] = 0;
+        }
+        return array;
+    }
+
+    @Override
+    public boolean addAll(ShortCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        boolean modified = false;
+        ShortIterator iterator = c.iterator();
+        while (iterator.hasNext()) {
+            modified |= add(iterator.nextShort());
+        }
+        return modified;
+    }
+
+    @Override
+    public boolean containsAll(ShortCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        ShortIterator iterator = c.iterator();
+        while (iterator.hasNext()) {
+            if (!contains(iterator.nextShort())) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public boolean removeAll(ShortCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        boolean modified = false;
+        ShortIterator iterator = c.iterator();
+        while (iterator.hasNext()) {
+            modified |= remove(iterator.nextShort());
+        }
+        return modified;
+    }
+
+    @Override
+    public boolean retainAll(ShortCollection c) {
+        Objects.requireNonNull(c, "Collection cannot be null");
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(short k) {
+        return backing.remove(k);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof ShortSet that)) return false;
+        
+        if (size() != that.size()) return false;
+        return containsAll((ShortCollection) that);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/FastUtilHackUtil.java b/src/main/java/io/github/dueris/canvas/util/fastutil/FastUtilHackUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..258db27a7608dbadaa4327de38408d29179b51fb
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/FastUtilHackUtil.java
@@ -0,0 +1,1572 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import org.apache.commons.lang3.ArrayUtils;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.bytes.ByteIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+public final class FastUtilHackUtil {
+    
+    private FastUtilHackUtil() {
+        throw new AssertionError("No instances");
+    }
+
+    public static class ConvertingObjectSet<E, T> implements ObjectSet<T> {
+        private final Set<E> backing;
+        private final Function<E, T> forward;
+        private final Function<T, E> back;
+
+        public ConvertingObjectSet(Set<E> backing, Function<E, T> forward, Function<T, E> back) {
+            this.backing = Objects.requireNonNull(backing, "Backing set cannot be null");
+            this.forward = Objects.requireNonNull(forward, "Forward function cannot be null");
+            this.back = Objects.requireNonNull(back, "Backward function cannot be null");
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @Override
+        public boolean add(T e) {
+            return backing.add(back.apply(e));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((T) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends T> c) {
+            return backing.addAll(c.stream().map(back).collect(Collectors.toSet()));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream()
+                        .map(i -> back.apply((T) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((T) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<T> iterator() {
+            return new ObjectIterator<>() {
+                private final Iterator<E> backg = backing.iterator();
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public T next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+    }
+
+public static class ConvertingObjectSetFast<E, T> 
+            implements Long2ObjectMap.FastEntrySet<T> {
+        private final Set<E> backing;
+        private final Function<E, Long2ObjectMap.Entry<T>> forward;
+        private final Function<Long2ObjectMap.Entry<T>, E> back;
+
+        public ConvertingObjectSetFast(
+                Set<E> backing,
+                Function<E, Long2ObjectMap.Entry<T>> forward,
+                Function<Long2ObjectMap.Entry<T>, E> back) {
+            this.backing = Objects.requireNonNull(backing);
+            this.forward = Objects.requireNonNull(forward);
+            this.back = Objects.requireNonNull(back);
+        }
+
+         @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((Long2ObjectMap.Entry<T>) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((Long2ObjectMap.Entry<T>) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> iterator() {
+            return fastIterator();
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> fastIterator() {
+            return new ObjectIterator<>() {
+                private final Iterator<E> it = backing.iterator();
+
+                @Override
+                public boolean hasNext() {
+                    return it.hasNext();
+                }
+
+                @Override
+                public Long2ObjectMap.Entry<T> next() {
+                    return forward.apply(it.next());
+                }
+
+                @Override
+                public void remove() {
+                    it.remove();
+                }
+            };
+        }
+
+   @Override
+        public boolean add(Long2ObjectMap.Entry<T> e) {
+            return backing.add(back.apply(e));
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long2ObjectMap.Entry<T>> c) {
+            return backing.addAll(c.stream().map(back).toList());
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+    }
+
+    private static <T> Int2ObjectMap.Entry<T> intEntryForwards(Map.Entry<Integer, T> entry) {
+        return new Int2ObjectMap.Entry<>() {
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public int getIntKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Integer, T> intEntryBackwards(Int2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static <T> Long2ObjectMap.Entry<T> longEntryForwards(Map.Entry<Long, T> entry) {
+        return new Long2ObjectMap.Entry<>() {
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Long, T> longEntryBackwards(Long2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static Long2ByteMap.Entry longByteEntryForwards(Map.Entry<Long, Byte> entry) {
+        return new Long2ByteMap.Entry() {
+            @Override
+            public Byte getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public byte setValue(byte value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public byte getByteValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static Map.Entry<Long, Byte> longByteEntryBackwards(Long2ByteMap.Entry entry) {
+        return entry;
+    }
+
+    private static Long2LongMap.Entry longLongEntryForwards(Map.Entry<Long, Long> entry) {
+        return new Long2LongMap.Entry() {
+            @Override
+            public Long getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long setValue(long value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static Map.Entry<Long, Long> longLongEntryBackwards(Long2LongMap.Entry entry) {
+        return entry;
+    }
+
+    static class WrappingIntIterator implements IntIterator {
+        private final Iterator<Integer> backing;
+
+        WrappingIntIterator(Iterator<Integer> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public int nextInt() {
+            return backing.next();
+        }
+
+        @Override
+        public Integer next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+    }
+
+    static class WrappingLongIterator implements LongIterator {
+        private final Iterator<Long> backing;
+
+        WrappingLongIterator(Iterator<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public Long next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+    }
+
+    static class WrappingShortIterator implements ShortIterator {
+        private final Iterator<Short> backing;
+
+        WrappingShortIterator(Iterator<Short> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public short nextShort() {
+            return backing.next();
+        }
+
+        @Override
+        public Short next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+    }
+
+    static class WrappingByteIterator implements ByteIterator {
+        private final Iterator<Byte> backing;
+
+        WrappingByteIterator(Iterator<Byte> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public byte nextByte() {
+            return next();
+        }
+
+        @Override
+        public Byte next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+    }
+
+    public static class WrappingIntSet implements IntSet {
+        private final Set<Integer> backing;
+
+        public WrappingIntSet(Set<Integer> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean add(int key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(int key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return backing.stream().mapToInt(Integer::intValue).toArray();
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+@Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return new WrappingIntIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(int k) {
+            return backing.remove(k);
+        }
+    }
+
+    public static class WrappingLongSet implements LongSet {
+        private final Set<Long> backing;
+
+        public WrappingLongSet(Set<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(Long::longValue).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return new WrappingLongIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+    }
+
+    public static class WrappingLongSortedSet implements LongSortedSet {
+        private final Set<Long> backing;
+
+        public WrappingLongSortedSet(Set<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(Long::longValue).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            }
+            return toLongArray();
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator() {
+            return wrap(new LinkedList<>(backing).iterator());
+        }
+
+        @Override
+        public LongSortedSet subSet(long fromElement, long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet headSet(long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet tailSet(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongComparator comparator() {
+            return null;
+        }
+
+        @Override
+        public long firstLong() {
+            return backing.stream().findFirst().orElseThrow();
+        }
+
+        @Override
+        public long lastLong() {
+            return backing.stream().reduce((first, second) -> second).orElseThrow();
+        }
+    }
+
+    public static class WrappingByteCollection implements ByteCollection {
+        private final Collection<Byte> backing;
+
+        public WrappingByteCollection(Collection<Byte> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(byte o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(byte e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Byte> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ByteIterator iterator() {
+            return itrByteWrap(backing);
+        }
+
+        @Override
+        public boolean rem(byte key) {
+            return remove(key);
+        }
+
+        @Override
+        public byte[] toByteArray() {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public byte[] toByteArray(byte[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public byte[] toArray(byte[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public boolean addAll(ByteCollection c) {
+            return addAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean containsAll(ByteCollection c) {
+            return containsAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean removeAll(ByteCollection c) {
+            return removeAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean retainAll(ByteCollection c) {
+            return retainAll((Collection<?>) c);
+        }
+    }
+
+    // Utility methods
+    public static <T> ObjectSet<Int2ObjectMap.Entry<T>> entrySetIntWrap(Map<Integer, T> map) {
+        return new ConvertingObjectSet<>(
+            map.entrySet(),
+            FastUtilHackUtil::intEntryForwards,
+            FastUtilHackUtil::intEntryBackwards
+        );
+    }
+
+    public static <T> ObjectSet<Long2ObjectMap.Entry<T>> entrySetLongWrap(Map<Long, T> map) {
+        return new ConvertingObjectSet<>(
+            map.entrySet(),
+            FastUtilHackUtil::longEntryForwards,
+            FastUtilHackUtil::longEntryBackwards
+        );
+    }
+
+    public static <T> Long2ObjectMap.FastEntrySet<T> entrySetLongWrapFast(Map<Long, T> map) {
+        return new ConvertingObjectSetFast<>(
+            map.entrySet(),
+            FastUtilHackUtil::longEntryForwards,
+            FastUtilHackUtil::longEntryBackwards
+        );
+    }
+
+    public static ObjectSet<Long2ByteMap.Entry> entrySetLongByteWrap(Map<Long, Byte> map) {
+        return new ConvertingObjectSet<>(
+            map.entrySet(),
+            FastUtilHackUtil::longByteEntryForwards,
+            FastUtilHackUtil::longByteEntryBackwards
+        );
+    }
+
+    public static ObjectSet<Long2LongMap.Entry> entrySetLongLongWrap(Map<Long, Long> map) {
+        return new ConvertingObjectSet<>(
+            map.entrySet(),
+            FastUtilHackUtil::longLongEntryForwards,
+            FastUtilHackUtil::longLongEntryBackwards
+        );
+    }
+
+    public static LongSet wrapLongSet(Set<Long> longset) {
+        return new WrappingLongSet(longset);
+    }
+
+    public static LongSortedSet wrapLongSortedSet(Set<Long> longset) {
+        return new WrappingLongSortedSet(longset);
+    }
+
+    public static IntSet wrapIntSet(Set<Integer> intset) {
+        return new WrappingIntSet(intset);
+    }
+
+    public static ByteCollection wrapBytes(Collection<Byte> c) {
+        return new WrappingByteCollection(c);
+    }
+
+    public static ByteIterator itrByteWrap(Iterator<Byte> backing) {
+        return new WrappingByteIterator(backing);
+    }
+
+    public static ByteIterator itrByteWrap(Iterable<Byte> backing) {
+        return itrByteWrap(backing.iterator());
+    }
+
+    public static IntIterator itrIntWrap(Iterator<Integer> backing) {
+        return new WrappingIntIterator(backing);
+    }
+
+    public static IntIterator itrIntWrap(Iterable<Integer> backing) {
+        return itrIntWrap(backing.iterator());
+    }
+
+    public static LongIterator itrLongWrap(Iterator<Long> backing) {
+        return new WrappingLongIterator(backing);
+    }
+
+    public static LongIterator itrLongWrap(Iterable<Long> backing) {
+        return itrLongWrap(backing.iterator());
+    }
+
+    public static ShortIterator itrShortWrap(Iterator<Short> backing) {
+        return new WrappingShortIterator(backing);
+    }
+
+    public static ShortIterator itrShortWrap(Iterable<Short> backing) {
+        return itrShortWrap(backing.iterator());
+    }
+
+    public static LongListIterator wrap(ListIterator<Long> c) {
+        return new WrappingLongListIterator(c);
+    }
+
+    public static LongListIterator wrap(Iterator<Long> c) {
+        return new SlimWrappingLongListIterator(c);
+    }
+
+    public static class WrappingLongListIterator implements LongListIterator {
+        private final ListIterator<Long> backing;
+
+        WrappingLongListIterator(ListIterator<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public long previousLong() {
+            return backing.previous();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return backing.hasPrevious();
+        }
+
+        @Override
+        public int nextIndex() {
+            return backing.nextIndex();
+        }
+
+        @Override
+        public int previousIndex() {
+            return backing.previousIndex();
+        }
+
+        @Override
+        public void add(long k) {
+            backing.add(k);
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            backing.set(k);
+        }
+    }
+
+    public static class SlimWrappingLongListIterator implements LongListIterator {
+        private final Iterator<Long> backing;
+
+        SlimWrappingLongListIterator(Iterator<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public long previousLong() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int nextIndex() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int previousIndex() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void add(long k) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    public static class WrappingObjectCollection<V> implements ObjectCollection<V> {
+        private final Collection<V> backing;
+
+        public WrappingObjectCollection(Collection<V> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(V e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<V> iterator() {
+            return itrWrap(backing);
+        }
+    }
+
+    public static class WrappingIntCollection implements IntCollection {
+        private final Collection<Integer> backing;
+
+        public WrappingIntCollection(Collection<Integer> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(int o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(int e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return itrIntWrap(backing);
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return remove(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return addAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return containsAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return removeAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return retainAll((Collection<?>) c);
+        }
+    }
+
+    public static class WrappingLongCollection implements LongCollection {
+        private final Collection<Long> backing;
+
+        public WrappingLongCollection(Collection<Long> backing) {
+            this.backing = Objects.requireNonNull(backing);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(long o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(long e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return itrLongWrap(backing);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return remove(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return addAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return containsAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return removeAll((Collection<?>) c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return retainAll((Collection<?>) c);
+        }
+    }
+
+    // Utility methods
+    public static <K> ObjectCollection<K> wrap(Collection<K> c) {
+        return new WrappingObjectCollection<>(c);
+    }
+
+    public static IntCollection wrapInts(Collection<Integer> c) {
+        return new WrappingIntCollection(c);
+    }
+
+    public static LongCollection wrapLongs(Collection<Long> c) {
+        return new WrappingLongCollection(c);
+    }
+
+    private static class WrapperObjectIterator<T> implements ObjectIterator<T> {
+        private final Iterator<T> parent;
+
+        public WrapperObjectIterator(Iterator<T> parent) {
+            this.parent = Objects.requireNonNull(parent);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public T next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterator<T> in) {
+        return new WrapperObjectIterator<>(in);
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterable<T> in) {
+        return new WrapperObjectIterator<>(in.iterator());
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Int2ObjectConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Int2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..04733f23f4d6031b7954f267cdf0fe54ec3b1e66
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Int2ObjectConcurrentHashMap.java
@@ -0,0 +1,232 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A thread-safe implementation of Int2ObjectMap using ConcurrentHashMap as backing storage.
+ * Provides concurrent access and high performance for integer-keyed maps.
+ *
+ * @param <V> the type of values maintained by this map
+ */
+public final class Int2ObjectConcurrentHashMap<V> implements Int2ObjectMap<V> {
+
+    private final ConcurrentHashMap<Integer, V> backing;
+    private V defaultReturnValue;
+
+    /**
+     * Creates a new empty concurrent map
+     */
+    public Int2ObjectConcurrentHashMap() {
+        this(16);
+    }
+
+    /**
+     * Creates a new concurrent map with the specified initial capacity
+     *
+     * @param initialCapacity the initial capacity of the map
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public Int2ObjectConcurrentHashMap(int initialCapacity) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        this.backing = new ConcurrentHashMap<>(initialCapacity);
+    }
+
+    /**
+     * Creates a new concurrent map with the contents of the given map
+     *
+     * @param map the map whose mappings are to be placed in this map
+     * @throws NullPointerException if map is null
+     */
+    public Int2ObjectConcurrentHashMap(Map<Integer, V> map) {
+        this(Math.max(16, map.size()));
+        putAll(Objects.requireNonNull(map, "Source map cannot be null"));
+    }
+
+    @Override
+    public V get(int key) {
+        V value = backing.get(key);
+        return value != null ? value : defaultReturnValue;
+    }
+
+    @Override
+    public V get(Object key) {
+        V value = backing.get(key);
+        return value != null ? value : defaultReturnValue;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        Objects.requireNonNull(m, "Source map cannot be null");
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        this.defaultReturnValue = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturnValue;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetIntWrap(backing);
+    }
+
+    @Override
+    public IntSet keySet() {
+        return FastUtilHackUtil.wrapIntSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(int key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V remove(int key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    /**
+     * Attempts to compute a mapping for the specified key and its current mapped value (or null if no
+     * current mapping exists).
+     *
+     * @param key key with which the specified value is to be associated
+     * @param remappingFunction the function to compute a value
+     * @return the new value associated with the specified key, or null if none
+     * @throws NullPointerException if the remappingFunction is null
+     */
+    public V compute(int key, java.util.function.BiFunction<? super Integer, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(remappingFunction);
+        return backing.compute(key, remappingFunction);
+    }
+
+    /**
+     * Returns a concurrent map view of this map where every operation preserves key primitiveness
+     *
+     * @return a concurrent map view of this map
+     */
+    public ConcurrentHashMap<Integer, V> concurrentView() {
+        return backing;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Int2ObjectMap<?> that)) return false;
+        
+        if (size() != that.size()) return false;
+        return int2ObjectEntrySet().containsAll(that.int2ObjectEntrySet());
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+
+    /**
+     * Returns the value to which the specified key is mapped, or the default value if
+     * this map contains no mapping for the key.
+     *
+     * @param key the key whose associated value is to be returned
+     * @param defaultValue the default mapping of the key
+     * @return the value to which the specified key is mapped, or defaultValue
+     */
+    public V getOrDefault(int key, V defaultValue) {
+        V value = get(key);
+        return value != null ? value : defaultValue;
+    }
+
+    /**
+     * If the specified key is not already associated with a value, associates it with
+     * the given value and returns null, else returns the current value.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value value to be associated with the specified key
+     * @return the previous value associated with the specified key, or null
+     */
+    public V putIfAbsent(int key, V value) {
+        return backing.putIfAbsent(key, value);
+    }
+
+    /**
+     * Removes the entry for the specified key only if it is currently mapped to the specified value.
+     *
+     * @param key key with which the specified value is associated
+     * @param value value expected to be associated with the specified key
+     * @return true if the value was removed
+     */
+    public boolean remove(int key, Object value) {
+        return backing.remove(key, value);
+    }
+
+    /**
+     * Replaces the entry for the specified key only if currently mapped to the specified value.
+     *
+     * @param key key with which the specified value is associated
+     * @param oldValue value expected to be associated with the specified key
+     * @param newValue value to be associated with the specified key
+     * @return true if the value was replaced
+     */
+    public boolean replace(int key, V oldValue, V newValue) {
+        return backing.replace(key, oldValue, newValue);
+    }
+
+    /**
+     * Replaces the entry for the specified key only if it is currently mapped to some value.
+     *
+     * @param key key with which the specified value is associated
+     * @param value value to be associated with the specified key
+     * @return the previous value associated with the specified key, or null
+     */
+    public V replace(int key, V value) {
+        return backing.replace(key, value);
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ByteConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ByteConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5ad7e12afd3006b1f74c140f422036d6d660b43
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ByteConcurrentHashMap.java
@@ -0,0 +1,218 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A thread-safe implementation of Long2ByteMap using ConcurrentHashMap as backing storage.
+ * Provides concurrent access and high performance for primitive long-to-byte mappings.
+ */
+public final class Long2ByteConcurrentHashMap implements Long2ByteMap {
+
+    private final ConcurrentHashMap<Long, Byte> backing;
+    private byte defaultReturnValue;
+
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    /**
+     * Creates a new empty concurrent map with default initial capacity and load factor
+     */
+    public Long2ByteConcurrentHashMap() {
+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new empty concurrent map with specified initial capacity and load factor
+     *
+     * @param initialCapacity initial capacity of the map
+     * @param loadFactor load factor of the map
+     * @throws IllegalArgumentException if initialCapacity is negative or loadFactor is non-positive
+     */
+    public Long2ByteConcurrentHashMap(int initialCapacity, float loadFactor) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        if (loadFactor <= 0) {
+            throw new IllegalArgumentException("Load factor must be positive: " + loadFactor);
+        }
+        this.backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    /**
+     * Creates a new concurrent map containing the same mappings as the specified map
+     *
+     * @param map the map whose mappings are to be placed in this map
+     * @throws NullPointerException if map is null
+     */
+    public Long2ByteConcurrentHashMap(Map<? extends Long, ? extends Byte> map) {
+        this(Math.max(DEFAULT_INITIAL_CAPACITY, map.size()));
+        putAll(Objects.requireNonNull(map, "Source map cannot be null"));
+    }
+
+    /**
+     * Creates a new empty concurrent map with specified initial capacity
+     *
+     * @param initialCapacity initial capacity of the map
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public Long2ByteConcurrentHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    @Override
+    public byte get(long key) {
+        Byte value = backing.get(key);
+        return value != null ? value : defaultReturnValue;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(byte value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Byte> m) {
+        Objects.requireNonNull(m, "Source map cannot be null");
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(byte rv) {
+        this.defaultReturnValue = rv;
+    }
+
+    @Override
+    public byte defaultReturnValue() {
+        return defaultReturnValue;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2ByteEntrySet() {
+        return FastUtilHackUtil.entrySetLongByteWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ByteCollection values() {
+        return FastUtilHackUtil.wrapBytes(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public byte put(long key, byte value) {
+        Byte previous = backing.put(key, value);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    @Override
+    public byte remove(long key) {
+        Byte previous = backing.remove(key);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    /**
+     * Returns the value associated with the specified key, or the default value
+     * if no mapping exists.
+     *
+     * @param key key to look up
+     * @param defaultValue value to return if key is not found
+     * @return the value associated with key, or defaultValue if not found
+     */
+    public byte getOrDefault(long key, byte defaultValue) {
+        Byte value = backing.get(key);
+        return value != null ? value : defaultValue;
+    }
+
+    /**
+     * Associates the specified value with the specified key if no value is present
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value value to be associated with the specified key
+     * @return the previous value or defaultReturnValue if none
+     */
+    public byte putIfAbsent(long key, byte value) {
+        Byte previous = backing.putIfAbsent(key, value);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    /**
+     * Removes the entry for the specified key only if it is currently mapped to the specified value
+     *
+     * @param key key with which the specified value is associated
+     * @param value value expected to be associated with the key
+     * @return true if the value was removed
+     */
+    public boolean remove(long key, byte value) {
+        return backing.remove(key, value);
+    }
+
+    /**
+     * Replaces the entry for the specified key only if it is currently mapped to the specified value
+     *
+     * @param key key with which the specified value is associated
+     * @param oldValue value expected to be associated with the key
+     * @param newValue value to be associated with the key
+     * @return true if the value was replaced
+     */
+    public boolean replace(long key, byte oldValue, byte newValue) {
+        return backing.replace(key, oldValue, newValue);
+    }
+
+    /**
+     * Returns the concurrent map backing this primitive map
+     *
+     * @return the backing concurrent map
+     */
+    public ConcurrentHashMap<Long, Byte> concurrentView() {
+        return backing;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Long2ByteMap that)) return false;
+        
+        if (size() != that.size()) return false;
+        return long2ByteEntrySet().containsAll(that.long2ByteEntrySet());
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Long2IntConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2IntConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb1df546867a8aa97b22d70776ed5aaee21edd73
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2IntConcurrentHashMap.java
@@ -0,0 +1,193 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiFunction;
+
+/**
+ * A thread-safe implementation of Long2IntMap using ConcurrentHashMap as backing storage.
+ */
+public final class Long2IntConcurrentHashMap implements Long2IntMap {
+
+    private final ConcurrentHashMap<Long, Integer> backing;
+    private int defaultReturnValue;
+
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    public Long2IntConcurrentHashMap() {
+        this(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    public Long2IntConcurrentHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    public Long2IntConcurrentHashMap(int initialCapacity, float loadFactor) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        if (loadFactor <= 0) {
+            throw new IllegalArgumentException("Load factor must be positive: " + loadFactor);
+        }
+        this.backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    public Long2IntConcurrentHashMap(Map<? extends Long, ? extends Integer> map) {
+        this(Math.max(DEFAULT_INITIAL_CAPACITY, map.size()));
+        putAll(Objects.requireNonNull(map, "Source map cannot be null"));
+    }
+
+    @Override
+    public int get(long key) {
+        Integer value = backing.get(key);
+        return value != null ? value : defaultReturnValue;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        Objects.requireNonNull(m, "Source map cannot be null");
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(int rv) {
+        this.defaultReturnValue = rv;
+    }
+
+    @Override
+    public int defaultReturnValue() {
+        return defaultReturnValue;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2IntEntrySet() {
+        throw new UnsupportedOperationException("Entry set is not supported");
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(int value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public int put(long key, int value) {
+        Integer previous = backing.put(key, value);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    @Override
+    public int remove(long key) {
+        Integer previous = backing.remove(key);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    public int getOrDefault(long key, int defaultValue) {
+        Integer value = backing.get(key);
+        return value != null ? value : defaultValue;
+    }
+
+    public int putIfAbsent(long key, int value) {
+        Integer previous = backing.putIfAbsent(key, value);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    public boolean remove(long key, int value) {
+        return backing.remove(key, value);
+    }
+
+    public boolean replace(long key, int oldValue, int newValue) {
+        return backing.replace(key, oldValue, newValue);
+    }
+
+    public int replace(long key, int value) {
+        Integer previous = backing.replace(key, value);
+        return previous != null ? previous : defaultReturnValue;
+    }
+
+    public int compute(long key, BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        Integer newValue = backing.compute(key, remappingFunction);
+        return newValue != null ? newValue : defaultReturnValue;
+    }
+
+    public int computeIfPresent(long key, BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        Integer newValue = backing.computeIfPresent(key, remappingFunction);
+        return newValue != null ? newValue : defaultReturnValue;
+    }
+
+    public int computeIfAbsent(long key, java.util.function.LongFunction<? extends Integer> mappingFunction) {
+        Objects.requireNonNull(mappingFunction, "Mapping function cannot be null");
+        Integer newValue = backing.computeIfAbsent(key, k -> mappingFunction.apply(k));
+        return newValue != null ? newValue : defaultReturnValue;
+    }
+
+    public ConcurrentHashMap<Long, Integer> concurrentView() {
+        return backing;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Long2IntMap that)) return false;
+        
+        if (size() != that.size()) return false;
+        try {
+            for (Entry entry : that.long2IntEntrySet()) {
+                if (get(entry.getLongKey()) != entry.getIntValue()) {
+                    return false;
+                }
+            }
+            return true;
+        } catch (UnsupportedOperationException e) {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Long2LongConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2LongConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b14f63c6501144b0b3f9a9cd620b24ebcd2087a
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2LongConcurrentHashMap.java
@@ -0,0 +1,101 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class Long2LongConcurrentHashMap implements Long2LongMap {
+
+    public Map<Long, Long> backing = new ConcurrentHashMap<>();
+    long defaultRV;
+
+    public Long2LongConcurrentHashMap(long defaultRV) {
+        this.defaultRV = defaultRV;
+    }
+
+    @Override
+    public long get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long put(final long key, final long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long put(final Long key, final Long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public long remove(final long key) {
+        try {
+            return backing.remove(key);
+        }catch (NullPointerException e){
+            return 0;
+        }
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Long> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(long rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public long defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2LongEntrySet() {
+        return FastUtilHackUtil.entrySetLongLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public LongCollection values() {
+        return FastUtilHackUtil.wrapLongs(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(long value) {
+        return backing.containsValue(value);
+    }
+
+
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..de4c0dfaafb7317dc34749207cb39a07c40a80b2
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectConcurrentHashMap.java
@@ -0,0 +1,247 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiFunction;
+
+/**
+ * A thread-safe implementation of Long2ObjectMap using ConcurrentHashMap as backing storage.
+ * Provides concurrent access and high performance for long-to-object mappings.
+ *
+ * @param <V> the type of values maintained by this map
+ */
+public final class Long2ObjectConcurrentHashMap<V> implements Long2ObjectMap<V> {
+
+    private final ConcurrentHashMap<Long, V> backing;
+    private V defaultReturnValue;
+
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    /**
+     * Creates a new empty concurrent map with default initial capacity
+     */
+    public Long2ObjectConcurrentHashMap() {
+        this(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Creates a new empty concurrent map with specified initial capacity
+     *
+     * @param initialCapacity the initial capacity of the map
+     * @throws IllegalArgumentException if initialCapacity is negative
+     */
+    public Long2ObjectConcurrentHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new empty concurrent map with specified initial capacity and load factor
+     *
+     * @param initialCapacity initial capacity of the map
+     * @param loadFactor load factor of the map
+     * @throws IllegalArgumentException if initialCapacity is negative or loadFactor is non-positive
+     */
+    public Long2ObjectConcurrentHashMap(int initialCapacity, float loadFactor) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        if (loadFactor <= 0) {
+            throw new IllegalArgumentException("Load factor must be positive: " + loadFactor);
+        }
+        this.backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    /**
+     * Creates a new concurrent map containing the same mappings as the specified map
+     *
+     * @param map the map whose mappings are to be placed in this map
+     * @throws NullPointerException if map is null
+     */
+    public Long2ObjectConcurrentHashMap(Map<? extends Long, ? extends V> map) {
+        this(Math.max(DEFAULT_INITIAL_CAPACITY, map.size()));
+        putAll(Objects.requireNonNull(map, "Source map cannot be null"));
+    }
+
+    @Override
+    public V get(long key) {
+        V value = backing.get(key);
+        return (value == null && !backing.containsKey(key)) ? defaultReturnValue : value;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        Objects.requireNonNull(m, "Source map cannot be null");
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        this.defaultReturnValue = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturnValue;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        V previous = backing.put(key, value);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public V remove(long key) {
+        V previous = backing.remove(key);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    /**
+     * Returns the value to which the specified key is mapped, or defaultValue if
+     * this map contains no mapping for the key.
+     *
+     * @param key the key whose associated value is to be returned
+     * @param defaultValue the default mapping of the key
+     * @return the value to which the specified key is mapped, or defaultValue
+     */
+    public V getOrDefault(long key, V defaultValue) {
+        V value = backing.get(key);
+        return (value == null && !backing.containsKey(key)) ? defaultValue : value;
+    }
+
+    /**
+     * Associates the specified value with the specified key if no value is present
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value value to be associated with the specified key
+     * @return the previous value or defaultReturnValue if none
+     */
+    public V putIfAbsent(long key, V value) {
+        V previous = backing.putIfAbsent(key, value);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    /**
+     * Removes the entry for the specified key only if it is currently mapped to the specified value
+     *
+     * @param key key with which the specified value is associated
+     * @param value value expected to be associated with the specified key
+     * @return true if the value was removed
+     */
+    public boolean remove(long key, Object value) {
+        return backing.remove(key, value);
+    }
+
+    /**
+     * Replaces the entry for the specified key only if it is currently mapped to the specified value
+     *
+     * @param key key with which the specified value is associated
+     * @param oldValue value expected to be associated with the specified key
+     * @param newValue value to be associated with the specified key
+     * @return true if the value was replaced
+     */
+    public boolean replace(long key, V oldValue, V newValue) {
+        return backing.replace(key, oldValue, newValue);
+    }
+
+    /**
+     * Replaces the entry for the specified key only if it is currently mapped to some value
+     *
+     * @param key key with which the specified value is associated
+     * @param value value to be associated with the specified key
+     * @return the previous value or defaultReturnValue if none
+     */
+    public V replace(long key, V value) {
+        V previous = backing.replace(key, value);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    /**
+     * Attempts to compute a mapping for the specified key and its current mapped value
+     *
+     * @param key key with which the specified value is to be associated
+     * @param remappingFunction the function to compute a value
+     * @return the new value associated with the specified key, or defaultReturnValue if none
+     */
+    @Override
+    public V compute(long key, BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        V newValue = backing.compute(key, remappingFunction);
+        return (newValue == null && !backing.containsKey(key)) ? defaultReturnValue : newValue;
+    }
+
+    /**
+     * Returns the concurrent map backing this primitive map
+     *
+     * @return the backing concurrent map
+     */
+    public ConcurrentHashMap<Long, V> concurrentView() {
+        return backing;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Long2ObjectMap<?> that)) return false;
+        
+        if (size() != that.size()) return false;
+        return long2ObjectEntrySet().containsAll(that.long2ObjectEntrySet());
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectOpenConcurrentHashMap.java b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectOpenConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4553742615dd76fb89c5d8e4e1d31ab8448e605
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/fastutil/Long2ObjectOpenConcurrentHashMap.java
@@ -0,0 +1,327 @@
+package io.github.dueris.canvas.util.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectFunction;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.io.Serial;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.LongFunction;
+
+/**
+ * Thread-safe implementation of Long2ObjectOpenHashMap using ConcurrentHashMap as backing storage.
+ * Provides concurrent access and maintains thread safety for all operations.
+ *
+ * @param <V> the type of values maintained by this map
+ */
+public class Long2ObjectOpenConcurrentHashMap<V> extends Long2ObjectOpenHashMap<V> {
+
+    @Serial
+    private static final long serialVersionUID = -121514116954680057L;
+
+    private static final int DEFAULT_INITIAL_CAPACITY = 16;
+    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    private final ConcurrentHashMap<Long, V> backing;
+    private V defaultReturnValue;
+
+    /**
+     * Constructs an empty map with default initial capacity
+     */
+    public Long2ObjectOpenConcurrentHashMap() {
+        this(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Constructs an empty map with specified initial capacity
+     *
+     * @param initialCapacity initial capacity of the map
+     */
+    public Long2ObjectOpenConcurrentHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Constructs an empty map with specified initial capacity and load factor
+     *
+     * @param initialCapacity initial capacity of the map
+     * @param loadFactor load factor for the map
+     */
+    public Long2ObjectOpenConcurrentHashMap(int initialCapacity, float loadFactor) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Initial capacity cannot be negative: " + initialCapacity);
+        }
+        if (loadFactor <= 0) {
+            throw new IllegalArgumentException("Load factor must be positive: " + loadFactor);
+        }
+        this.backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    /**
+     * Constructs a new map with the same mappings as the specified map
+     *
+     * @param map the map whose mappings are to be placed in this map
+     */
+    public Long2ObjectOpenConcurrentHashMap(Map<? extends Long, ? extends V> map) {
+        this(Math.max(DEFAULT_INITIAL_CAPACITY, map.size()));
+        putAll(Objects.requireNonNull(map, "Source map cannot be null"));
+    }
+
+    @Override
+    public V get(long key) {
+        V value = backing.get(key);
+        return (value == null && !backing.containsKey(key)) ? defaultReturnValue : value;
+    }
+
+    @Override
+    public V get(Object key) {
+        V value = backing.get(key);
+        return (value == null && !backing.containsKey(key)) ? defaultReturnValue : value;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        Objects.requireNonNull(m, "Source map cannot be null");
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        this.defaultReturnValue = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturnValue;
+    }
+
+    @Override
+    public FastEntrySet<V> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrapFast(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        V previous = backing.put(key, value);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        Objects.requireNonNull(key, "Key cannot be null");
+        return put(key.longValue(), value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V previous = backing.remove(key);
+        return (previous == null && !backing.containsKey(key)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public boolean trim() {
+        return true;
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true;
+    }
+
+    @Override
+    public boolean replace(final long k, final V oldValue, final V newValue) {
+        return backing.replace(k, oldValue, newValue);
+    }
+
+    @Override
+    public V replace(final long k, final V v) {
+        V previous = backing.replace(k, v);
+        return (previous == null && !backing.containsKey(k)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public boolean replace(final Long k, final V oldValue, final V newValue) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return replace(k.longValue(), oldValue, newValue);
+    }
+
+    @Override
+    public V replace(final Long k, final V v) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return replace(k.longValue(), v);
+    }
+
+    @Override
+    public boolean remove(final long k, final Object v) {
+        return backing.remove(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final long k, final V v) {
+        V previous = backing.putIfAbsent(k, v);
+        return (previous == null && !backing.containsKey(k)) ? defaultReturnValue : previous;
+    }
+
+    @Override
+    public V putIfAbsent(final Long k, final V v) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return putIfAbsent(k.longValue(), v);
+    }
+
+    @Override
+    public V merge(final long k, final V v, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        V newValue = backing.merge(k, v, remappingFunction);
+        return (newValue == null && !backing.containsKey(k)) ? defaultReturnValue : newValue;
+    }
+
+    @Override
+    public V merge(Long k, final V v, final BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return merge(k.longValue(), v, remappingFunction);
+    }
+
+    @Override
+    public V getOrDefault(final long k, final V defaultValue) {
+        V value = backing.get(k);
+        return (value == null && !backing.containsKey(k)) ? defaultValue : value;
+    }
+
+    @Override
+    public V getOrDefault(Object k, final V defaultValue) {
+        if (k instanceof Long key) {
+            return getOrDefault(key.longValue(), defaultValue);
+        }
+        return defaultValue;
+    }
+
+    @Override
+    public V computeIfPresent(final long k, final BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        V newValue = backing.computeIfPresent(k, remappingFunction);
+        return (newValue == null && !backing.containsKey(k)) ? defaultReturnValue : newValue;
+    }
+
+    @Override
+    public V computeIfPresent(final Long k, final BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return computeIfPresent(k.longValue(), remappingFunction);
+    }
+
+    @Override
+    public V computeIfAbsent(final long k, final LongFunction<? extends V> mappingFunction) {
+        Objects.requireNonNull(mappingFunction, "Mapping function cannot be null");
+        V newValue = backing.computeIfAbsent(k, mappingFunction::apply);
+        return (newValue == null && !backing.containsKey(k)) ? defaultReturnValue : newValue;
+    }
+
+    @Override
+    public V computeIfAbsentPartial(final long key, final Long2ObjectFunction<? extends V> mappingFunction) {
+        Objects.requireNonNull(mappingFunction, "Mapping function cannot be null");
+        if (!mappingFunction.containsKey(key)) {
+            return defaultReturnValue;
+        }
+        return computeIfAbsent(key, mappingFunction::apply);
+    }
+
+    @Override
+    public V compute(final long k, final BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(remappingFunction, "Remapping function cannot be null");
+        V newValue = backing.compute(k, remappingFunction);
+        return (newValue == null && !backing.containsKey(k)) ? defaultReturnValue : newValue;
+    }
+
+    @Override
+    public V compute(final Long k, final BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        Objects.requireNonNull(k, "Key cannot be null");
+        return compute(k.longValue(), remappingFunction);
+    }
+
+    @Override
+    public Long2ObjectOpenHashMap<V> clone() {
+        return new Long2ObjectOpenConcurrentHashMap<>(this);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return new FastUtilHackUtil.ConvertingObjectSet<>(
+            backing.entrySet(),
+            Function.identity(),
+            Function.identity()
+        );
+    }
+
+    @Override
+    public V remove(Object key) {
+        if (key instanceof Long k) {
+            return remove(k.longValue());
+        }
+        return defaultReturnValue;
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        if (key instanceof Long k) {
+            return remove(k.longValue(), value);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Map<?,?> that)) return false;
+        return backing.equals(that);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return backing.toString();
+    }
+}
