From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: satvrn <pastawho@gmail.com>
Date: Wed, 27 Sep 2023 16:29:07 -0700
Subject: [PATCH] Graphene (krypton): network.pipeline


diff --git a/src/main/java/net/minecraft/network/Varint21FrameDecoder.java b/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
index 1f71357a4caef4b2cbff95b560d0f3df268b3621..be2d2bdaef04ab1c3342b955791768777a427173 100644
--- a/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
+++ b/src/main/java/net/minecraft/network/Varint21FrameDecoder.java
@@ -1,23 +1,36 @@
 package net.minecraft.network;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
+//import io.netty.buffer.Unpooled; // Graphene - now unused
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
-import io.netty.handler.codec.CorruptedFrameException;
+//import io.netty.handler.codec.CorruptedFrameException; // Graphene - now unused
 import java.util.List;
 import javax.annotation.Nullable;
 
+// Graphene start - krypton: network.pipeline
+import me.steinborn.krypton.network.VarintByteDecoder;
+import static me.steinborn.krypton.network.util.WellKnownExceptions.BAD_LENGTH_CACHED;
+import static me.steinborn.krypton.network.util.WellKnownExceptions.VARINT_BIG_CACHED;
+// Graphene end
+
 public class Varint21FrameDecoder extends ByteToMessageDecoder {
+    // Graphene start - now unused
+    /*
     private static final int MAX_VARINT21_BYTES = 3;
     private final ByteBuf helperBuf = Unpooled.directBuffer(3);
     @Nullable
     private final BandwidthDebugMonitor monitor;
+    */
+    // Graphene end
+    private final VarintByteDecoder reader = new VarintByteDecoder(); // Graphene - krypton: network.pipeline
 
     public Varint21FrameDecoder(@Nullable BandwidthDebugMonitor packetSizeLogger) {
-        this.monitor = packetSizeLogger;
+        //this.monitor = packetSizeLogger; // Graphene - now unused
     }
 
+    // Graphene start - now unused
+    /*
     protected void handlerRemoved0(ChannelHandlerContext channelHandlerContext) {
         this.helperBuf.release();
     }
@@ -37,8 +50,12 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder {
 
         throw new CorruptedFrameException("length wider than 21-bit");
     }
+    */
+    // Graphene end
 
     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) {
+        // Graphene start - krypton: Use optimized Velocity varint decoder that reduces bounds checking
+        /*
         // Paper start - if channel is not active just discard the packet
         if (!channelHandlerContext.channel().isActive()) {
             byteBuf.skipBytes(byteBuf.readableBytes());
@@ -61,5 +78,51 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder {
                 list.add(byteBuf.readBytes(i));
             }
         }
+        */
+        // Graphene end
+
+        // Graphene start - krypton: network.pipeline
+        if (!channelHandlerContext.channel().isActive()) {
+            byteBuf.clear();
+            return;
+        }
+
+        reader.reset();
+
+        int varintEnd = byteBuf.forEachByte(reader);
+        if (varintEnd == -1) {
+            // We tried to go beyond the end of the buffer. This is probably a good sign that the
+            // buffer was too short to hold a proper varint.
+            if (reader.getResult() == VarintByteDecoder.DecodeResult.RUN_OF_ZEROES) {
+                // Special case where the entire packet is just a run of zeroes. We ignore them all.
+                byteBuf.clear();
+            }
+            return;
+        }
+
+        if (reader.getResult() == VarintByteDecoder.DecodeResult.RUN_OF_ZEROES) {
+            // this will return to the point where the next varint starts
+            byteBuf.readerIndex(varintEnd);
+        } else if (reader.getResult() == VarintByteDecoder.DecodeResult.SUCCESS) {
+            int readVarint = reader.getReadVarint();
+            int bytesRead = reader.getBytesRead();
+            if (readVarint < 0) {
+                byteBuf.clear();
+                throw BAD_LENGTH_CACHED;
+            } else if (readVarint == 0) {
+                // skip over the empty packet(s) and ignore it
+                byteBuf.readerIndex(varintEnd + 1);
+            } else {
+                int minimumRead = bytesRead + readVarint;
+                if (byteBuf.isReadable(minimumRead)) {
+                    list.add(byteBuf.retainedSlice(varintEnd + 1, readVarint));
+                    byteBuf.skipBytes(minimumRead);
+                }
+            }
+        } else if (reader.getResult() == VarintByteDecoder.DecodeResult.TOO_BIG) {
+            byteBuf.clear();
+            throw VARINT_BIG_CACHED;
+        }
+        // Graphene end
     }
 }
diff --git a/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java b/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
index 8f4a964a0863b1be834c1ea1e3d49092516f9258..b5f3f199c9bb3c1054170f9046544a6dbc75746f 100644
--- a/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
+++ b/src/main/java/net/minecraft/server/network/LegacyQueryHandler.java
@@ -24,6 +24,13 @@ public class LegacyQueryHandler extends ChannelInboundHandlerAdapter {
     public void channelRead(ChannelHandlerContext channelhandlercontext, Object object) {
         ByteBuf bytebuf = (ByteBuf) object;
 
+        // Graphene start - krypton: network.pipeline
+        if (!channelhandlercontext.channel().isActive()) {
+            bytebuf.clear();
+            return;
+        }
+        // Graphene end
+
         // Paper start - Make legacy ping handler more reliable
         if (this.buf != null) {
             try {
