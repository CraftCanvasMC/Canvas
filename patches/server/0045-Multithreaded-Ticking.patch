From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Tue, 5 Nov 2024 20:02:36 -0800
Subject: [PATCH] Multithreaded Ticking


diff --git a/src/main/java/ca/spottedleaf/moonrise/common/list/EntityList.java b/src/main/java/ca/spottedleaf/moonrise/common/list/EntityList.java
index db1112a284a8f1dd7d4072e467ae92748d2869b4..df0964b476f0fe5a4390f159af0d41a20ead9954 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/list/EntityList.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/list/EntityList.java
@@ -2,6 +2,8 @@ package ca.spottedleaf.moonrise.common.list;
 
 import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
 import net.minecraft.world.entity.Entity;
+
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -86,7 +88,7 @@ public final class EntityList implements Iterable<Entity> {
         // Canvas start
         // return this.entities[index];
         int i = 0;
-        for (Entity element : this.handle) {
+        for (Entity element : new ArrayList<>(this.handle)) { // Canvas
             if (i == index) {
                 return element;
             }
@@ -99,12 +101,7 @@ public final class EntityList implements Iterable<Entity> {
     public Entity[] getRawData() {
         // Canvas start
         // return this.entities;
-        Entity[] entityArray = new Entity[this.size()];
-        int i = 0;
-        for (Entity entity : this.handle) {
-            entityArray[i++] = entity;
-        }
-        return entityArray;
+        return this.handle.toArray(new Entity[0]); // Canvas
         // Canvas end
     }
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java b/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
index 2e876b918672e8ef3b5197b7e6b1597247fdeaa1..90017a69e72a6210e4002d02e44b3e5e10307b71 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/list/ReferenceList.java
@@ -1,6 +1,7 @@
 package ca.spottedleaf.moonrise.common.list;
 
 import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
@@ -9,50 +10,58 @@ public final class ReferenceList<E> implements Iterable<E> {
 
     private static final Object[] EMPTY_LIST = new Object[0];
 
+    private final Class<E> type;
     private final Reference2IntOpenHashMap<E> referenceToIndex;
     private E[] references;
     private int count;
 
-    public ReferenceList() {
-        this((E[])EMPTY_LIST);
+    @SuppressWarnings("unchecked")
+    public ReferenceList(Class<E> type) {
+        this(type, (E[])EMPTY_LIST);
     }
 
+    @SuppressWarnings("unchecked")
     public ReferenceList(final E[] referenceArray) {
+        this((Class<E>) referenceArray.getClass().getComponentType(), referenceArray);
+    }
+
+    @SuppressWarnings("unchecked")
+    public ReferenceList(Class<E> type, final E[] referenceArray) {
+        this.type = type;
         this.references = referenceArray;
         this.referenceToIndex = new Reference2IntOpenHashMap<>(2, 0.8f);
         this.referenceToIndex.defaultReturnValue(Integer.MIN_VALUE);
     }
 
-    private ReferenceList(final E[] references, final int count, final Reference2IntOpenHashMap<E> referenceToIndex) {
+    private ReferenceList(Class<E> type, final E[] references, final int count, final Reference2IntOpenHashMap<E> referenceToIndex) {
+        this.type = type;
         this.references = references;
         this.count = count;
         this.referenceToIndex = referenceToIndex;
     }
 
-    public ReferenceList<E> copy() {
-        return new ReferenceList<>(this.references.clone(), this.count, this.referenceToIndex.clone());
+    public synchronized ReferenceList<E> copy() {
+        return new ReferenceList<>(this.type, this.references.clone(), this.count, this.referenceToIndex.clone());
     }
 
-    public int size() {
+    public synchronized int size() {
         return this.count;
     }
 
-    public boolean contains(final E obj) {
+    public synchronized boolean contains(final E obj) {
         return this.referenceToIndex.containsKey(obj);
     }
 
-    public boolean remove(final E obj) {
+    public synchronized boolean remove(final E obj) {
         final int index = this.referenceToIndex.removeInt(obj);
         if (index == Integer.MIN_VALUE) {
             return false;
         }
 
-        // move the object at the end to this index
         final int endIndex = --this.count;
-        final E end = (E)this.references[endIndex];
+        final E end = this.references[endIndex];
         if (index != endIndex) {
-            // not empty after this call
-            this.referenceToIndex.put(end, index); // update index
+            this.referenceToIndex.put(end, index);
         }
         this.references[index] = end;
         this.references[endIndex] = null;
@@ -60,19 +69,18 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public boolean add(final E obj) {
+    public synchronized boolean add(final E obj) {
         final int count = this.count;
         final int currIndex = this.referenceToIndex.putIfAbsent(obj, count);
 
         if (currIndex != Integer.MIN_VALUE) {
-            return false; // already in this list
+            return false;
         }
 
         E[] list = this.references;
 
         if (list.length == count) {
-            // resize required
-            list = this.references = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
+            list = this.references = Arrays.copyOf(list, (int)Math.max(4L, count * 2L));
         }
 
         list[count] = obj;
@@ -81,61 +89,61 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public E getChecked(final int index) {
+    public synchronized E getChecked(final int index) {
         if (index < 0 || index >= this.count) {
             throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
         }
         return this.references[index];
     }
 
-    public E getUnchecked(final int index) {
+    public synchronized E getUnchecked(final int index) {
         return this.references[index];
     }
 
-    public Object[] getRawData() {
-        return this.references;
+    public synchronized E[] getRawData() {
+        return Arrays.copyOf(this.references, this.count);
     }
 
-    public E[] getRawDataUnchecked() {
+    public synchronized E[] getRawDataUnchecked() {
         return this.references;
     }
 
-    public void clear() {
+    @SuppressWarnings("unchecked")
+    public synchronized void clear() {
         this.referenceToIndex.clear();
-        Arrays.fill(this.references, 0, this.count, null);
+        this.references = (E[]) Array.newInstance(type, 0);
         this.count = 0;
     }
 
     @Override
-    public Iterator<E> iterator() {
+    public synchronized Iterator<E> iterator() {
         return new Iterator<>() {
-            private E lastRet;
-            private int current;
+            private int current = 0;
+            private int lastRet = -1;
 
             @Override
-            public boolean hasNext() {
-                return this.current < ReferenceList.this.count;
+            public synchronized boolean hasNext() {
+                return current < ReferenceList.this.count;
             }
 
             @Override
-            public E next() {
-                if (this.current >= ReferenceList.this.count) {
+            public synchronized E next() {
+                if (current >= ReferenceList.this.count) {
                     throw new NoSuchElementException();
                 }
-                return this.lastRet = ReferenceList.this.references[this.current++];
+                lastRet = current;
+                return ReferenceList.this.references[current++];
             }
 
             @Override
-            public void remove() {
-                final E lastRet = this.lastRet;
-
-                if (lastRet == null) {
+            public synchronized void remove() {
+                if (lastRet < 0) {
                     throw new IllegalStateException();
                 }
-                this.lastRet = null;
-
-                ReferenceList.this.remove(lastRet);
-                --this.current;
+                E element = ReferenceList.this.references[lastRet];
+                ReferenceList.this.remove(element);
+                current = lastRet;
+                lastRet = -1;
             }
         };
     }
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/misc/Delayed8WayDistancePropagator2D.java b/src/main/java/ca/spottedleaf/moonrise/common/misc/Delayed8WayDistancePropagator2D.java
index ab2fa1563d5e32a5313dfcc1da411cab45fb5ca0..5bcd4fb805218a7c260d2e40123884a73b85189b 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/misc/Delayed8WayDistancePropagator2D.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/misc/Delayed8WayDistancePropagator2D.java
@@ -561,7 +561,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        private int find(final long k) {
+        private synchronized int find(final long k) { // Canvas - synchronize
             if (k == 0L) {
                 return this.containsNullKey ? this.n : -(this.n + 1);
             } else {
@@ -585,7 +585,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        private void insert(final int pos, final long k, final byte v) {
+        private synchronized void insert(final int pos, final long k, final byte v) { // Canvas - synchronize
             if (pos == this.n) {
                 this.containsNullKey = true;
             }
@@ -598,7 +598,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        public byte putIfGreater(final long key, final byte value) {
+        public synchronized byte putIfGreater(final long key, final byte value) { // Canvas - synchronize
             final int pos = this.find(key);
             if (pos < 0) {
                 if (this.defRetValue < value) {
@@ -616,7 +616,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        private void removeEntry(final int pos) {
+        private synchronized void removeEntry(final int pos) { // Canvas - synchronize
             --this.size;
             this.shiftKeys(pos);
             if (this.n > this.minN && this.size < this.maxFill / 4 && this.n > 16) {
@@ -625,7 +625,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        private void removeNullEntry() {
+        private synchronized void removeNullEntry() { // Canvas - synchronize
             this.containsNullKey = false;
             --this.size;
             if (this.n > this.minN && this.size < this.maxFill / 4 && this.n > 16) {
@@ -634,7 +634,7 @@ public final class Delayed8WayDistancePropagator2D {
         }
 
         // copied from superclass
-        public byte removeIfGreaterOrEqual(final long key, final byte value) {
+        public synchronized byte removeIfGreaterOrEqual(final long key, final byte value) { // Canvas - synchronize
             if (key == 0L) {
                 if (!this.containsNullKey) {
                     return this.defRetValue;
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java b/src/main/java/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
index bb44de17a37082e57f2292a4f470740be1d09b11..1b215a69bddfb4e9ed935b983f2aa95ad806694d 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
@@ -15,6 +15,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.ChunkPos;
 import java.util.ArrayList;
+import net.minecraft.server.MinecraftServer;
 
 public final class NearbyPlayers {
 
@@ -61,6 +62,7 @@ public final class NearbyPlayers {
     private final ServerLevel world;
     private final Reference2ReferenceOpenHashMap<ServerPlayer, TrackedPlayer[]> players = new Reference2ReferenceOpenHashMap<>();
     private final Long2ReferenceOpenHashMap<TrackedChunk> byChunk = new Long2ReferenceOpenHashMap<>();
+    private static final ReferenceList<ServerPlayer> emptyList = new ReferenceList<>(new ServerPlayer[0]); // Canvas
     private final Long2ReferenceOpenHashMap<ReferenceList<ServerPlayer>>[] directByChunk = new Long2ReferenceOpenHashMap[TOTAL_MAP_TYPES];
     {
         for (int i = 0; i < this.directByChunk.length; ++i) {
@@ -113,7 +115,7 @@ public final class NearbyPlayers {
     public void tickPlayer(final ServerPlayer player) {
         final TrackedPlayer[] players = this.players.get(player);
         if (players == null) {
-            throw new IllegalStateException("Don't have player " + player);
+            return; // throw new IllegalStateException("Don't have player " + player); // Canvas
         }
 
         final ChunkPos chunk = player.chunkPosition();
@@ -139,18 +141,22 @@ public final class NearbyPlayers {
     }
 
     public ReferenceList<ServerPlayer> getPlayers(final BlockPos pos, final NearbyMapType type) {
+        if (MinecraftServer.getServer().getPlayerList().hasPlayers) return emptyList; // Canvas - if there are no players dont waste time checking
         return this.directByChunk[type.ordinal()].get(CoordinateUtils.getChunkKey(pos));
     }
 
     public ReferenceList<ServerPlayer> getPlayers(final ChunkPos pos, final NearbyMapType type) {
+        if (MinecraftServer.getServer().getPlayerList().hasPlayers) return emptyList; // Canvas - if there are no players dont waste time checking
         return this.directByChunk[type.ordinal()].get(CoordinateUtils.getChunkKey(pos));
     }
 
     public ReferenceList<ServerPlayer> getPlayersByChunk(final int chunkX, final int chunkZ, final NearbyMapType type) {
+        if (MinecraftServer.getServer().getPlayerList().hasPlayers) return emptyList; // Canvas - if there are no players dont waste time checking
         return this.directByChunk[type.ordinal()].get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
     }
 
     public ReferenceList<ServerPlayer> getPlayersByBlock(final int blockX, final int blockZ, final NearbyMapType type) {
+        if (MinecraftServer.getServer().getPlayerList().hasPlayers) return emptyList; // Canvas - if there are no players dont waste time checking
         return this.directByChunk[type.ordinal()].get(CoordinateUtils.getChunkKey(blockX >> 4, blockZ >> 4));
     }
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 217d1f908a36a5177ba3cbb80a33f73d4dab0fa0..ab8396c26c31b3120aec98073b187c0aa2d2ee5d 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -41,6 +41,7 @@ public class TickThread extends Thread {
     }
 
     public static void ensureTickThread(final Level world, final int chunkX, final int chunkZ, final String reason) {
+        if (currentThread().isVirtual()) return; // Canvas
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
             LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
@@ -94,6 +95,7 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
+        if (Thread.currentThread().isVirtual()) return true; // Canvas - ignore virtual threads
         return Thread.currentThread() instanceof TickThread;
     }
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index 93335de8cf514dc8417e4b9b2d495663deda2904..d987b780fe84a8fcf0a2299c8057d038dcdb504a 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -8,6 +8,7 @@ import ca.spottedleaf.moonrise.common.util.WorldUtil;
 import ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -30,6 +31,7 @@ import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -190,6 +192,12 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             return Arrays.copyOf(this.accessibleEntities.getRawData(), this.accessibleEntities.size(), Entity[].class);
         }
     }
+    // Canvas start
+
+    public int entityCount() {
+        return this.accessibleEntities.size();
+    }
+    // Canvas end
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AbortableIterationConsumer<U> action) {
@@ -226,6 +234,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             }
         }
     }
+    private ConcurrentLinkedQueue<Runnable> statusChangesQue = new ConcurrentLinkedQueue<>(); // Canvas
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
@@ -233,14 +242,15 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
         if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
             // recursive status update
-            LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
+            // LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable()); // Canvas - silence.
             return;
         }
 
         final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
 
         if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            // LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable()); // Canvas
+            statusChangesQue.add(() -> entityStatusChange(entity, slices, oldVisibility, newVisibility, moved, created, destroyed)); // Canvas
             return;
         }
 
@@ -322,6 +332,11 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         } finally {
             if (slices != null) {
                 slices.stopPreventingStatusUpdates(false);
+                // Canvas start
+                ConcurrentLinkedQueue<Runnable> clone = new ConcurrentLinkedQueue<>(statusChangesQue);
+                statusChangesQue.clear();
+                clone.forEach(Runnable::run);
+                // Canvas end
             }
         }
     }
@@ -474,7 +489,13 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
         } else {
             if (slices.isPreventingStatusUpdates()) {
-                throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas start
+               ((ServerLevel)entity.level()).concurrentChunkTaskScheduler.schedule(() -> {
+                    removeEntity(entity);
+                });
+                return;
+                // throw new IllegalStateException("Attempting to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ") that is receiving status updates");
+                // Canvas end
             }
             if (!slices.removeEntity(entity, sectionY)) {
                 LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
@@ -510,7 +531,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         }
     }
 
-    protected ChunkEntitySlices moveEntity(final Entity entity) {
+    protected synchronized ChunkEntitySlices moveEntity(final Entity entity) { // Canvas
         // ensure we own the entity
         this.checkThread(entity, "Cannot move entity off-main");
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index 5a6defc4c4d30c06d4bba856847feb176950ca1e..77c680e33963853936aa5096766bb8584546d652 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -20,6 +20,8 @@ import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongComparator;
 import it.unimi.dsi.fastutil.longs.LongHeapPriorityQueue;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import io.github.dueris.canvas.thread.TickTaskHolder;
+import io.github.dueris.canvas.thread.exception.AlreadySentChunkException;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
@@ -38,6 +40,11 @@ import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
@@ -308,8 +315,13 @@ public final class RegionizedPlayerChunkLoader {
                 // not our problem anymore
                 continue;
             }
-            loader.update(); // can't invoke plugin logic
-            loader.updateQueues(currTime);
+
+            try {
+                synchronized (this) {
+                    loader.update(); // can't invoke plugin logic
+                    loader.updateQueues(currTime);
+                }
+            } catch (AlreadySentChunkException ignored) {}
         }
     }
 
@@ -339,7 +351,7 @@ public final class RegionizedPlayerChunkLoader {
 
         private boolean canGenerateChunks = true;
 
-        private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
+        private final ConcurrentLinkedDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ConcurrentLinkedDeque<>(); // Canvas
         private final LongOpenHashSet sentChunks = new LongOpenHashSet();
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
@@ -420,7 +432,7 @@ public final class RegionizedPlayerChunkLoader {
                 PlayerChunkSender.sendChunk(this.player.connection, this.world, chunk);
                 return;
             }
-            throw new IllegalStateException();
+            throw new AlreadySentChunkException();
         }
 
         private void sendUnloadChunk(final int chunkX, final int chunkZ) {
@@ -819,7 +831,12 @@ public final class RegionizedPlayerChunkLoader {
             final int maxSendsThisTick = Math.min((int)this.chunkSendLimiter.takeAllocation(time, sendRate, maxSends), this.sendQueue.size());
             // we do not return sends that we took from the allocation back because we want to limit the max send rate, not target it
             for (int i = 0; i < maxSendsThisTick; ++i) {
-                final long pendingSend = this.sendQueue.firstLong();
+                final long pendingSend;
+                try {
+                    pendingSend = this.sendQueue.firstLong();
+                } catch (NoSuchElementException e) {
+                    break;
+                }
                 final int pendingSendX = CoordinateUtils.getChunkX(pendingSend);
                 final int pendingSendZ = CoordinateUtils.getChunkZ(pendingSend);
                 final LevelChunk chunk = ((ChunkSystemLevel)this.world).moonrise$getFullChunkIfLoaded(pendingSendX, pendingSendZ);
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index a0e5fc2eff605e17704f0726d20e79cbb3d88d6d..27e3195f0fdbdf99e7f91dda94c1ed7cb5a8696e 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -51,6 +51,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.PrimitiveIterator;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -81,27 +82,8 @@ public final class ChunkHolderManager {
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
-        if (c1 == c2) {
-            return 0;
-        }
-
-        final int saveTickCompare = Long.compare(c1.lastAutoSave, c2.lastAutoSave);
-
-        if (saveTickCompare != 0) {
-            return saveTickCompare;
-        }
-
-        final long coord1 = CoordinateUtils.getChunkKey(c1.chunkX, c1.chunkZ);
-        final long coord2 = CoordinateUtils.getChunkKey(c2.chunkX, c2.chunkZ);
-
-        if (coord1 == coord2) {
-            throw new IllegalStateException("Duplicate chunkholder in auto save queue");
-        }
-
-        return Long.compare(coord1, coord2);
-    });
+    private final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>(); // Canvas
+    private final ConcurrentLinkedDeque<NewChunkHolder> autoSaveQueue = new ConcurrentLinkedDeque<>();
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -234,7 +216,7 @@ public final class ChunkHolderManager {
         final long maxSaveTime = currentTick - Math.max(1L, PlatformHooks.get().configAutoSaveInterval(this.world));
         final int maxToSave = PlatformHooks.get().configMaxAutoSavePerTick(this.world);
         for (int autoSaved = 0; autoSaved < maxToSave && !this.autoSaveQueue.isEmpty();) {
-            final NewChunkHolder holder = this.autoSaveQueue.first();
+            final NewChunkHolder holder = this.autoSaveQueue.getFirst(); // Canvas
 
             if (holder.lastAutoSave > maxSaveTime) {
                 break;
@@ -1032,7 +1014,7 @@ public final class ChunkHolderManager {
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate; // Canvas
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -1040,7 +1022,7 @@ public final class ChunkHolderManager {
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1380,7 +1362,7 @@ public final class ChunkHolderManager {
 
     // only call on tick thread
     private boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final ConcurrentLinkedDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate; // Canvas
 
         boolean ret = false;
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
index f3c453773e0413276935ca653b60bbe64fa4b169..c581876f818e9c5f3987ebafee8f40d49b7402e2 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
@@ -25,6 +25,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.status.ChunkSystemChunkStep;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
+import java.util.concurrent.LinkedBlockingDeque;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -877,7 +878,7 @@ public final class ChunkTaskScheduler {
         return true;
     }
 
-    public static final ArrayDeque<ChunkInfo> WAITING_CHUNKS = new ArrayDeque<>(); // stack
+    public static final LinkedBlockingDeque<ChunkInfo> WAITING_CHUNKS = new LinkedBlockingDeque<>(); // stack // Canvas
 
     public static final class ChunkInfo {
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
index 310a8f80debadd64c2d962ebf83b7d0505ce6e42..e853fa9995751343835800cba29a0f92befe0a19 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
@@ -16,6 +16,8 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.locks.LockSupport;
 
 public abstract class ThreadedTicketLevelPropagator {
@@ -752,7 +754,7 @@ public abstract class ThreadedTicketLevelPropagator {
 
     private static final class Propagator {
 
-        private static final ArrayDeque<Propagator> CACHED_PROPAGATORS = new ArrayDeque<>();
+        private static final ConcurrentLinkedDeque<Propagator> CACHED_PROPAGATORS = new ConcurrentLinkedDeque<>(); // Canvas
         private static final int MAX_PROPAGATORS = Runtime.getRuntime().availableProcessors() * 2;
 
         private static Propagator acquirePropagator() {
diff --git a/src/main/java/com/destroystokyo/paper/entity/ai/MobGoalHelper.java b/src/main/java/com/destroystokyo/paper/entity/ai/MobGoalHelper.java
index c8651af322927c46d075f88890fcd0476bd85440..5906c652154c0cd5fb8cb1bc81458c3a7a2c7fe5 100644
--- a/src/main/java/com/destroystokyo/paper/entity/ai/MobGoalHelper.java
+++ b/src/main/java/com/destroystokyo/paper/entity/ai/MobGoalHelper.java
@@ -10,6 +10,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import net.minecraft.world.entity.FlyingMob;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.entity.TamableAnimal;
@@ -128,8 +129,8 @@ import org.bukkit.entity.ZombieVillager;
 public class MobGoalHelper {
 
     private static final BiMap<String, String> deobfuscationMap = HashBiMap.create();
-    private static final Map<Class<? extends Goal>, Class<? extends Mob>> entityClassCache = new HashMap<>();
-    private static final Map<Class<? extends net.minecraft.world.entity.Mob>, Class<? extends Mob>> bukkitMap = new HashMap<>();
+    private static final Map<Class<? extends Goal>, Class<? extends Mob>> entityClassCache = new ConcurrentHashMap<>(); // Canvas
+    private static final Map<Class<? extends net.minecraft.world.entity.Mob>, Class<? extends Mob>> bukkitMap = new ConcurrentHashMap<>(); // Canvas
 
     static final Set<String> ignored = new HashSet<>();
 
diff --git a/src/main/java/io/github/dueris/canvas/CanvasConfig.java b/src/main/java/io/github/dueris/canvas/CanvasConfig.java
index 76920a64ecc5fba2ea480e00dcb9fc1e7982f639..f940c3f9245c9a9773150b0df07a147f37b81d4f 100644
--- a/src/main/java/io/github/dueris/canvas/CanvasConfig.java
+++ b/src/main/java/io/github/dueris/canvas/CanvasConfig.java
@@ -3,6 +3,7 @@ package io.github.dueris.canvas;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.command.CanvasCommand;
 import net.kyori.adventure.bossbar.BossBar;
 import net.kyori.adventure.text.minimessage.MiniMessage;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -52,7 +53,7 @@ public class CanvasConfig {
     private static File CONFIG_FILE;
     public static YamlConfiguration config;
 
-    private static Map<String, Command> commands;
+    private static Map<String, Command> commands = new HashMap<>();
 
     public static int version;
     static boolean verbose;
@@ -70,6 +71,8 @@ public class CanvasConfig {
         config.options().header(HEADER);
         config.options().copyDefaults(true);
 
+        commands.put("canvas", new CanvasCommand("canvas"));
+
         version = getInt("config-version", 33);
         set("config-version", 33);
 
@@ -207,6 +210,14 @@ public class CanvasConfig {
     public static boolean useCanvasOrbOptimizations = true;
     public static double orbMergeSearchInfaltionRadius = 0.5;
     public static int maxEntitiesToReducePathfindingRates = 2;
+    public static boolean spectatorsSpawnMobs = false;
+    public static int asyncEntityTrackerThreadCount = 1;
+
+    public static boolean disableFeatures = false;
+
+    private static void chunkGen() {
+        disableFeatures = getBoolean("chunkgen.disablefeatures", disableFeatures);
+    }
 
     private static void general(){
         disableFootsteps = getBoolean("disableFootsteps", disableFootsteps);
@@ -217,6 +228,7 @@ public class CanvasConfig {
         useCanvasOrbOptimizations = getBoolean("useCanvasOrbOptimizations", useCanvasOrbOptimizations);
         orbMergeSearchInfaltionRadius = getDouble("orbMergeSearchInfaltionRadius", orbMergeSearchInfaltionRadius);
         maxEntitiesToReducePathfindingRates = getInt("maxEntitiesToReducePathfindingRates", maxEntitiesToReducePathfindingRates);
+        spectatorsSpawnMobs = getBoolean("spectatorsCanSpawnNaturalMobs", spectatorsSpawnMobs);
     }
 
     private static void optimizations(){
@@ -250,6 +262,7 @@ public class CanvasConfig {
         playerInstaAbsorbOrbs = getBoolean("playerInstaAbsorbOrbs", playerInstaAbsorbOrbs);
         useCanvasOrbOptimizations = getBoolean("useCanvasOrbOptimizations", useCanvasOrbOptimizations);
         orbMergeSearchInfaltionRadius = getDouble("orbMergeSearchInfaltionRadius", orbMergeSearchInfaltionRadius);
+        asyncEntityTrackerThreadCount = getInt("asyncEntityTrackerThreadCount", asyncEntityTrackerThreadCount);
     }
     
     private static void blocks(){
diff --git a/src/main/java/io/github/dueris/canvas/command/CanvasCommand.java b/src/main/java/io/github/dueris/canvas/command/CanvasCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f111e6352add0b35f9c5fa492bf3e7b2deb171d
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/command/CanvasCommand.java
@@ -0,0 +1,201 @@
+package io.github.dueris.canvas.command;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+import java.text.DecimalFormat;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import ca.spottedleaf.moonrise.common.util.MoonriseCommon;
+import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.CanvasConfig;
+import io.github.dueris.canvas.world.TickManagerHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.SpigotConfig;
+
+import static io.papermc.paper.command.MSPTCommand.getColor;
+import static java.lang.String.valueOf;
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.TextColor.color;
+
+public class CanvasCommand extends Command {
+    static int HEADER = 0x5FC3DD;
+    static int VALUE = 0x96D6F0;
+    public CanvasCommand(String name) {
+        super(name);
+        this.description = "Canvas related commands";
+        this.usageMessage = "/canvas [tps | version]";
+        this.setPermission("bukkit.command.canvas");
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("tps", "version", "connection")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        CraftServer server = (CraftServer) sender.getServer();
+        List<Pair<ServerTickRateManager, Float>> tpsValues = server.getServer().getAllTickRateManagers()
+            .stream().map(ServerTickRateManager::toTpsPair).toList();
+
+        Pair<ServerTickRateManager, Float> minMSPT = tpsValues.stream()
+            .min(Comparator.comparing(Pair::getSecond))
+            .orElseThrow(() -> new RuntimeException("List is empty"));
+        Pair<ServerTickRateManager, Float> maxMSPT = tpsValues.stream()
+            .max(Comparator.comparing(Pair::getSecond))
+            .orElseThrow(() -> new RuntimeException("List is empty"));
+
+        float median = (minMSPT.getSecond() + maxMSPT.getSecond()) / 2;
+        float min = minMSPT.getSecond();
+        float max = maxMSPT.getSecond();
+
+        if (args.length < 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("tps")) {
+            TextComponent base = text("").color(color(0x4EA2ED));
+            TextComponent header = text("==================================")
+                .color(color(0x2F8FE9));
+
+            sender.sendMessage(header);
+            sender.sendMessage(base.append(text("Server Status Report").color(color(HEADER))));
+
+            sendReportLine(sender, " Online Players: ", valueOf(server.getOnlinePlayers().size()), 0x4EA2ED, 0x2F8FE9);
+            sendReportLine(sender, " Running TickHolders: ", valueOf(server.getServer().getAllTickRateManagers().size()), 0x4EA2ED, 0x2F8FE9);
+            sendReportLine(sender, " Lowest TickHolder TPS: ", createColoredComponent(simplifyNumber(min).toString(), min, 20F), 0x4EA2ED);
+            sendReportLine(sender, " Median TickHolder TPS: ", createColoredComponent(simplifyNumber(median).toString(), median, 20F), 0x4EA2ED);
+            sendReportLine(sender, " Highest TickHolder TPS: ", createColoredComponent(simplifyNumber(max).toString(), max, 20F), 0x4EA2ED);
+
+            sender.sendMessage(header);
+
+            sender.sendMessage(base.append(text(" Thread Analysis").color(color(HEADER))));
+            sendReportLine(sender, " MAX Available threads: ", valueOf(Runtime.getRuntime().availableProcessors()), 0x4EA2ED, 0x2F8FE9);
+            sendReportLine(sender, " Current Available threads: ", valueOf(Runtime.getRuntime().availableProcessors() - usingThreads()), 0x4EA2ED, 0x2F8FE9);
+
+            sender.sendMessage(base.append(text(" Util ThreadCount:").color(color(0x4EA2ED))));
+            sendSubReportLine(sender, "Async Pathfinding: ", valueOf(CanvasConfig.asyncPathfindingMaxThreads), 0x2F8FE9, VALUE);
+            sendSubReportLine(sender, "EntityTracking: ", valueOf(CanvasConfig.asyncEntityTrackerThreadCount), 0x2F8FE9, VALUE);
+            sendSubReportLine(sender, "NettyIO: ", valueOf(SpigotConfig.getInt("settings.netty-threads", 4)), 0x2F8FE9, VALUE);
+            sendSubReportLine(sender, "Moonrise Workers: ", valueOf(MoonriseCommon.WORKER_THREADS), 0x2F8FE9, VALUE);
+
+            sender.sendMessage(header);
+
+            boolean reverse = args.length >= 2 && args[1].equalsIgnoreCase("true");
+            sender.sendMessage(base.append(text("Detailed Status Report ").color(color(HEADER))
+                .append(text(reverse ? "(Lowest 3)" : "(Highest 3)").color(color(VALUE)))));
+
+            List<Pair<ServerTickRateManager, Long>> pairs = server.getServer().getAllTickRateManagers()
+                .stream().map(ServerTickRateManager::toNanoPair)
+                .sorted(Comparator.comparing((Function<? super Pair<ServerTickRateManager, Long>, ? extends Long>) Pair::getSecond, reverse ? Comparator.reverseOrder() : Comparator.naturalOrder()))
+                .limit(3).toList();
+
+            for (Pair<ServerTickRateManager, Long> pair : pairs) {
+                TickManagerHolder ticker = pair.getFirst().getHolder();
+                int chunkCount = ticker instanceof ServerLevel level ? level.getChunkSource().getLoadedChunksCount() : 0;
+                int playerCount = ticker instanceof ServerLevel level ? level.players().size() : 0;
+                int entityCount = ticker instanceof ServerLevel level ? level.moonrise$getEntityLookup().entityCount() : 0;
+
+                sender.sendMessage(base.append(text(" - TickLoopThread Level [")
+                    .append(text(ticker.getHolderName()).color(color(0x96D6F0)))
+                    .append(text("]").color(color(0x4EA2ED)))));
+
+                sender.sendMessage(base.append(Component.text("   ")).append(getColor((double) ticker.getNanoSecondsFromLastTick() / 1_000_000)
+                    .append(text(" MSPT at "))
+                    .append(createColoredComponent(simplifyNumber(ticker.getTps()).toString(), ticker.getTps(), 20F))
+                    .append(text(" TPS"))));
+
+                float threadUtil = (float) (((ticker.getNanoSecondsFromLastTick() / 1_000_000.0) / 50) * 100);
+                if (threadUtil > 100) threadUtil = 100;
+
+                sender.sendMessage(base.append(text("   Chunks: ")
+                    .append(text(valueOf(chunkCount)).color(color(VALUE)))
+                    .append(text(" Players: ").append(text(valueOf(playerCount)).color(color(VALUE))))
+                    .append(text(" Entities: ").append(text(valueOf(entityCount)).color(color(VALUE))))
+                    .append(text(" Thread Utilization: ").append(createColoredUtilComponent(simplifyNumber(threadUtil) + "%", threadUtil)))));
+            }
+
+            sender.sendMessage(header);
+
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
+            if (verCmd != null) {
+                return verCmd.execute(sender, commandLabel, new String[0]);
+            }
+        } else if (args[0].equalsIgnoreCase("connection")) {
+            if (sender instanceof Player player) {
+                ServerPlayer p = ((CraftPlayer) player).getHandle();
+                sender.sendMessage(text("Currently running on connection-thread: " + (p.connection.connection.handledOnMain ? "MainThread" : p.connection.connection.getHandlerThreadName())));
+            }
+        }
+
+        return true;
+    }
+
+    private void sendReportLine(@NotNull CommandSender sender, String label, String value, int labelColor, int valueColor) {
+        sender.sendMessage(text(label).color(color(labelColor))
+            .append(text(value).color(color(valueColor))));
+    }
+
+    private void sendReportLine(@NotNull CommandSender sender, String label, Component value, int labelColor) {
+        sender.sendMessage(text(label).color(color(labelColor)).append(value));
+    }
+
+    private void sendSubReportLine(@NotNull CommandSender sender, String label, String value, int labelColor, int valueColor) {
+        sender.sendMessage(text("   " + label).color(color(labelColor))
+            .append(text(value).color(color(valueColor))));
+    }
+
+    public int usingThreads() {
+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
+        return (int) java.util.Arrays.stream(threadMXBean.getAllThreadIds())
+            .mapToObj(threadMXBean::getThreadInfo)
+            .filter(threadInfo -> threadInfo != null && threadInfo.getThreadState() == Thread.State.RUNNABLE)
+            .count();
+    }
+
+    public Component createColoredUtilComponent(String text, float value) {
+        float ratio = Math.max(0, Math.min(100, value)) / 100.0f;
+        int red = (ratio <= 0.5) ? (int) (ratio * 510) : 255;
+        int green = (ratio <= 0.5) ? 255 : (int) ((1.0f - ratio) * 510);
+
+        return text(text).color(color(red, green, 0));
+    }
+
+    public Component createColoredComponent(String text, float value, float outOf) {
+        float ratio = Math.max(0, Math.min(outOf, value)) / outOf;
+        int red = (int) ((1 - ratio) * 255);
+        int green = (int) (ratio * 255);
+
+        return text(text).color(color(red, green, 0));
+    }
+
+    public static @NotNull Double simplifyNumber(@NotNull Float num) {
+        DecimalFormat df = new DecimalFormat("###.##");
+        return Double.parseDouble(df.format(num.doubleValue()));
+    }
+
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/NamedTickThreadFactory.java b/src/main/java/io/github/dueris/canvas/thread/NamedTickThreadFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..f14cf4855ff799ce01ef56e5aa52da640c24b148
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/NamedTickThreadFactory.java
@@ -0,0 +1,63 @@
+package io.github.dueris.canvas.thread;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import com.mojang.logging.LogUtils;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.slf4j.Logger;
+
+public class NamedTickThreadFactory implements ThreadFactory { // Extends the functionality of the NamedThreadFactory by vanilla
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private final ThreadGroup group;
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String namePrefix;
+    private final int priority;
+    private final boolean daemon;
+
+    public NamedTickThreadFactory(String name) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = 5;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName, boolean daemon) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = daemon;
+    }
+
+    @Override
+    public Thread newThread(Runnable runnable) {
+        TickThread thread = new TickThread(runnable, namePrefix + this.threadNumber.getAndIncrement());
+        thread.setDaemon(daemon);
+        thread.setUncaughtExceptionHandler((threadx, throwable) -> {
+            LOGGER.error("Caught exception in thread {} from {}", threadx, runnable);
+            LOGGER.error("", throwable);
+        });
+        if (thread.getPriority() != priority) {
+            thread.setPriority(priority);
+        }
+
+        return thread;
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/ScheduledTask.java b/src/main/java/io/github/dueris/canvas/thread/ScheduledTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c55918afeb85346468bd8782d3af9f8ecfd4ce9
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/ScheduledTask.java
@@ -0,0 +1,25 @@
+package io.github.dueris.canvas.thread;
+
+public class ScheduledTask {
+    Runnable runnable;
+    boolean onMain;
+    TickTaskHolder.Timing timing;
+
+    public ScheduledTask(Runnable runnable, boolean onMain, TickTaskHolder.Timing timing) {
+        this.runnable = runnable;
+        this.onMain = onMain;
+        this.timing = timing;
+    }
+
+    public boolean canRun(TickTaskHolder.Timing timing) {
+        return this.timing == timing;
+    }
+
+    public boolean serverLevel() {
+        return !this.onMain;
+    }
+
+    public void run() {
+        this.runnable.run();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/TickLoopThread.java b/src/main/java/io/github/dueris/canvas/thread/TickLoopThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b1c701538b457d34aabe6bdd9418ef8782352a5
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/TickLoopThread.java
@@ -0,0 +1,242 @@
+package io.github.dueris.canvas.thread;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import io.github.dueris.canvas.thread.chunk.ConcurrentChunkTaskScheduler;
+import io.github.dueris.canvas.util.WrappedConcurrentLockSet;
+import io.github.dueris.canvas.world.TickManagerHolder;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+import java.util.concurrent.CountDownLatch;
+import java.util.function.BooleanSupplier;
+import net.minecraft.Util;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.Connection;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.ServerTickRateManager;
+import net.minecraft.server.TickTask;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.util.debugchart.DebugSampleSubscriptionTracker;
+import net.minecraft.util.debugchart.RemoteDebugSampleType;
+import net.minecraft.util.debugchart.RemoteSampleLogger;
+import net.minecraft.util.debugchart.SampleLogger;
+import net.minecraft.util.debugchart.TpsDebugDimensions;
+import net.minecraft.util.thread.ReentrantBlockableEventLoop;
+import net.minecraft.world.TickRateManager;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.command.defaults.ReloadCommand;
+import org.jetbrains.annotations.NotNull;
+import org.purpurmc.purpur.PurpurConfig;
+
+public abstract class TickLoopThread extends TickThread implements TickTaskHolder, TickManagerHolder {
+    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal("1E9").multiply(new java.math.BigDecimal(MinecraftServer.SAMPLE_INTERVAL));
+    public final CountDownLatch latch = new CountDownLatch(1);
+    public final Double[] recentTps = new Double[1];
+    public final MinecraftServer.RollingAverage tps5s = new MinecraftServer.RollingAverage(5);
+    private final Logger LOGGER = LogManager.getLogger("TickLoopThread-" + getName());
+    private final MinecraftServer server;
+    public ServerTickRateManager tickRateManager;
+    public volatile boolean running = false;
+    public int tickCount = 0;
+    public int currentTick;
+    public long currentTickLong;
+    public boolean lagging = false;
+    public Long lastNanoTickTime = 0L;
+    public long currentTime;
+    public ConcurrentChunkTaskScheduler concurrentChunkTaskScheduler = new ConcurrentChunkTaskScheduler();
+    public WrappedConcurrentLockSet<Connection> connections;
+    public long milliSinceLastConnectionTick = 0;
+    private long nextTickTimeNanos;
+    private long lastOverloadWarningNanos;
+    private long taskExecutionStartNanos;
+    private long idleTimeNanos;
+    private long delayedTasksMaxNextTickTimeNanos;
+    private boolean mayHaveDelayedTasks;
+    private EventLoop eventLoop;
+    private net.minecraft.util.debugchart.SampleLogger tickTimeLogger;
+
+    public TickLoopThread(final String name, final MinecraftServer server) {
+        super(name);
+        this.server = server;
+        this.tickRateManager = new ServerTickRateManager(this);
+        this.connections = new WrappedConcurrentLockSet<>();
+    }
+
+    public abstract void endLoop();
+
+    public abstract void tickThread(BooleanSupplier shouldKeepTicking, int tickCount);
+
+    public abstract void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state);
+
+    @Override
+    public void run() {
+        long tickSection = Util.getNanos();
+        this.running = true;
+        this.eventLoop = new EventLoop(this);
+        DebugSampleSubscriptionTracker debugSampleSubscriptionTracker = new DebugSampleSubscriptionTracker(this.server.getPlayerList());
+        this.tickTimeLogger = new RemoteSampleLogger(TpsDebugDimensions.values().length, debugSampleSubscriptionTracker, RemoteDebugSampleType.TICK_TIME);
+        while (this.running) {
+            try {
+                long tickDuration;
+                currentTime = Util.getNanos();
+                if (ReloadCommand.isReloading) continue; // Dont tick worlds during reload
+                if (!server.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
+                    tickDuration = 0L;
+                    this.nextTickTimeNanos = Util.getNanos();
+                    this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                } else {
+                    tickDuration = this.tickRateManager.nanosecondsPerTick();
+                    long elapsedTime = Util.getNanos() - this.nextTickTimeNanos;
+
+                    if (elapsedTime > 20 + 20L * tickDuration && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= MinecraftServer.OVERLOADED_WARNING_INTERVAL_NANOS + 100L * tickDuration) {
+                        long ticksBehind = elapsedTime / tickDuration;
+
+                        if (server.server.getWarnOnOverload() && tickCount > 300)
+                            LOGGER.warn("Can't keep up! Is the thread overloaded? Running {}ms or {} ticks behind. TickLoopThread identifier: {}"
+                                , elapsedTime / TimeUtil.NANOSECONDS_PER_MILLISECOND, ticksBehind, getName());
+                        this.nextTickTimeNanos += ticksBehind * tickDuration;
+                        this.lastOverloadWarningNanos = this.nextTickTimeNanos;
+                    }
+                }
+                ++this.currentTickLong;
+                currentTime = Util.getNanos();
+                if (++this.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+                    final long diff = currentTime - tickSection;
+                    final BigDecimal currentTps = TPS_BASE.divide(new BigDecimal(diff), 30, RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff);
+
+                    this.recentTps[0] = tps5s.getAverage();
+                    lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold;
+                    tickSection = currentTime;
+                }
+                this.nextTickTimeNanos += tickDuration;
+
+                BooleanSupplier supplier = tickDuration == 0L ? () -> {
+                    return false;
+                } : this::haveTime;
+                long i = Util.getNanos();
+                this.tickThread(supplier, ++tickCount);
+                this.lastNanoTickTime = Util.getNanos() - i;
+                this.mayHaveDelayedTasks = true;
+                this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + tickDuration, this.nextTickTimeNanos);
+                if (!PurpurConfig.tpsCatchup || this.tickRateManager.isUnlockedTickRate()) {
+                    this.nextTickTimeNanos = currentTime + nextTickTimeNanos;
+                    this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                }
+                this.startMeasuringTaskExecutionTime();
+                this.waitUntilNextTick();
+                this.finishMeasuringTaskExecutionTime();
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+        latch.countDown();
+    }
+
+    @Override
+    public void start() {
+        super.start();
+    }
+
+    private void startMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            this.taskExecutionStartNanos = Util.getNanos();
+            this.idleTimeNanos = 0L;
+        }
+
+    }
+
+    private void finishMeasuringTaskExecutionTime() {
+        if (server.isTickTimeLoggingEnabled()) {
+            SampleLogger samplelogger = this.tickTimeLogger;
+
+            samplelogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            samplelogger.logPartialSample(this.idleTimeNanos, TpsDebugDimensions.IDLE.ordinal());
+        }
+
+    }
+
+    public void waitUntilNextTick() {
+        if (this.tickRateManager.isUnlockedTickRate()) return;
+        eventLoop.managedBlock(() -> !(server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < this.nextTickTimeNanos));
+    }
+
+    public boolean haveTime() {
+        if (server.forceTicks) {
+            return true;
+        }
+        if (server.isOversleep)
+            return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
+        return server.forceTicks || eventLoop.getRunningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+    }
+
+    @Override
+    public String getHolderName() {
+        return getName();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public TickRateManager getManager() {
+        return tickRateManager;
+    }
+
+    @Override
+    public void onTickRateChanged() {
+        server.onTickRateChanged();
+    }
+
+    @Override
+    public PlayerList getPlayerList() {
+        return null;
+    }
+
+    @Override
+    public CommandSourceStack createCommandSourceStack() {
+        return server.createCommandSourceStack();
+    }
+
+    protected static class EventLoop extends ReentrantBlockableEventLoop<TickTask> {
+        private final TickLoopThread server;
+
+        public EventLoop(@NotNull TickLoopThread server) {
+            super("TickLoopThread-" + server.getName());
+            this.server = server;
+        }
+
+        @Override
+        protected @NotNull TickTask wrapRunnable(@NotNull Runnable runnable) {
+            if (server.server.hasStopped && Thread.currentThread().equals(server.server.shutdownThread)) {
+                runnable.run();
+                runnable = () -> {
+                };
+            }
+            return new TickTask(server.tickCount, runnable);
+        }
+
+        @Override
+        protected boolean shouldRun(@NotNull TickTask ticktask) {
+            return ticktask.getTick() + 3 < server.tickCount || server.server.haveTime();
+        }
+
+        @Override
+        protected @NotNull Thread getRunningThread() {
+            return Thread.currentThread();
+        }
+
+        public boolean getRunningTask() {
+            return this.runningTask();
+        }
+
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/TickTaskHolder.java b/src/main/java/io/github/dueris/canvas/thread/TickTaskHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..402289e16d3ebaa7b7895363881bdcc63bd14a32
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/TickTaskHolder.java
@@ -0,0 +1,13 @@
+package io.github.dueris.canvas.thread;
+
+public interface TickTaskHolder {
+    void scheduleTickTask(Runnable runnable, Timing timing, State state);
+
+    enum Timing {
+        END_TICK, PRE_TICK, PRE_ENTITY, POST_ENTITY
+    }
+
+    enum State {
+        SERVER_LEVEL, MAIN
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/WorldTickThread.java b/src/main/java/io/github/dueris/canvas/thread/WorldTickThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..b090e0d515f0f4dd22984c1f57307c15a9787d15
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/WorldTickThread.java
@@ -0,0 +1,26 @@
+package io.github.dueris.canvas.thread;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+
+public abstract class WorldTickThread extends TickThread implements TickTaskHolder {
+
+    public WorldTickThread(final String name) {
+        super(name);
+    }
+
+    public abstract void stopWorld();
+
+    public abstract void runWorld();
+
+    public abstract void scheduleTickTask(Runnable runnable, Timing timing, TickTaskHolder.State state);
+
+    @Override
+    public void run() {
+        this.runWorld();
+    }
+
+    @Override
+    public void start() {
+        super.start();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/chunk/ConcurrentChunkTaskScheduler.java b/src/main/java/io/github/dueris/canvas/thread/chunk/ConcurrentChunkTaskScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..7235c37301c6c1cbd48804fd0d4e7a8b9c02aac9
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/chunk/ConcurrentChunkTaskScheduler.java
@@ -0,0 +1,24 @@
+package io.github.dueris.canvas.thread.chunk;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+public class ConcurrentChunkTaskScheduler {
+    private final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<>();
+
+    public void schedule(Runnable task) {
+        taskQueue.add(task);
+    }
+
+    public void tick() {
+        Runnable task;
+        while ((task = taskQueue.poll()) != null) {
+            try {
+                task.run();
+            } catch (Throwable throwable) {
+                if (throwable instanceof ThreadDeath) throw throwable;
+                else throwable.printStackTrace();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/dueris/canvas/thread/exception/AlreadySentChunkException.java b/src/main/java/io/github/dueris/canvas/thread/exception/AlreadySentChunkException.java
new file mode 100644
index 0000000000000000000000000000000000000000..6bb45ec5b4639edb016bca47f318356a07563338
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/exception/AlreadySentChunkException.java
@@ -0,0 +1,15 @@
+package io.github.dueris.canvas.thread.exception;
+
+/**
+ * I did this so I can specifically ignore the stacktrace
+ */
+public class AlreadySentChunkException extends IllegalStateException {
+
+    public AlreadySentChunkException(String string) {
+        super(string);
+    }
+
+    public AlreadySentChunkException() {
+
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/lock/ThreadedCoordinateManager.java b/src/main/java/io/github/dueris/canvas/thread/lock/ThreadedCoordinateManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..b71519081cacd2e9a480e9edde0a8c4063d2c3a2
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/lock/ThreadedCoordinateManager.java
@@ -0,0 +1,28 @@
+package io.github.dueris.canvas.thread.lock;
+
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class ThreadedCoordinateManager extends TickThread {
+    public volatile boolean running = true;
+    public Lock lock = new ReentrantLock();
+
+    public ThreadedCoordinateManager() {
+        super("ThreadedRegionManager");
+    }
+
+    @Override
+    public void run() {
+        // while ()
+    }
+
+    public void kill() {
+        running = false;
+        try {
+            lock.wait();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/thread/tracker/AsyncEntityTracker.java b/src/main/java/io/github/dueris/canvas/thread/tracker/AsyncEntityTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cd06d519695b9acf4e3af10ef847dd3d614ab4c
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/thread/tracker/AsyncEntityTracker.java
@@ -0,0 +1,45 @@
+package io.github.dueris.canvas.thread.tracker;
+
+import io.github.dueris.canvas.CanvasConfig;
+import io.github.dueris.canvas.thread.NamedTickThreadFactory;
+import java.util.Iterator;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+public class AsyncEntityTracker {
+    private final ExecutorService executor;
+    private final BlockingQueue<Runnable> taskQueue;
+
+    public AsyncEntityTracker() {
+        this.executor = Executors.newFixedThreadPool(CanvasConfig.asyncEntityTrackerThreadCount, new NamedTickThreadFactory("AsyncEntityTracker"));
+        this.taskQueue = new LinkedBlockingQueue<>();
+    }
+
+    public void scheduleUpdate(Runnable runnable) {
+        taskQueue.add(runnable);
+    }
+
+    public void tick() {
+        if (taskQueue.isEmpty()) return;
+        Iterator<Runnable> taskIterator = taskQueue.iterator();
+        while (taskIterator.hasNext()) {
+            Runnable task = taskIterator.next();
+            taskQueue.remove(task);
+            executor.submit(task);
+        }
+    }
+
+    public void stopTicking() {
+        executor.shutdown();
+        try {
+            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
+                executor.shutdownNow();
+            }
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/AsyncExecutor.java b/src/main/java/io/github/dueris/canvas/util/AsyncExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..a0f6c364b3bb033532b3deac9c321729098f58e7
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/AsyncExecutor.java
@@ -0,0 +1,72 @@
+package io.github.dueris.canvas.util;
+
+import com.google.common.collect.Queues;
+import org.jetbrains.annotations.Nullable;
+import java.util.Queue;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class AsyncExecutor implements Runnable {
+    private static final Logger LOGGER = Logger.getLogger("Async Executor");
+	private final Queue<Runnable> jobs = Queues.newArrayDeque();
+	private final Lock mutex = new ReentrantLock();
+	private final Condition cond = mutex.newCondition();
+	private final Thread thread;
+	private volatile boolean killswitch = false;
+
+	public AsyncExecutor(String threadName) {
+		this.thread = new Thread(this, threadName);
+	}
+
+	public void start() {
+		thread.start();
+	}
+
+	public void kill() {
+		killswitch = true;
+		cond.signalAll();
+	}
+
+	public void submit(Runnable runnable) {
+		mutex.lock();
+        try {
+            jobs.offer(runnable);
+			cond.signalAll();
+		} finally {
+			mutex.unlock();
+		}
+	}
+
+	@Override
+	public void run() {
+        while (!killswitch) {
+            try {
+                Runnable runnable = takeRunnable();
+                if (runnable != null) {
+                    runnable.run();
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            } catch (Exception e) {
+                LOGGER.log(Level.SEVERE, e, () -> "Failed to execute async job for thread " + thread.getName());
+            }
+        }
+    }
+
+    private @Nullable Runnable takeRunnable() throws InterruptedException {
+        mutex.lock();
+        try {
+            while (jobs.isEmpty() && !killswitch) {
+                cond.await();
+            }
+            if (jobs.isEmpty()) return null; // We've set killswitch
+            return jobs.remove();
+        } finally {
+            mutex.unlock();
+        }
+    }
+
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/ObjectGetter.java b/src/main/java/io/github/dueris/canvas/util/ObjectGetter.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc561e44f207f99001b41fb866ab40060bbe79b4
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/ObjectGetter.java
@@ -0,0 +1,6 @@
+package io.github.dueris.canvas.util;
+
+public interface ObjectGetter<T> {
+
+    public T get();
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockDeque.java b/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockDeque.java
new file mode 100644
index 0000000000000000000000000000000000000000..364fabe47695a0ca8bd5cb21ce7409771622578b
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockDeque.java
@@ -0,0 +1,153 @@
+package io.github.dueris.canvas.util;
+
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+public class WrappedConcurrentLockDeque<T> {
+    private ConcurrentLinkedDeque<T> set;
+    private ConcurrentLinkedDeque<T> toUpdate;
+    private boolean iterating = false;
+    private int count;
+
+    public WrappedConcurrentLockDeque() {
+        this.set = new ConcurrentLinkedDeque<>();
+        this.count = 0;
+    }
+
+    public synchronized WrappedConcurrentLockDeque<T> add(T item) {
+        set.add(item);
+        count++;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockDeque<T> addLast(T item) {
+        set.addLast(item);
+        count++;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockDeque<T> remove(T item) {
+        set.remove(item);
+        count--;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockDeque<T> removeAll() {
+        set.clear();
+        count = 0;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockDeque<T> addAll(ConcurrentLinkedDeque<T> set) {
+        this.set.addAll(set);
+        count = this.set.size();
+        return this;
+    }
+
+    public boolean isEmpty() {
+        return set.isEmpty();
+    }
+
+    public Iterator<T> iterator() {
+        return this.set.iterator();
+    }
+
+    public void scheduleUpdate(ConcurrentLinkedDeque<T> set) {
+        synchronized (this) {
+            if (isIterating()) {
+                toUpdate = set;
+                return;
+            }
+            this.set = set;
+            this.toUpdate = null;
+        }
+    }
+
+    public void markIterating() {
+        if (this.toUpdate != null) {
+            this.set = toUpdate;
+            count = this.set.size();
+            this.toUpdate = null;
+        }
+        iterating = true;
+    }
+
+    public void markFinished() {
+        iterating = false;
+        if (this.toUpdate != null) {
+            this.set = toUpdate;
+            count = this.set.size();
+            this.toUpdate = null;
+        }
+    }
+
+    public boolean isIterating() {
+        return iterating;
+    }
+
+    public ConcurrentLinkedDeque<T> getRaw() {
+        return set;
+    }
+
+    public int getCount() {
+        return count;
+    }
+
+    public int size() {
+        return count;
+    }
+
+    public void forEach(Consumer<T> consumer) {
+        for (final T t : this.set) {
+            consumer.accept(t);
+        }
+    }
+
+    public WrappedConcurrentLockDeque<T> clone() {
+        return new WrappedConcurrentLockDeque<T>().addAll(set);
+    }
+
+    public synchronized T pollFirst() {
+        T item = set.pollFirst();
+        if (item != null) {
+            count--;
+        }
+        return item;
+    }
+
+    public synchronized T pollLast() {
+        T item = set.pollLast();
+        if (item != null) {
+            count--;
+        }
+        return item;
+    }
+
+    public synchronized void clear() {
+        set.clear();
+        count = 0;
+    }
+
+    public synchronized T poll() {
+        T item = set.poll();
+        if (item != null) {
+            count--;
+        }
+        return item;
+    }
+
+    public synchronized boolean removeIf(Predicate<? super T> filter) {
+        boolean removed = set.removeIf(filter);
+        if (removed) {
+            count = set.size();
+        }
+        return removed;
+    }
+
+    public Stream<T> stream() {
+        return set.stream();
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockSet.java b/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..3686817d7fbde6c2c2001ef2b8623858545f6272
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/util/WrappedConcurrentLockSet.java
@@ -0,0 +1,101 @@
+package io.github.dueris.canvas.util;
+
+import java.util.Iterator;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.function.Consumer;
+
+public class WrappedConcurrentLockSet<T> {
+    private Set<T> set;
+    private Set<T> toUpdate;
+    private boolean iterating = false;
+    private int count;
+
+    public WrappedConcurrentLockSet() {
+        this.set = new CopyOnWriteArraySet<>();
+        this.count = 0;
+    }
+
+    public synchronized WrappedConcurrentLockSet<T> add(T item) {
+        set.add(item);
+        count++;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockSet<T> remove(T item) {
+        set.remove(item);
+        count--;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockSet<T> removeAll() {
+        set.clear();
+        count = 0;
+        return this;
+    }
+
+    public synchronized WrappedConcurrentLockSet<T> addAll(Set<T> set) {
+        this.set.addAll(set);
+        count = this.set.size();
+        return this;
+    }
+
+    public boolean isEmpty() {
+        return set.isEmpty();
+    }
+
+    public Iterator<T> iterator() {
+        return this.set.iterator();
+    }
+
+    public void scheduleUpdate(CopyOnWriteArraySet<T> set) {
+        synchronized (this) {
+            if (isIterating()) {
+                toUpdate = set;
+                return;
+            }
+            this.set = set;
+            this.toUpdate = null;
+        }
+    }
+
+    public void markIterating() {
+        if (this.toUpdate != null) {
+            this.set = toUpdate;
+            count = this.set.size();
+            this.toUpdate = null;
+        }
+        iterating = true;
+    }
+
+    public void markFinished() {
+        iterating = false;
+        if (this.toUpdate != null) {
+            this.set = toUpdate;
+            count = this.set.size();
+            this.toUpdate = null;
+        }
+    }
+
+    public boolean isIterating() {
+        return iterating;
+    }
+
+    public CopyOnWriteArraySet<T> getRaw() {
+        return (CopyOnWriteArraySet<T>) set;
+    }
+
+    public int getCount() {
+        return count;
+    }
+
+    public void forEach(Consumer<T> consumer) {
+        for (final T t : this.set) {
+            consumer.accept(t);
+        }
+    }
+
+    public WrappedConcurrentLockSet<T> clone() {
+        return new WrappedConcurrentLockSet<T>().addAll(set);
+    }
+}
diff --git a/src/main/java/io/github/dueris/canvas/world/TickManagerHolder.java b/src/main/java/io/github/dueris/canvas/world/TickManagerHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e63aa5c14c8f092e99d67ac8ba94b56b5facb0a9
--- /dev/null
+++ b/src/main/java/io/github/dueris/canvas/world/TickManagerHolder.java
@@ -0,0 +1,21 @@
+package io.github.dueris.canvas.world;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.server.players.PlayerList;
+import net.minecraft.world.TickRateManager;
+
+public interface TickManagerHolder {
+    public PlayerList getPlayerList();
+
+    public CommandSourceStack createCommandSourceStack();
+
+    public void onTickRateChanged();
+
+    public TickRateManager getManager();
+
+    public Float getTps();
+
+    public Long getNanoSecondsFromLastTick();
+
+    public String getHolderName();
+}
diff --git a/src/main/java/io/papermc/paper/command/MSPTCommand.java b/src/main/java/io/papermc/paper/command/MSPTCommand.java
index 8b5293b0c696ef21d0101493ffa41b60bf0bc86b..945f827e061d03b78948ea78a029c489017085a9 100644
--- a/src/main/java/io/papermc/paper/command/MSPTCommand.java
+++ b/src/main/java/io/papermc/paper/command/MSPTCommand.java
@@ -81,7 +81,7 @@ public final class MSPTCommand extends Command {
         return true;
     }
 
-    private static List<Component> eval(long[] times) {
+    public static List<Component> eval(long[] times) { // Canvas - private -> public
         long min = Integer.MAX_VALUE;
         long max = 0L;
         long total = 0L;
@@ -96,7 +96,7 @@ public final class MSPTCommand extends Command {
         return Arrays.asList(getColor(avgD), getColor(minD), getColor(maxD));
     }
 
-    private static Component getColor(double avg) {
+    public static Component getColor(double avg) { // Canvas - private -> public
         return text(DF.format(avg), avg >= 50 ? RED : avg >= 40 ? YELLOW : GREEN);
     }
 }
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
index 777b789fdcdf297309cfb36fc7f77e3fdb6327ca..73e3166785ff92511b974e2c28c72a503851639f 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
@@ -103,6 +103,7 @@ public final class EntityCommand implements PaperSubcommand {
             Map<ResourceLocation, Integer> nonEntityTicking = Maps.newHashMap();
             ServerChunkCache chunkProviderServer = world.getChunkSource();
             world.getAllEntities().forEach(e -> {
+                if (e == null) return; // Canvas
                 ResourceLocation key = EntityType.getKey(e.getType());
 
                 MutablePair<Integer, Map<ChunkPos, Integer>> info = list.computeIfAbsent(key, k -> MutablePair.of(0, Maps.newHashMap()));
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 3aa3b0be2285def7a068f1f440ee5b7736f1d96c..05b68873a216766b4185c226860ffc9653094756 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -39,7 +39,7 @@ class PaperEventManager {
         if (event.getHandlers().getRegisteredListeners().length == 0) return;
         if (event.isAsynchronous() && this.server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
+        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping() && !Thread.currentThread().getName().startsWith("WorldTicker")) { // Canvas - multithreaded world ticking
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index c03608fec96b51e1867f43d8f42e5aefb1520e46..650323c0af11affc91aaeba33b1c15169b7aaa08 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -3,12 +3,14 @@ package io.papermc.paper.threadedregions;
 import ca.spottedleaf.concurrentutil.util.Validate;
 import ca.spottedleaf.moonrise.common.util.TickThread;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import io.github.dueris.canvas.util.WrappedConcurrentLockDeque;
 import net.minecraft.world.entity.Entity;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.Consumer;
 
 /**
@@ -44,7 +46,7 @@ public final class EntityScheduler {
     private final Object stateLock = new Object();
     private final Long2ObjectOpenHashMap<List<ScheduledTask>> oneTimeDelayed = new Long2ObjectOpenHashMap<>();
 
-    private final ArrayDeque<ScheduledTask> currentlyExecuting = new ArrayDeque<>();
+    private final WrappedConcurrentLockDeque<ScheduledTask> currentlyExecuting = new WrappedConcurrentLockDeque<>(); // Canvas
 
     public EntityScheduler(final CraftEntity entity) {
         this.entity = Validate.notNull(entity);
@@ -144,7 +146,7 @@ public final class EntityScheduler {
         final List<ScheduledTask> toRun;
         synchronized (this.stateLock) {
             if (this.tickCount == RETIRED_TICK_COUNT) {
-                throw new IllegalStateException("Ticking retired scheduler");
+                return; // throw new IllegalStateException("Ticking retired scheduler"); // Canvas
             }
             ++this.tickCount;
             if (this.oneTimeDelayed.isEmpty()) {
diff --git a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
index 35772110e9318df46a2729dbc0b5879b290011b7..5fc2a1b2e042a999e85cc520cd37e5d6fdabcd4e 100644
--- a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
+++ b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
@@ -7,7 +7,9 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.function.Predicate;
+import io.netty.util.internal.ConcurrentSet;
 import net.minecraft.advancements.CriterionTrigger;
 import net.minecraft.advancements.CriterionTriggerInstance;
 import net.minecraft.server.PlayerAdvancements;
@@ -19,7 +21,7 @@ public abstract class SimpleCriterionTrigger<T extends SimpleCriterionTrigger.Si
 
     @Override
     public final void addPlayerListener(PlayerAdvancements manager, CriterionTrigger.Listener<T> conditions) {
-        manager.criterionData.computeIfAbsent(this, managerx -> Sets.newHashSet()).add(conditions);  // Paper - fix AdvancementDataPlayer leak
+        manager.criterionData.computeIfAbsent(this, managerx -> new ConcurrentSet<>()).add(conditions);  // Paper - fix AdvancementDataPlayer leak // Canvas
     }
 
     @Override
@@ -38,6 +40,7 @@ public abstract class SimpleCriterionTrigger<T extends SimpleCriterionTrigger.Si
         tracker.criterionData.remove(this); // Paper - fix AdvancementDataPlayer leak
     }
 
+    @SuppressWarnings("unchecked") // Canvas
     protected void trigger(ServerPlayer player, Predicate<T> predicate) {
         PlayerAdvancements playerAdvancements = player.getAdvancements();
         Set<CriterionTrigger.Listener<T>> set = (Set) playerAdvancements.criterionData.get(this); // Paper - fix AdvancementDataPlayer leak
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 6a8248b43bf739b691c7e888ebf964cad0a92623..6a6f64872afd15ea17041aa7ddb1720e6f35742e 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -365,6 +365,7 @@ public class Commands {
                 });
             }
         } catch (Exception exception) {
+            exception.printStackTrace(); // Canvas - lets print command stacktraces
             if (throwCommandError) throw exception;
             MutableComponent ichatmutablecomponent = Component.literal(exception.getMessage() == null ? exception.getClass().getName() : exception.getMessage());
 
diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index 21ea63da99c5b3e2e1ab9cc1049c903bba6cf288..a9881945d7a117b180848168b77975cbaf8636ec 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -9,6 +9,7 @@ import it.unimi.dsi.fastutil.longs.LongSet;
 import java.util.ArrayDeque;
 import java.util.Optional;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -519,7 +520,7 @@ public class BlockPos extends Vec3i {
     public static int breadthFirstTraversal(
         BlockPos pos, int maxDepth, int maxIterations, BiConsumer<BlockPos, Consumer<BlockPos>> nextQueuer, Predicate<BlockPos> callback
     ) {
-        Queue<Pair<BlockPos, Integer>> queue = new ArrayDeque<>();
+        Queue<Pair<BlockPos, Integer>> queue = new ConcurrentLinkedDeque<>(); // Canvas
         LongSet longSet = new LongOpenHashSet();
         queue.add(Pair.of(pos, 0));
         int i = 0;
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 75482befb5af2b517957c74ec4234f16e4ea14d0..e4c413715775922c52b1457f28fd03bfeab8e64c 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -114,6 +114,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private float averageReceivedPackets;
     private float averageSentPackets;
     private int tickCount;
+    public boolean handledOnMain = false; // Canvas
+    public String handlerThreadName; // Canvas
     private boolean handlingFault;
     @Nullable
     private volatile DisconnectionDetails delayedDisconnect;
@@ -131,6 +133,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     // Paper end - Optimize network
 
     // Paper start - add utility methods
+    @Nullable // Canvas
     public final net.minecraft.server.level.ServerPlayer getPlayer() {
         if (this.packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl impl) {
             return impl.player;
@@ -175,6 +178,23 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
 
     }
+    // Canvas start
+
+    @Override
+    public String toString() {
+        if (this.getPlayer() != null) {
+            return "Connection{" +
+                "tickCount=" + tickCount +
+                ", virtualHost=" + virtualHost +
+                ", player=" + getPlayer().getName().getString() +
+                '}';
+        }
+        return "Connection{" +
+            "tickCount=" + tickCount +
+            ", virtualHost=" + virtualHost +
+            '}';
+    }
+    // Canvas end
 
     public void channelInactive(ChannelHandlerContext channelhandlercontext) {
         this.disconnect((Component) Component.translatable("disconnect.endOfStream"));
@@ -969,6 +989,12 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         this.pendingActions.clear();
     }
+    // Canvas start
+
+    public String getHandlerThreadName() {
+        return this.handlerThreadName;
+    }
+    // Canvas end
 
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib, so it doesn't accidently pick them up.
 
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 1a37654aff9a9c86c9f7af10a1cf721371f0c5ec..60b79dd1216a4bf7cc3ccb513a15c93f4dc96ec9 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,9 @@ package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -18,18 +21,24 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public static final StreamCodec<FriendlyByteBuf, ClientboundSectionBlocksUpdatePacket> STREAM_CODEC = Packet.codec(ClientboundSectionBlocksUpdatePacket::write, ClientboundSectionBlocksUpdatePacket::new);
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
-    private final short[] positions;
+    private final Short[] positions;
     private final BlockState[] states;
+    // Canvas start - fix orebfuscator compat
 
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos pos, ShortSet set, BlockState[] states) {
+        this(pos, new ConcurrentLinkedQueue<>(set), states);
+    }
+    // Canvas end
+
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ConcurrentLinkedQueue<Short> positions, LevelChunkSection section) { // Canvas
         this.sectionPos = sectionPos;
         int i = positions.size();
 
-        this.positions = new short[i];
+        this.positions = new Short[i];
         this.states = new BlockState[i];
         int j = 0;
 
-        for (ShortIterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
+        for (Iterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
             short short0 = (Short) shortiterator.next();
 
             this.positions[j] = short0;
@@ -39,9 +48,9 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     }
 
     // CraftBukkit start - Add constructor
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ShortSet shortset, BlockState[] states) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionposition, ConcurrentLinkedQueue<Short> shortset, BlockState[] states) { // Canvas
         this.sectionPos = sectionposition;
-        this.positions = shortset.toShortArray();
+        this.positions = shortset.toArray(new Short[0]);
         this.states = states;
     }
     // CraftBukkit end
@@ -50,7 +59,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
         this.sectionPos = SectionPos.of(buf.readLong());
         int i = buf.readVarInt();
 
-        this.positions = new short[i];
+        this.positions = new Short[i];
         this.states = new BlockState[i];
 
         for (int j = 0; j < i; ++j) {
@@ -63,9 +72,9 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     }
 
     // Paper start - Multi Block Change API
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<BlockState> blockChanges) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ConcurrentHashMap<Short, ?> blockChanges) { // Canvas
         this.sectionPos = sectionPos;
-        this.positions = blockChanges.keySet().toShortArray();
+        this.positions = blockChanges.keySet().toArray(new Short[0]);
         this.states = blockChanges.values().toArray(new BlockState[0]);
     }
     // Paper end - Multi Block Change API
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 5923baa402d80000037d2f40918756fad4455924..b2232ebdc90a4f2b746441423f02e7a1135418f2 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -3,9 +3,6 @@ package net.minecraft.server;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -16,6 +13,7 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.jtracy.DiscontinuousFrame;
 import com.mojang.jtracy.TracyClient;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.thread.TickLoopThread;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -48,6 +46,7 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
@@ -57,6 +56,8 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import io.github.dueris.canvas.thread.tracker.AsyncEntityTracker;
+import io.github.dueris.canvas.world.TickManagerHolder;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.FileUtil;
@@ -116,11 +117,9 @@ import net.minecraft.util.profiling.ProfileResults;
 import net.minecraft.util.profiling.Profiler;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.profiling.ResultField;
-import net.minecraft.util.profiling.SingleTickProfiler;
 import net.minecraft.util.profiling.jfr.JvmProfiler;
 import net.minecraft.util.profiling.jfr.callback.ProfiledDuration;
 import net.minecraft.util.profiling.metrics.profiling.ActiveMetricsRecorder;
-import net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder;
 import net.minecraft.util.profiling.metrics.profiling.MetricsRecorder;
 import net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvider;
 import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
@@ -204,7 +203,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer, TickManagerHolder { // Paper - rewrite chunk system // Canvas
 
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogUtils.getLogger();
@@ -214,7 +213,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final int TICK_STATS_SPAN = 100;
     private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    public static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND; // Canvas - private -> public
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
     private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
     private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
@@ -249,10 +248,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private final LayeredRegistryAccess<RegistryLayer> registries;
     private Map<ResourceKey<Level>, ServerLevel> levels;
     private PlayerList playerList;
-    private volatile boolean running;
+    public volatile boolean running; // Canvas
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
     private boolean stopped;
-    private int tickCount;
+    public int tickCount; // Canvas
     private int ticksUntilAutosave;
     protected final Proxy proxy;
     private boolean onlineMode;
@@ -298,7 +297,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private String serverId;
     public MinecraftServer.ReloadableResources resources;
     private final StructureTemplateManager structureTemplateManager;
-    private final ServerTickRateManager tickRateManager;
+    public final ServerTickRateManager tickRateManager; // Canvas
     protected WorldData worldData;
     public PotionBrewing potionBrewing;
     private FuelValues fuelValues;
@@ -323,9 +322,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Spigot start
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
-    private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
+    public static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop // Canvas
     @Deprecated(forRemoval = true) // Paper
-    public final double[] recentTps = new double[ 4 ]; // Purpur
+    public final double[] recentTps = new double[ 4 ]; // Purpur // Canvas
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
@@ -356,6 +355,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         thread.start();
         return s0;
     }
+    // Canvas start - Multithreaded WorldTicking
+
+    public List<ServerTickRateManager> getAllTickRateManagers() {
+        List<ServerTickRateManager> managers = new ArrayList<>();
+        managers.add(this.tickRateManager);
+        this.getAllLevels().forEach(level -> {
+            managers.add((ServerTickRateManager) level.tickRateManager());
+        });
+        return managers;
+    }
+
+    public final AsyncEntityTracker tracker;
+    // Canvas end
 
     // Paper start - rewrite chunk system
     private volatile Throwable chunkSystemCrash;
@@ -367,7 +379,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private static final long CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME = 25L * 1000L; // 25us
     private static final long MAX_CHUNK_EXEC_TIME = 1000L; // 1us
-    private static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us
+    public static final long TASK_EXECUTION_FAILURE_BACKOFF = 5L * 1000L; // 5us // Canvas
 
     private long lastMidTickExecute;
     private long lastMidTickExecuteFailure;
@@ -394,6 +406,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public final void moonrise$executeMidTickTasks() {
+        if (true) return; // Canvas - no.
         final long startTime = System.nanoTime();
         if ((startTime - this.lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - this.lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -513,6 +526,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper - add paper configuration files
+        this.tracker = new AsyncEntityTracker(); // Canvas
     }
 
     private void readScoreboard(DimensionDataStorage persistentStateManager) {
@@ -1053,7 +1067,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // CraftBukkit start
-    private boolean hasStopped = false;
+    public boolean hasStopped = false; // Canvas
     private boolean hasLoggedStop = false; // Paper - Debugging
     public volatile boolean hasFullyShutdown = false; // Paper
     private final Object stopLock = new Object();
@@ -1175,6 +1189,25 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.onServerExit();
         // Paper end - Improved watchdog support - move final shutdown items here
     }
+    // Canvas start
+
+    private final LinkedBlockingQueue<TickLoopThread> currentWorldThreads = new LinkedBlockingQueue<>();
+    public void shutdownTickers() {
+        for (final TickLoopThread currentWorldThread : currentWorldThreads) {
+            currentWorldThread.endLoop();
+            try {
+                currentWorldThread.join();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    @Override
+    public ServerTickRateManager getManager() {
+        return tickRateManager;
+    }
+    // Canvas end
 
     public String getLocalIp() {
         return this.localIp;
@@ -1234,7 +1267,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private final java.math.BigDecimal[] samples;
         private final long[] times;
 
-        RollingAverage(int size) {
+        public RollingAverage(int size) { // Canvas
             this.size = size;
             this.time = size * SEC_IN_NANO;
             this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
@@ -1268,7 +1301,27 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
     // Paper end
     // Spigot End
+    // Canvas start
+    public BooleanSupplier shouldKeepTicking;
+    private boolean shouldTickLevels = false;
+    private long lastNanoTickTime = 0L;
 
+    @Override
+    public Float getTps() {
+        return Double.valueOf(tps5s.getAverage()).floatValue();
+    }
+
+    @Override
+    public Long getNanoSecondsFromLastTick() {
+        return this.lastNanoTickTime;
+    }
+
+    @Override
+    public String getHolderName() {
+        return "MinecraftServer";
+    }
+
+    // Canvas end
     protected void runServer() {
         try {
             long serverStartTime = Util.getNanos(); // Paper
@@ -1288,13 +1341,25 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // everything is init before watchdog tick.
             // anything at 3+ won't be caught here but also will trip watchdog....
             // tasks are default scheduled at -1 + delay, and first tick will tick at 1
+            // Canvas start - rewrite world ticking
+            LOGGER.info("Canvas: Starting Multithreaded WorldTickers");
+            try {
+                for (ServerLevel level : this.getAllLevels()) {
+                    this.currentWorldThreads.add(level);
+                    level.start();
+                }
+            } catch (Throwable throwable) {
+                throw new IllegalStateException("Failed to start WorldTickers");
+            }
+            // Canvas end
             final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli(); // Paper - Add total time
             LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Add total time
+            this.shouldTickLevels = true; // Canvas
             this.server.spark.enableBeforePlugins(); // Paper - spark
             org.spigotmc.WatchdogThread.tick();
             // Paper end - Improved Watchdog Support
             org.spigotmc.WatchdogThread.hasStarted = true; // Paper
-            Arrays.fill( this.recentTps, 20 );
+            Arrays.fill( this.recentTps, 20D ); // Canvas
             // Paper start - further improve server tick loop
             long tickSection = Util.getNanos();
             long currentTime;
@@ -1391,9 +1456,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
                         gameprofilerfiller.push("tick");
                         this.tickFrame.start();
-                        this.tickServer(flag ? () -> {
+                        // Canvas start
+                        shouldKeepTicking = flag ? () -> {
                             return false;
-                        } : this::haveTime);
+                        } : this::haveTime;
+                        long iA = Util.getNanos();
+                        this.tickServer(shouldKeepTicking);
+                        this.lastNanoTickTime = Util.getNanos() - iA;
+                        // Canvas end
                         // Paper start - rewrite chunk system
                         final Throwable crash = this.chunkSystemCrash;
                         if (crash != null) {
@@ -1463,6 +1533,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             try {
                 this.stopped = true;
+                // Canvas start
+                LOGGER.info("Waiting for ServerLevel processes to finish..");
+                this.shutdownTickers();
+                // Canvas end
                 this.stopServer();
             } catch (Throwable throwable3) {
                 MinecraftServer.LOGGER.error("Exception stopping the server", throwable3);
@@ -1537,7 +1611,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return crashreport;
     }
 
-    private boolean haveTime() {
+    public boolean haveTime() { // Canvas
         // CraftBukkit start
         return this.forceTicks || this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
     }
@@ -1574,6 +1648,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.waitingForNextTick = true;
 
         try {
+            // Canvas start - allow uncapping the tickrate
+            if (this.tickRateManager.isUnlockedTickRate()) {
+                this.waitingForNextTick = false;
+                return;
+                }
+            // Canvas end
             this.managedBlock(() -> {
                 return !this.haveTime();
             });
@@ -1716,6 +1796,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 for (final ServerLevel level : this.levels.values()) {
                     // process unloads
                     level.getChunkSource().tick(() -> true, false);
+                    if (level.milliSinceLastConnectionTick + 20000 < Util.getMillis()) {
+                        // Assuming WorldThread died, schedule on ServerConnectionListener
+                        level.connections.forEach((connection) -> {
+                            this.getConnection().throwToFallback(connection);
+                        });
+                        level.connections.removeAll();
+                    }
                 }
                 // Paper end - avoid issues with certain tasks not processing during sleep
                 this.server.spark.executeMainThreadTasks(); // Paper - spark
@@ -1821,6 +1908,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return Math.max(100, (int) (f * 300.0F));
     }
 
+    @Override // Canvas
     public void onTickRateChanged() {
         int i = this.computeNextAutosaveInterval();
 
@@ -1871,9 +1959,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
         ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
+        // Canvas start
+        Iterable<ServerLevel> allLevels = getAllLevels();
+        for (ServerLevel level : allLevels) {
             for (final Entity entity : level.getEntities().getAll()) {
-                if (entity.isRemoved()) {
+                if (entity == null || entity.isRemoved()) { // Canvas
                     continue;
                 }
                 final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
@@ -1881,7 +1971,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     bukkit.taskScheduler.executeTick();
                 }
             }
-        });
+            level.runMainThreadTasks(); // Canvas - scheduled thread tasks
+        } // Canvas
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         gameprofilerfiller.push("commandFunctions");
@@ -1897,7 +1988,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        /* for (final ServerLevel level : this.getAllLevels()) { // Canvas
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1936,7 +2027,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.synchronizeTime(worldserver);
                 gameprofilerfiller.pop();
             }
-            // CraftBukkit end */
+            // CraftBukkit end // Canvas
 
             gameprofilerfiller.push("tick");
 
@@ -1954,6 +2045,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        // Canvas start - Multithreaded WorldTicking
+        */ // Run scheduled main thread tasks now
+        this.tracker.tick();
+        // Canvas end
 
         gameprofilerfiller.popPush("connection");
         this.tickConnection();
@@ -1970,7 +2065,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         gameprofilerfiller.popPush("send chunks");
-        iterator = this.playerList.getPlayers().iterator();
+        Iterator<ServerPlayer> iterator = this.playerList.getPlayers().iterator(); // Canvas
 
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
@@ -2040,6 +2135,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        if (this.shouldTickLevels) level.start(); // Canvas
     }
 
     public void removeLevel(ServerLevel level) {
@@ -2047,6 +2143,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        if (this.shouldTickLevels) level.endLoop(); // Canvas
     }
     // CraftBukkit end
 
@@ -2288,6 +2385,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.stopped;
     }
 
+    @Override // Canvas
     public PlayerList getPlayerList() {
         return this.playerList;
     }
@@ -2635,6 +2733,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.resources.managers.getCommands();
     }
 
+    @Override // Canvas
     public CommandSourceStack createCommandSourceStack() {
         ServerLevel worldserver = this.overworld();
 
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 1e85c9318ede93b8e9fe548a8945324b5b00e818..2025d4de72353074476297910bbf2717fb111473 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -24,6 +24,8 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.BiConsumer;
 import javax.annotation.Nullable;
 import net.minecraft.FileUtil;
@@ -54,16 +56,16 @@ public class PlayerAdvancements {
     private final PlayerList playerList;
     private final Path playerSavePath;
     private AdvancementTree tree;
-    private final Map<AdvancementHolder, AdvancementProgress> progress = new LinkedHashMap();
-    private final Set<AdvancementHolder> visible = new HashSet();
-    private final Set<AdvancementHolder> progressChanged = new HashSet();
-    private final Set<AdvancementNode> rootsToUpdate = new HashSet();
+    private final ConcurrentHashMap<AdvancementHolder, AdvancementProgress> progress = new ConcurrentHashMap();
+    private final Set<AdvancementHolder> visible = new io.netty.util.internal.ConcurrentSet<>();
+    private final ConcurrentLinkedQueue<AdvancementHolder> progressChanged = new ConcurrentLinkedQueue();
+    private final ConcurrentLinkedQueue<AdvancementNode> rootsToUpdate = new ConcurrentLinkedQueue();
     private ServerPlayer player;
     @Nullable
     private AdvancementHolder lastSelectedTab;
     private boolean isFirstPacket = true;
     private final Codec<PlayerAdvancements.Data> codec;
-    public final Map<net.minecraft.advancements.critereon.SimpleCriterionTrigger<?>, Set<CriterionTrigger.Listener<?>>> criterionData = new java.util.IdentityHashMap<>(); // Paper - fix advancement data player leakage
+    public final Map<net.minecraft.advancements.critereon.SimpleCriterionTrigger<?>, Set<CriterionTrigger.Listener<?>>> criterionData = new ConcurrentHashMap<>(); // Paper - fix advancement data player leakage
 
     public PlayerAdvancements(DataFixer dataFixer, PlayerList playerManager, ServerAdvancementManager advancementLoader, Path filePath, ServerPlayer owner) {
         this.playerList = playerManager;
diff --git a/src/main/java/net/minecraft/server/ServerTickRateManager.java b/src/main/java/net/minecraft/server/ServerTickRateManager.java
index 37dcf3dc3e50afd85912a7496c828576a38a4e9c..b136c920a0b1a6c34c51266be84c86847167cec2 100644
--- a/src/main/java/net/minecraft/server/ServerTickRateManager.java
+++ b/src/main/java/net/minecraft/server/ServerTickRateManager.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import com.mojang.datafixers.util.Pair;
+import io.github.dueris.canvas.world.TickManagerHolder;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.game.ClientboundTickingStatePacket;
 import net.minecraft.network.protocol.game.ClientboundTickingStepPacket;
@@ -14,9 +16,10 @@ public class ServerTickRateManager extends TickRateManager {
     private long sprintTimeSpend = 0L;
     private long scheduledCurrentSprintTicks = 0L;
     private boolean previousIsFrozen = false;
-    private final MinecraftServer server;
+    private final TickManagerHolder server; // Canvas
+    private boolean unlocked = false; // Canvas
 
-    public ServerTickRateManager(MinecraftServer server) {
+    public ServerTickRateManager(TickManagerHolder server) { // Canvas
         this.server = server;
     }
 
@@ -24,6 +27,33 @@ public class ServerTickRateManager extends TickRateManager {
         return this.scheduledCurrentSprintTicks > 0L;
     }
 
+    // Canvas start
+
+    public TickManagerHolder getHolder() {
+        return server;
+    }
+
+    public Pair<ServerTickRateManager, Float> toTpsPair() {
+        return new Pair<>(this, getHolder().getTps());
+    }
+
+    public Pair<ServerTickRateManager, Long> toNanoPair() {
+        return new Pair<>(this, getHolder().getNanoSecondsFromLastTick());
+    }
+
+    public void unlock() {
+        this.unlocked = true;
+    }
+
+    public void lock() {
+        this.unlocked = false;
+    }
+
+    public boolean isUnlockedTickRate() {
+        return unlocked;
+    }
+    // Canvas end
+
     @Override
     public void setFrozen(boolean frozen) {
         super.setFrozen(frozen);
diff --git a/src/main/java/net/minecraft/server/commands/JfrCommand.java b/src/main/java/net/minecraft/server/commands/JfrCommand.java
index 7c75a461a724322782a4870546984cb7d61c42d3..8f64920a9a12cf1f2136560b38c5873dee91c0b6 100644
--- a/src/main/java/net/minecraft/server/commands/JfrCommand.java
+++ b/src/main/java/net/minecraft/server/commands/JfrCommand.java
@@ -35,6 +35,12 @@ public class JfrCommand {
     }
 
     private static int startJfr(CommandSourceStack source) throws CommandSyntaxException {
+        // Canvas start - disable jfr
+        if (true) {
+            source.sendFailure(Component.literal("Canvas disables the JFR command due to thread unsaftey"));
+            return 1;
+        }
+        // Canvas end
         Environment environment = Environment.from(source.getServer());
         if (!JvmProfiler.INSTANCE.start(environment)) {
             throw START_FAILED.create();
@@ -46,6 +52,12 @@ public class JfrCommand {
 
     private static int stopJfr(CommandSourceStack source) throws CommandSyntaxException {
         try {
+            // Canvas start - disable jfr
+            if (true) {
+                source.sendFailure(Component.literal("Canvas disables the JFR command due to thread unsaftey"));
+                return 1;
+            }
+            // Canvas end
             Path path = Paths.get(".").relativize(JvmProfiler.INSTANCE.stop().normalize());
             Path path2 = source.getServer().isPublished() && !SharedConstants.IS_RUNNING_IN_IDE ? path : path.toAbsolutePath();
             Component component = Component.literal(path.toString())
diff --git a/src/main/java/net/minecraft/server/commands/TickCommand.java b/src/main/java/net/minecraft/server/commands/TickCommand.java
index 13d96b54f48d60b098b80e04ba6168762c335c75..e2fd3674b98da77e9092bcd701f057b6912fd493 100644
--- a/src/main/java/net/minecraft/server/commands/TickCommand.java
+++ b/src/main/java/net/minecraft/server/commands/TickCommand.java
@@ -14,7 +14,6 @@ import net.minecraft.server.ServerTickRateManager;
 import net.minecraft.util.TimeUtil;
 
 public class TickCommand {
-    private static final float MAX_TICKRATE = 10000.0F;
     private static final String DEFAULT_TICKRATE = String.valueOf(20);
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
@@ -25,11 +24,27 @@ public class TickCommand {
                 .then(
                     Commands.literal("rate")
                         .then(
-                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F, 10000.0F))
+                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F)) // Canvas - remove cap on tick cmd
                                 .suggests((context, suggestionsBuilder) -> SharedSuggestionProvider.suggest(new String[]{DEFAULT_TICKRATE}, suggestionsBuilder))
                                 .executes(context -> setTickingRate(context.getSource(), FloatArgumentType.getFloat(context, "rate")))
                         )
                 )
+                // Canvas start - allow uncapping the tickrate
+                .then(
+                    Commands.literal("unlock")
+                        .executes(context -> {
+                            context.getSource().getServer().getAllTickRateManagers().forEach(ServerTickRateManager::unlock);
+                            return 1;
+                        })
+                )
+                .then(
+                    Commands.literal("lock")
+                        .executes(context -> {
+                            context.getSource().getServer().getAllTickRateManagers().forEach(ServerTickRateManager::lock);
+                            return 1;
+                        })
+                )
+                // Canvas end
                 .then(
                     Commands.literal("step")
                         .executes(context -> step(context.getSource(), 1))
@@ -61,8 +76,13 @@ public class TickCommand {
     }
 
     private static int setTickingRate(CommandSourceStack source, float rate) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        serverTickRateManager.setTickRate(rate);
+        // Canvas start
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            tickRateManager.setTickRate(rate);
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // serverTickRateManager.setTickRate(rate);
+        // Canvas end
         String string = String.format(Locale.ROOT, "%.1f", rate);
         source.sendSuccess(() -> Component.translatable("commands.tick.rate.success", string), true);
         return (int)rate;
@@ -99,8 +119,16 @@ public class TickCommand {
     }
 
     private static int sprint(CommandSourceStack source, int ticks) {
-        boolean bl = source.getServer().tickRateManager().requestGameToSprint(ticks);
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.requestGameToSprint(ticks)) {
+                success[0] = false;
+            }
+        });
+        // boolean bl = source.getServer().tickRateManager().requestGameToSprint(ticks);
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.sprint.stop.success"), true);
         }
 
@@ -109,7 +137,21 @@ public class TickCommand {
     }
 
     private static int setFreeze(CommandSourceStack source, boolean frozen) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // Canvas start
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (frozen) {
+                if (tickRateManager.isSprinting()) {
+                    tickRateManager.stopSprinting();
+                }
+
+                if (tickRateManager.isSteppingForward()) {
+                    tickRateManager.stopStepping();
+                }
+            }
+
+            tickRateManager.setFrozen(frozen);
+        });
+        /* ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
         if (frozen) {
             if (serverTickRateManager.isSprinting()) {
                 serverTickRateManager.stopSprinting();
@@ -121,6 +163,7 @@ public class TickCommand {
         }
 
         serverTickRateManager.setFrozen(frozen);
+        */ // Canvas end
         if (frozen) {
             source.sendSuccess(() -> Component.translatable("commands.tick.status.frozen"), true);
         } else {
@@ -131,9 +174,17 @@ public class TickCommand {
     }
 
     private static int step(CommandSourceStack source, int steps) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stepGameIfPaused(steps);
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stepGameIfPaused(steps)) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stepGameIfPaused(steps);
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.step.success", steps), true);
         } else {
             source.sendFailure(Component.translatable("commands.tick.step.fail"));
@@ -143,9 +194,17 @@ public class TickCommand {
     }
 
     private static int stopStepping(CommandSourceStack source) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stopStepping();
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stopStepping()) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stopStepping();
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.step.stop.success"), true);
             return 1;
         } else {
@@ -155,9 +214,17 @@ public class TickCommand {
     }
 
     private static int stopSprinting(CommandSourceStack source) {
-        ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
-        boolean bl = serverTickRateManager.stopSprinting();
-        if (bl) {
+        // Canvas start
+        boolean[] success = {true};
+        source.getServer().getAllTickRateManagers().forEach(tickRateManager -> {
+            if (!tickRateManager.stopSprinting()) {
+                success[0] = false;
+            }
+        });
+        // ServerTickRateManager serverTickRateManager = source.getServer().tickRateManager();
+        // boolean bl = serverTickRateManager.stopSprinting();
+        if (success[0]) {
+        // Canvas end
             source.sendSuccess(() -> Component.translatable("commands.tick.sprint.stop.success"), true);
             return 1;
         } else {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 9a5c2491597f32739aee3b85f7aa60dfe8452238..91d1eb60e6e1ef6319f0b349d185de73c5324998 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -241,6 +241,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
         org.purpurmc.purpur.PurpurConfig.registerCommands();
+        io.github.dueris.canvas.CanvasConfig.registerCommands(); // Canvas
         // Purpur end
         // Paper start - initialize global and world-defaults configuration
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 8dd9375f2ad2c65a773a3195aeff1f977e09e7e0..3a65999aa7330d480aeb99c725767195ea24d345 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -5,10 +5,12 @@ import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.BitSet;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
 import java.util.function.IntConsumer;
 import java.util.function.IntSupplier;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.thread.exception.AlreadySentChunkException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -39,7 +41,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
     private final LevelHeightAccessor levelHeightAccessor;
     // Paper - rewrite chunk system
     private boolean hasChangedSections;
-    private final ShortSet[] changedBlocksPerSection;
+    private final ConcurrentLinkedQueue<Short>[] changedBlocksPerSection;
     private final BitSet blockChangedLightSectionFilter;
     private final BitSet skyChangedLightSectionFilter;
     private final LevelLightEngine lightEngine;
@@ -70,14 +72,14 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
     @Override
     public final void moonrise$addReceivedChunk(final ServerPlayer player) {
         if (!this.playersSentChunkTo.add(player)) {
-            throw new IllegalStateException("Already sent chunk " + this.pos + " in world '" + ca.spottedleaf.moonrise.common.util.WorldUtil.getWorldName(this.getChunkMap().level) + "' to player " + player);
+            throw new AlreadySentChunkException("Already sent chunk " + this.pos + " in world '" + ca.spottedleaf.moonrise.common.util.WorldUtil.getWorldName(this.getChunkMap().level) + "' to player " + player);
         }
     }
 
     @Override
     public final void moonrise$removeReceivedChunk(final ServerPlayer player) {
         if (!this.playersSentChunkTo.remove(player)) {
-            throw new IllegalStateException("Already sent chunk " + this.pos + " in world '" + ca.spottedleaf.moonrise.common.util.WorldUtil.getWorldName(this.getChunkMap().level) + "' to player " + player);
+            throw new AlreadySentChunkException("Already sent chunk " + this.pos + " in world '" + ca.spottedleaf.moonrise.common.util.WorldUtil.getWorldName(this.getChunkMap().level) + "' to player " + player);
         }
     }
 
@@ -152,7 +154,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
         this.playerProvider = playersWatchingChunkProvider;
         // Paper - rewrite chunk system
         this.setTicketLevel(level);
-        this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
+        this.changedBlocksPerSection = new ConcurrentLinkedQueue[world.getSectionsCount()];
     }
 
     // CraftBukkit start
@@ -237,7 +239,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
             if (i < 0 || i >= this.changedBlocksPerSection.length) return false; // CraftBukkit - SPIGOT-6086, SPIGOT-6296
             if (this.changedBlocksPerSection[i] == null) {
                 this.hasChangedSections = true;
-                this.changedBlocksPerSection[i] = new ShortOpenHashSet();
+                this.changedBlocksPerSection[i] = new ConcurrentLinkedQueue<>();
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
@@ -302,7 +304,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
                 list = this.moonrise$getPlayers(false); // Paper - rewrite chunk system
 
                 for (int i = 0; i < this.changedBlocksPerSection.length; ++i) {
-                    ShortSet shortset = this.changedBlocksPerSection[i];
+                    ConcurrentLinkedQueue<Short> shortset = this.changedBlocksPerSection[i];
 
                     if (shortset != null) {
                         this.changedBlocksPerSection[i] = null;
@@ -311,7 +313,7 @@ public class ChunkHolder extends GenerationChunkHolder implements ca.spottedleaf
                             SectionPos sectionposition = SectionPos.of(chunk.getPos(), j);
 
                             if (shortset.size() == 1) {
-                                BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
+                                BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().next());
                                 BlockState iblockdata = world.getBlockState(blockposition);
 
                                 this.broadcast(list, new ClientboundBlockUpdatePacket(blockposition, iblockdata));
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 5b3a886c624b36557cbfaccdc3fb05a46a4ba36a..0ca9ebbc2b2234c7806913bcf5d624f05550274c 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -8,6 +8,8 @@ import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.thread.TickTaskHolder;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -27,6 +29,7 @@ import java.io.Writer;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
@@ -38,6 +41,9 @@ import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
@@ -62,6 +68,7 @@ import net.minecraft.network.protocol.game.ClientboundChunksBiomesPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
+import net.minecraft.util.ByIdMap;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.StaticCache2D;
@@ -141,7 +148,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final String storageName;
     private final PlayerMap playerMap;
     public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
-    private final Long2ByteMap chunkTypeCache;
+    private final ConcurrentHashMap<Long, Byte> chunkTypeCache; // Canvas
     // Paper - rewrite chunk system
     public int serverViewDistance;
     public final WorldGenContext worldGenContext; // Paper - public
@@ -186,8 +193,67 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.toDrop = new LongOpenHashSet();
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
-        this.chunkTypeCache = new Long2ByteOpenHashMap();
+        // Canvas start
+        this.entityMap = new Int2ObjectOpenHashMap<>() {
+            private final ConcurrentHashMap<Integer, TrackedEntity> entities = new ConcurrentHashMap<>();
+
+            @Override
+            public boolean containsKey(final int k) {
+                return entities.containsKey(k);
+            }
+
+            @Override
+            public boolean containsValue(final Object v) {
+                return entities.containsValue(v);
+            }
+
+            @Override
+            public TrackedEntity put(final int k, final TrackedEntity trackedEntity) {
+                return entities.put(k, trackedEntity);
+            }
+
+            @Override
+            public TrackedEntity put(final Integer key, final TrackedEntity value) {
+                return entities.put(key, value);
+            }
+
+            @Override
+            public TrackedEntity get(final int k) {
+                return entities.get(k);
+            }
+
+            @Override
+            public TrackedEntity get(final Object key) {
+                return entities.get(key);
+            }
+
+            @Override
+            public TrackedEntity getOrDefault(final int k, final TrackedEntity defaultValue) {
+                return entities.getOrDefault(k, defaultValue);
+            }
+
+            @Override
+            public boolean remove(final Object key, final Object value) {
+                return entities.remove(key, value);
+            }
+
+            @Override
+            public boolean remove(final int k, final Object v) {
+                return entities.remove(k, v);
+            }
+
+            @Override
+            public TrackedEntity remove(final int k) {
+                return entities.remove(k);
+            }
+
+            @Override
+            public TrackedEntity remove(final Object key) {
+                return entities.remove(key);
+            }
+        };
+        // Canvas end
+        this.chunkTypeCache = new ConcurrentHashMap<>(); // Canvas
         // Paper - rewrite chunk system
         Path path = session.getDimensionPath(world.dimension());
 
@@ -405,7 +471,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     }
 
-    protected void tick(BooleanSupplier shouldKeepTicking) {
+    public void tick(BooleanSupplier shouldKeepTicking) { // Canvas - protected -> public
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         gameprofilerfiller.push("poi");
@@ -787,7 +853,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public boolean playerIsCloseEnoughForSpawning(ServerPlayer entityplayer, ChunkPos chunkcoordintpair, double range) { // Spigot // Paper - chunk tick iteration optimisation - public
-        if (entityplayer.isSpectator()) {
+        if (entityplayer.isSpectator() && !io.github.dueris.canvas.CanvasConfig.spectatorsSpawnMobs) { // Canvas
             return false;
         } else {
             double d0 = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, entityplayer);
@@ -887,17 +953,27 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
         // Paper end - rewrite chunk system
     }
+    // Canvas start
+    public synchronized boolean addEntity(Entity entity) {
+        return addEntity(entity, false);
+    }
 
-    public void addEntity(Entity entity) {
+    public synchronized boolean addEntity(Entity entity, boolean retrial) { // Canvas - sync
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
         if (!entity.valid || entity.level() != this.level || this.entityMap.containsKey(entity.getId())) {
-            LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
-            return;
+            // Canvas start - run this on main if failed
+            if (retrial) {
+                LOGGER.error("Illegal ChunkMap::addEntity for world {}: {}{}", this.level.getWorld().getName(),
+                    entity, this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : "", new Throwable());
+            } else
+                LOGGER.warn("Illegal ChunkMap::addEntity for world {} was caught by canvas. Redirecting to main for 2nd attempt.", this.level.getWorld().getName());
+            this.level.getServer().scheduleOnMain(() -> addEntity(entity, true));
+            return false;
+            // Canvas end
         }
         // Paper end - ignore and warn about illegal addEntity calls instead of crashing server
-        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return; // Paper - Fire PlayerJoinEvent when Player is actually ready; Delay adding to tracker until after list packets
+        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return true; // Paper - Fire PlayerJoinEvent when Player is actually ready; Delay adding to tracker until after list packets // Canvas
         if (!(entity instanceof EnderDragonPart)) {
             EntityType<?> entitytypes = entity.getType();
             int i = entitytypes.clientTrackingRange() * 16;
@@ -923,11 +999,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
-
-                        while (objectiterator.hasNext()) {
-                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
+                        // Canvas start
 
+                        for (final TrackedEntity playerchunkmap_entitytracker1 : this.entityMap.values()) {
+                            if (playerchunkmap_entitytracker1 == null) continue;
+                        // Canvas end
                             if (playerchunkmap_entitytracker1.entity != entityplayer) {
                                 playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
@@ -937,13 +1013,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
             }
         }
+        return true; // Canvas
     }
 
-    protected void removeEntity(Entity entity) {
+    protected synchronized void removeEntity(Entity entity) { // Canvas - sync
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer entityplayer) {
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator(); // Canvas
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -963,12 +1040,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
+        this.level.getServer().tracker.scheduleUpdate(() -> { // Canvas
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = entityLookup.trackerEntities;
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
+            if (entity == null) continue; // Canvas
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
@@ -979,10 +1058,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 tracker.serverEntity.sendChanges();
             }
         }
+        }); // Canvas
     }
     // Paper end - optimise entity tracker
 
-    protected void tick() {
+    public void tick() { // Canvas - protected -> pubilc
         // Paper start - optimise entity tracker
         if (true) {
             this.newTrackerTick();
@@ -993,7 +1073,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator objectiterator = this.entityMap.values().iterator();
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
 
@@ -1132,7 +1212,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        public final Set<ServerPlayerConnection> seenBy = new ConcurrentSet<>(); // Paper - Perf: optimise map impl // Canvas - no.
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1272,7 +1352,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         public void updatePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
-            if (player != this.entity) {
+            if (player != this.entity && player != null) { // Canvas
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3d = player.position().subtract(this.entity.position());
                 double vec3d_dx = player.getX() - this.entity.getX();
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 7a9e7fc688e48d18a6a884f02f768ae652326aae..11ae2e1a0454d2327c6a88ead204e88a8c1827bf 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -2,6 +2,7 @@ package net.minecraft.server.level;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
@@ -25,13 +26,16 @@ import java.nio.charset.StandardCharsets;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
+import io.netty.util.internal.ConcurrentSet;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.thread.TaskScheduler;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
 
 public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemDistanceManager, ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager { // Paper - rewrite chunk system // Paper - chunk tick iteration optimisation
@@ -39,7 +43,7 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     static final Logger LOGGER = LogUtils.getLogger();
     static final int PLAYER_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
+    final ConcurrentHashMap<Long, ConcurrentSet<ServerPlayer>> playersPerChunk = new ConcurrentHashMap<Long, ConcurrentSet<ServerPlayer>>();
     // Paper - rewrite chunk system
     // Paper - chunk tick iteration optimisation
     // Paper - rewrite chunk system
@@ -159,8 +163,8 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
         ChunkPos chunkcoordintpair = pos.chunk();
         long i = chunkcoordintpair.toLong();
 
-        ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
-            return new ObjectOpenHashSet();
+        ((ConcurrentSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
+            return new ConcurrentSet();
         })).add(player);
         // Paper - chunk tick iteration optimisation
         // Paper - rewrite chunk system
@@ -169,7 +173,7 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     public void removePlayer(SectionPos pos, ServerPlayer player) {
         ChunkPos chunkcoordintpair = pos.chunk();
         long i = chunkcoordintpair.toLong();
-        ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
+        ConcurrentSet<ServerPlayer> objectset = (ConcurrentSet) this.playersPerChunk.get(i);
         if (objectset == null) return; // CraftBukkit - SPIGOT-6208
 
         if (objectset != null) objectset.remove(player); // Paper - some state corruption happens here, don't crash, clean up gracefully
@@ -307,29 +311,36 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
 
     private class FixedPlayerDistanceChunkTracker extends ChunkTracker {
 
-        protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
+        protected final ConcurrentHashMap<Long, Byte> chunks = new ConcurrentHashMap<Long, Byte>();
         protected final int maxDistance;
+        private final byte defaultReturnValue;
 
         protected FixedPlayerDistanceChunkTracker(final int i) {
             super(i + 2, 16, 256);
             this.maxDistance = i;
-            this.chunks.defaultReturnValue((byte) (i + 2));
+            this.defaultReturnValue = (byte) (i + 2);
         }
 
         @Override
         protected int getLevel(long id) {
-            return this.chunks.get(id);
+            return this.chunks.getOrDefault(id, defaultReturnValue);
         }
 
         @Override
         protected void setLevel(long id, int level) {
-            byte b0;
+            Byte b0;
 
             if (level > this.maxDistance) {
                 b0 = this.chunks.remove(id);
             } else {
                 b0 = this.chunks.put(id, (byte) level);
             }
+            // Canvas start
+
+            if (b0 == null) {
+                b0 = defaultReturnValue;
+            }
+            // Canvas end
 
             this.onLevelChange(id, b0, level);
         }
@@ -342,7 +353,7 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
         }
 
         private boolean havePlayer(long chunkPos) {
-            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
+            ConcurrentSet<ServerPlayer> objectset = (ConcurrentSet) DistanceManager.this.playersPerChunk.get(chunkPos);
 
             return objectset != null && !objectset.isEmpty();
         }
@@ -356,7 +367,7 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
                 FileOutputStream fileoutputstream = new FileOutputStream(new File(path));
 
                 try {
-                    ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+                    Iterator<Map.Entry<Long, Byte>> objectiterator = this.chunks.entrySet().iterator();
 
                     while (objectiterator.hasNext()) {
                         it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 3c711e1df57ac5b0f8795ebb12299d275792b1d4..50fd28e3a1400065ee4d56e528b968951a0bb5ef 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -2,17 +2,21 @@ package net.minecraft.server.level;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.datafixers.DataFixer;
+import java.io.File;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import java.io.IOException;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index e3e9a06047519eb4159cfa28b5cdb1ee707e4d16..ce3d6d9b3d6213a012b702cc9328b2fbc1dd0f8e 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -10,6 +10,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index ff0d266218ed60e5a4e879077c80fcdb993566e4..a2797a6bdf1a0b3cb20b90964e4b5e5c2906521c 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -29,6 +29,9 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -40,6 +43,7 @@ import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
+import net.minecraft.ReportedException;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -49,9 +53,12 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
@@ -60,6 +67,7 @@ import net.minecraft.network.protocol.game.ClientboundExplodePacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -183,6 +191,8 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+
+import static net.minecraft.server.MinecraftServer.TASK_EXECUTION_FAILURE_BACKOFF;
 // CraftBukkit end
 
 public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevelReader, ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickServerLevel {  // Paper - rewrite chunk system // Paper - chunk tick iteration
@@ -192,10 +202,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public static final IntProvider RAIN_DURATION = UniformInt.of(12000, 24000);
     private static final IntProvider THUNDER_DELAY = UniformInt.of(12000, 180000);
     public static final IntProvider THUNDER_DURATION = UniformInt.of(3600, 15600);
-    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final Logger LOGGER = LogUtils.getLogger(); // Canvas - private -> public
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new CopyOnWriteArrayList<>(); // Canvas
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -210,10 +220,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final LevelTicks<Block> blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final LevelTicks<Fluid> fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded);
     private final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    final Set<Mob> navigatingMobs = new ObjectOpenHashSet();
+    Set<Mob> navigatingMobs = new ObjectOpenHashSet();
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents = new ObjectLinkedOpenHashSet();
+    private CopyOnWriteArrayList<BlockEventData> blockEvents = new CopyOnWriteArrayList(); // Canvas
     private final List<BlockEventData> blockEventsToReschedule = new ArrayList(64);
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
@@ -598,6 +608,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
+        this.navigatingMobs = ConcurrentHashMap.newKeySet(); // Canvas
         this.tickTime = flag1;
         this.server = minecraftserver;
         // Purpur start - enable/disable MobSpawners per world
@@ -722,8 +733,109 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public StructureManager structureManager() {
         return this.structureManager;
     }
+    // Canvas start - Multithreaded Ticking
+
+    @Override
+    public void endLoop() {
+        this.running = false;
+        try {
+            LOGGER.info("Attempting to stop ServerLevel ({}) tickloop...", this.getName());
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void takeConnection(Connection connection) {
+        this.connections.add(connection);
+        connection.handledOnMain = false;
+        connection.handlerThreadName = this.dimension().location().toString();
+        server.getConnection().remindOnLevel(connection);
+    }
+
+    public void setConnectionLevel(Connection connection, ServerLevel otherLevel) {
+        if (this != otherLevel) {
+            otherLevel.takeConnection(connection);
+            this.connections.remove(connection);
+        }
+    }
+
+    public void checkFill() {
+        connections.scheduleUpdate(new CopyOnWriteArraySet<>(players.stream().map(ServerPlayer::getRawConnection).toList()));
+    }
+
+    @Override
+    public void tickThread(BooleanSupplier shouldKeepTicking, final int tickCount) {
+        this.runAllWithTiming(Timing.PRE_TICK);
+        checkFill();
+        connections.markIterating();
+        if (!this.connections.isEmpty()) {
+            Iterator<Connection> iterator = connections.iterator();
+
+            while (iterator.hasNext()) {
+                Connection playerConnection = iterator.next();
+                if (!playerConnection.isConnecting()) {
+                    if (playerConnection.isConnected()) {
+                        try {
+                            playerConnection.tick();
+                        } catch (Throwable throwable) {
+                            if (playerConnection.isMemoryConnection()) {
+                                throw new ReportedException(CrashReport.forThrowable(throwable, "Ticking memory connection"));
+                            }
+
+                            LOGGER.error("Failed to handle packet for {}", playerConnection.getLoggableAddress(this.server.logIPs()), throwable);
+
+                            MutableComponent component = Component.literal("Internal server error");
+                            playerConnection.send(new ClientboundDisconnectPacket(component), PacketSendListener.thenRun(() -> {
+                                playerConnection.disconnect(component);
+                            }));
+                            playerConnection.setReadOnly();
+                        }
+                    } else {
+                        if (playerConnection.preparing) continue;
+                        LOGGER.info("Removing disconnected PlayerConnection:{{}} from Threaded-Handler:{}", playerConnection.toString(), this.dimension.location().toString());
+                        this.connections.remove(playerConnection);
+                        playerConnection.handleDisconnection();
+                    }
+                }
 
-    public void tick(BooleanSupplier shouldKeepTicking) {
+            }
+        }
+        connections.markFinished();
+        milliSinceLastConnectionTick = Util.getMillis();
+        // mid tick tasks
+        long currTime = System.nanoTime();
+        if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this).moonrise$getLastMidTickFailure() > TASK_EXECUTION_FAILURE_BACKOFF) {
+            if (!getChunkSource().pollTask()) {
+                // we need to back off if this fails
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this).moonrise$setLastMidTickFailure(currTime);
+            }
+        }
+        // Ensure it still ticks time
+        final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+        final long dayTime = this.getDayTime();
+        long worldTime = this.getGameTime();
+        final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+        for (Player entityhuman : this.players()) {
+            if (!(entityhuman instanceof ServerPlayer) || (!this.isForceTime() && (tickCount + entityhuman.getId()) % 20 != 0)) {
+                continue;
+            }
+            ServerPlayer entityplayer = (ServerPlayer) entityhuman;
+            long playerTime = entityplayer.getPlayerTime();
+            ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
+                new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+            entityplayer.connection.send(packet);
+        }
+        this.handlingTick = true;
+        this.runAllWithTiming(io.github.dueris.canvas.thread.TickTaskHolder.Timing.PRE_TICK); // Canvas
+        //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
+        // Moved from MinecraftSever
+        this.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
+        this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
+        net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = this.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+        this.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+        // Move end
+    // Canvas end - Multithreaded Ticking
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         this.handlingTick = true;
@@ -805,6 +917,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+            this.runAllWithTiming(Timing.PRE_ENTITY); // Canvas
             this.entityTickList.forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (!tickratemanager.isEntityFrozen(entity)) {
@@ -830,8 +943,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 }
             });
             gameprofilerfiller.pop();
+            this.runAllWithTiming(Timing.POST_ENTITY); // Canvas
             this.tickBlockEntities();
         }
+        // Canvas start
+        this.runAllWithTiming(Timing.END_TICK);
+        getChunkSource().tick(shouldKeepTicking, true);
+        explosionDensityCache.clear();
+        this.concurrentChunkTaskScheduler.tick();
+        // Canvas end
 
         gameprofilerfiller.push("entityManagement");
         // Paper - rewrite chunk system
@@ -1638,7 +1758,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     // CraftBukkit start
-    private boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+    private synchronized boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) { // Canvas
         org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
         entity.generation = false; // Paper - Don't fire sync event during generation; Reset flag if it was added during a ServerLevel generation process
         // Paper start - extra debug info
@@ -1827,7 +1947,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (this.isUpdatingNavigations) {
             String s = "recursive call to sendBlockUpdated";
 
-            Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
+            return; // Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated")); // Canvas
         }
 
         this.getChunkSource().blockChanged(pos);
@@ -2140,7 +2260,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public TickRateManager tickRateManager() {
-        return this.server.tickRateManager();
+        return this.tickRateManager; // Canvas
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index ba1e985455f162a7f113afc1aa63ff655ef31288..74a62b2ce82766bbff7dac69e32e91aaae1eb3c7 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -41,6 +41,7 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.Tag;
+import net.minecraft.network.Connection;
 import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.CommonComponents;
@@ -630,6 +631,16 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
 
         return blockposition1;
     }
+    // Canvas start
+
+    public ServerGamePacketListenerImpl getConnection() {
+        return this.connection;
+    }
+
+    public Connection getRawConnection() {
+        return this.connection.connection;
+    }
+    // Canvas end
 
     private boolean noCollisionNoLiquid(ServerLevel world, AABB box) {
         return world.noCollision(this, box, true);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 88eb3774f688bcff383efa7f113bd0b1b97d8a11..453e0d9201d130a082b766fc8a408a61311bc62a 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -31,6 +31,7 @@ import org.slf4j.Logger;
 
 // CraftBukkit start
 import java.util.ArrayList;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.CakeBlock;
@@ -298,7 +299,7 @@ public class ServerPlayerGameMode {
                     if (!iblockdata.isAir()) {
                         float f1 = iblockdata.getDestroyProgress(this.player, this.player.level(), pos) * (float) (l + 1);
 
-                        if (f1 >= 0.7F) {
+                        if (f1 >= 0F) {
                             this.isDestroyingBlock = false;
                             this.level.destroyBlockProgress(this.player.getId(), pos, -1);
                             this.destroyAndAck(pos, sequence, "destroyed");
@@ -423,7 +424,7 @@ public class ServerPlayerGameMode {
             } else {
                 // CraftBukkit start
                 org.bukkit.block.BlockState state = bblock.getState();
-                this.level.captureDrops = new ArrayList<>();
+                this.level.captureDrops = new ConcurrentLinkedQueue<>(); // Canvas - CME
                 // CraftBukkit end
                 BlockState iblockdata1 = block.playerWillDestroy(this.level, pos, iblockdata, this.player);
                 boolean flag = this.level.removeBlock(pos, false);
@@ -451,10 +452,10 @@ public class ServerPlayerGameMode {
                     // return true; // CraftBukkit
                 }
                 // CraftBukkit start
-                java.util.List<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = this.level.captureDrops; // Paper - capture all item additions to the world
+                java.util.Queue<net.minecraft.world.entity.item.ItemEntity> itemsToDrop = this.level.captureDrops; // Paper - capture all item additions to the world // Canvas - CME
                 this.level.captureDrops = null; // Paper - capture all item additions to the world; Remove this earlier so that we can actually drop stuff
                 if (event.isDropItems()) {
-                    org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockDropItemEvent(bblock, state, this.player, itemsToDrop); // Paper - capture all item additions to the world
+                    org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockDropItemEvent(bblock, state, this.player, itemsToDrop.stream().toList()); // Paper - capture all item additions to the world // Canvas - CME
                 }
                 //this.level.captureDrops = null; // Paper - capture all item additions to the world; move up
 
diff --git a/src/main/java/net/minecraft/server/network/PlayerChunkSender.java b/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
index dafa2cf7d3c49fc5bdcd68d2a952812774a1dfe4..56666af8c599831de63e07edcd375c379380f7e6 100644
--- a/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
+++ b/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
@@ -2,6 +2,7 @@ package net.minecraft.server.network;
 
 import com.google.common.collect.Comparators;
 import com.mojang.logging.LogUtils;
+import io.github.dueris.canvas.thread.TickTaskHolder;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import java.util.Comparator;
@@ -79,6 +80,7 @@ public class PlayerChunkSender {
     }
 
     public static void sendChunk(ServerGamePacketListenerImpl handler, ServerLevel world, LevelChunk chunk) { // Paper - public
+        handler.player.level().scheduleTickTask(() -> { // Canvas
         // Paper start - Anti-Xray
         final boolean shouldModify = world.chunkPacketBlockController.shouldModify(handler.player, chunk);
         handler.send(new ClientboundLevelChunkWithLightPacket(chunk, world.getLightEngine(), null, null, shouldModify));
@@ -90,6 +92,7 @@ public class PlayerChunkSender {
         // Paper end - PlayerChunkLoadEvent
         ChunkPos chunkPos = chunk.getPos();
         DebugPackets.sendPoiPacketsForChunk(world, chunkPos);
+        }, TickTaskHolder.Timing.END_TICK, TickTaskHolder.State.SERVER_LEVEL); // Canvas
     }
 
     private List<LevelChunk> collectChunksToSend(ChunkMap chunkLoadingManager, ChunkPos playerPos) {
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 3a9e25b436f366fffe08c3b0c1fce11ed42ee646..09697cf01d80e0f23daaba11d3f1d4920238433f 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -32,11 +32,13 @@ import java.net.SocketAddress;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
+import net.minecraft.Util;
 import net.minecraft.network.BandwidthDebugMonitor;
 import net.minecraft.network.Connection;
 import net.minecraft.network.PacketSendListener;
@@ -46,6 +48,7 @@ import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import org.slf4j.Logger;
 
 public class ServerConnectionListener {
@@ -71,6 +74,7 @@ public class ServerConnectionListener {
             connection.isPending = false; // Paper - Optimize network
         }
     }
+    private final ConcurrentLinkedQueue<Connection> pendingSchedulerChange = new ConcurrentLinkedQueue<>();
     // Paper end - prevent blocking on adding a new connection while the server is ticking
 
     public ServerConnectionListener(MinecraftServer server) {
@@ -224,6 +228,24 @@ public class ServerConnectionListener {
         }
 
     }
+    // Canvas start
+
+    public void remindOnLevel(Connection connection) {
+        pendingSchedulerChange.add(connection);
+    }
+
+    public void throwToFallback(Connection connection) {
+        this.pending.add(connection);
+        connection.handledOnMain = true;
+    }
+
+    public void tickPendingSchedulerChanges() {
+        for (Connection connection : pendingSchedulerChange) {
+            this.connections.remove(connection);
+            connection.handledOnMain = false;
+        }
+    }
+    // Canvas end
 
     public void tick() {
         List list = this.connections;
@@ -231,16 +253,36 @@ public class ServerConnectionListener {
         synchronized (this.connections) {
             // Spigot Start
             this.addPending(); // Paper - prevent blocking on adding a new connection while the server is ticking
+            // Canvas start
+            Iterator<Connection> iterator = this.connections.iterator();
+
+            while (iterator.hasNext()) {
+                Connection connection = iterator.next();
+                if (!connection.handledOnMain) {
+                    if (connection.getPlayer() != null) {
+                        ((ServerLevel) connection.getPlayer().level()).takeConnection(connection);
+                    }
+                }
+            }
+
+            tickPendingSchedulerChanges();
+            // Canvas end
             // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
             if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
             {
                 Collections.shuffle( this.connections );
             }
             // Spigot End
-            Iterator<Connection> iterator = this.connections.iterator();
+            iterator = this.connections.iterator(); // Canvas
 
             while (iterator.hasNext()) {
-                Connection networkmanager = (Connection) iterator.next();
+                Connection networkmanager = iterator.next(); // Canvas
+                if (networkmanager.getPlayer() != null) {
+                    if (((ServerLevel) networkmanager.getPlayer().level()).milliSinceLastConnectionTick + 20000 >= Util.getMillis()) {
+                        ((ServerLevel) networkmanager.getPlayer().level()).takeConnection(networkmanager);
+                        continue;
+                    }
+                }
 
                 if (!networkmanager.isConnecting()) {
                     if (networkmanager.isConnected()) {
@@ -269,6 +311,7 @@ public class ServerConnectionListener {
                     }
                 }
             }
+            tickPendingSchedulerChanges(); // Canvas
 
         }
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 7d57f9b7fc4837f0f44f5c1cb76a5751a15b9254..103dd8b2ac66b8ea284004b6e6850c19aa9d4d98 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -24,6 +24,7 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.thread.TickTaskHolder;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -137,6 +138,7 @@ public abstract class PlayerList {
     private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    public boolean hasPlayers = false; // Canvas
     private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
     private final UserBanList bans;
     private final IpBanList ipBans;
@@ -329,6 +331,7 @@ public abstract class PlayerList {
 
         // entityplayer.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players)); // CraftBukkit - replaced with loop below
         this.players.add(player);
+        this.hasPlayers = true; // Canvas
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
         // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(entityplayer))); // CraftBukkit - replaced with loop below
@@ -617,6 +620,11 @@ public abstract class PlayerList {
         entityplayer.retireScheduler(); // Paper - Folia schedulers
         entityplayer.getAdvancements().stopListening();
         this.players.remove(entityplayer);
+        // Canvas start
+        if (this.players.isEmpty()) {
+            this.hasPlayers = false;
+        }
+        // Canvas end
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         this.server.getCustomBossEvents().onPlayerDisconnect(entityplayer);
         UUID uuid = entityplayer.getUUID();
@@ -773,6 +781,11 @@ public abstract class PlayerList {
     public ServerPlayer respawn(ServerPlayer entityplayer, boolean flag, Entity.RemovalReason entity_removalreason, RespawnReason reason, Location location) {
         entityplayer.stopRiding(); // CraftBukkit
         this.players.remove(entityplayer);
+        // Canvas start
+        if (this.players.isEmpty()) {
+            this.hasPlayers = false;
+        }
+        // Canvas end
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         entityplayer.serverLevel().removePlayerImmediately(entityplayer, entity_removalreason);
         /* CraftBukkit start
@@ -859,6 +872,7 @@ public abstract class PlayerList {
         if (!entityplayer.connection.isDisconnected()) {
             worldserver.addRespawnedPlayer(entityplayer1);
             this.players.add(entityplayer1);
+            this.hasPlayers = true; // Canvas
             this.playersByName.put(entityplayer1.getScoreboardName().toLowerCase(java.util.Locale.ROOT), entityplayer1); // Spigot
             this.playersByUUID.put(entityplayer1.getUUID(), entityplayer1);
         }
diff --git a/src/main/java/net/minecraft/util/ThreadingDetector.java b/src/main/java/net/minecraft/util/ThreadingDetector.java
index 84b3a37fe2a4597312c26abded08a45e7218cd17..c59c2d351e3c96c2e5f213073ec0e2570ec22a6c 100644
--- a/src/main/java/net/minecraft/util/ThreadingDetector.java
+++ b/src/main/java/net/minecraft/util/ThreadingDetector.java
@@ -1,5 +1,6 @@
 package net.minecraft.util;
 
+import ca.spottedleaf.moonrise.common.util.TickThread;
 import com.mojang.logging.LogUtils;
 import java.util.Arrays;
 import java.util.Objects;
@@ -33,19 +34,23 @@ public class ThreadingDetector {
 
         try {
             this.stackTraceLock.lock();
-            if (!this.lock.tryAcquire()) {
-                this.threadThatFailedToAcquire = Thread.currentThread();
-                bl = true;
-                this.stackTraceLock.unlock();
+            // Canvas start
+            if(!(Thread.currentThread() instanceof TickThread)){
+                if (!this.lock.tryAcquire()) {
+                    this.threadThatFailedToAcquire = Thread.currentThread();
+                    bl = true;
+                    this.stackTraceLock.unlock();
 
-                try {
-                    this.lock.acquire();
-                } catch (InterruptedException var6) {
-                    Thread.currentThread().interrupt();
-                }
+                    try {
+                        this.lock.acquire();
+                    } catch (InterruptedException var6) {
+                        Thread.currentThread().interrupt();
+                    }
 
-                throw this.fullException;
+                    throw this.fullException;
+                }
             }
+            // Canvas end
         } finally {
             if (!bl) {
                 this.stackTraceLock.unlock();
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 9b706276dc5b5f55b966c5472c6c4e864342b916..2f81c4fca51425bd73089bbaf50834e41a688b6c 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -6,6 +6,7 @@ import com.mojang.jtracy.TracyClient;
 import com.mojang.jtracy.Zone;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -125,7 +126,16 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
         } else {
+            // Canvas start
+            if (this.pendingRunnables.isEmpty()) return false;
+            try {
+            // Canvas end
             this.doRunTask(this.pendingRunnables.remove());
+            // Canvas start
+            } catch (NoSuchElementException e) {
+                return false;
+            }
+            // Canvas end
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 8bde4662f520870cd642fb174b29aec7cf4e0ce5..2ee88aa3380af0af8e30f539ebeea893e056a59c 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1548,8 +1548,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     protected BlockPos getOnPos(float offset) {
+        // Canvas start
+        int i = Mth.floor(this.position.x);
+        int j = Mth.floor(this.position.y - (double) offset);
+        int k = Mth.floor(this.position.z);
+        BlockPos fallback = new BlockPos(i, j, k);
+        // Canvas end
         if (this.mainSupportingBlockPos.isPresent() && this.level().getChunkIfLoadedImmediately(this.mainSupportingBlockPos.get()) != null) { // Paper - ensure no loads
-            BlockPos blockposition = (BlockPos) this.mainSupportingBlockPos.get();
+            BlockPos blockposition = this.mainSupportingBlockPos.orElse(fallback); // Canvas - fallback
 
             if (offset <= 1.0E-5F) {
                 return blockposition;
@@ -1559,11 +1565,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 return ((double) offset > 0.5D || !iblockdata.is(BlockTags.FENCES)) && !iblockdata.is(BlockTags.WALLS) && !(iblockdata.getBlock() instanceof FenceGateBlock) ? blockposition.atY(Mth.floor(this.position.y - (double) offset)) : blockposition;
             }
         } else {
-            int i = Mth.floor(this.position.x);
-            int j = Mth.floor(this.position.y - (double) offset);
-            int k = Mth.floor(this.position.z);
-
-            return new BlockPos(i, j, k);
+            return fallback; // Canvas - fallback
         }
     }
 
@@ -5051,6 +5053,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         if (this.inBlockState == null) {
             this.inBlockState = this.level().getBlockState(this.blockPosition());
         }
+        // Canvas start -- why is it still null... - iirc this only happens when the player is in an ungenerated/generating chunk, fallback to air
+
+        if (this.inBlockState == null) {
+            this.inBlockState = Blocks.AIR.defaultBlockState();
+        }
+        // Canvas end
 
         return this.inBlockState;
     }
@@ -5148,6 +5156,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.setPosRaw(x, y, z, false);
     }
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
+        // Canvas start - ensure section status is caught
+        if (this.updatingSectionStatus) {
+            final double fx = x;
+            final double fy = y;
+            final double fz = z;
+            ((ServerLevel)this.level()).chunkSource.mainThreadProcessor.execute(() -> {
+                this.setPosRaw(fx, fy, fz, forceBoundingBoxUpdate);
+            });
+            return;
+        }
+        // Canvas end
+        // Paper end - Block invalid positions and bounding box
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
@@ -5290,7 +5310,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public final void setRemoved(Entity.RemovalReason entity_removalreason, EntityRemoveEvent.Cause cause) {
         // Paper start - rewrite chunk system
         if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
-            LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
+            // LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable()); // Canvas - its fine, we try again on the next tick and it works out
             return;
         }
         // Paper end - rewrite chunk system
@@ -5354,6 +5374,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public void setLevel(Level world) {
+        if (this instanceof ServerPlayer player && player.connection != null) {
+            ((ServerLevel)this.level).setConnectionLevel(player.connection.connection, (ServerLevel) world);
+        }
         this.level = world;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 06b890275d1a171d609b91a1d1a018c43b943ab2..e18978c96b593dfef4350fe3717011bf2d5ad455 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -2,11 +2,14 @@ package net.minecraft.world.entity.ai.attributes;
 
 import com.google.common.collect.Multimap;
 import com.mojang.logging.LogUtils;
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
@@ -20,8 +23,8 @@ import org.slf4j.Logger;
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Map<Holder<Attribute>, AttributeInstance> attributes = new Object2ObjectOpenHashMap<>();
-    private final Set<AttributeInstance> attributesToSync = new ObjectOpenHashSet<>();
-    private final Set<AttributeInstance> attributesToUpdate = new ObjectOpenHashSet<>();
+    private final Set<AttributeInstance> attributesToSync = new ConcurrentSet<>();
+    private final Set<AttributeInstance> attributesToUpdate = new ConcurrentSet<>();
     private final AttributeSupplier supplier;
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
 
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractBoat.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractBoat.java
index 56c265940208bc94f531a5af94f564b59f35ebf3..d04bfd12fa8d4a23e26df85fc7222213029e95e4 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractBoat.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractBoat.java
@@ -839,7 +839,15 @@ public abstract class AbstractBoat extends VehicleEntity implements Leashable {
     public InteractionResult interact(Player player, InteractionHand hand) {
         InteractionResult enuminteractionresult = super.interact(player, hand);
 
-        return (InteractionResult) (enuminteractionresult != InteractionResult.PASS ? enuminteractionresult : (!player.isSecondaryUseActive() && this.outOfControlTicks < 60.0F && (this.level().isClientSide || player.startRiding(this)) ? InteractionResult.SUCCESS : InteractionResult.PASS));
+        // Canvas start
+        if (player.isSecondaryUseActive()) return InteractionResult.PASS;
+        if (this.outOfControlTicks < 60.0F) {
+            if (!this.level().isClientSide())
+                return player.startRiding(this) ? InteractionResult.CONSUME : InteractionResult.PASS;
+            return InteractionResult.SUCCESS;
+        }
+        return InteractionResult.PASS;
+        // Canvas end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index c2aff2f03451b97f1ec6bd4ee987bb729177320a..2025c5216b741cc39ac6af63ea7e52bed70cb324 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -3,15 +3,17 @@ package net.minecraft.world.level;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+import io.github.dueris.canvas.thread.TickLoopThread;
+import io.github.dueris.canvas.thread.TickTaskHolder;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -24,14 +26,13 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
+import io.github.dueris.canvas.thread.ScheduledTask;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.StringRepresentable;
@@ -42,8 +43,6 @@ import net.minecraft.world.TickRateManager;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -105,7 +104,7 @@ import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
 
-public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions
+public abstract class Level extends TickLoopThread implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system // Paper - optimise collisions // Canvas
 
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
@@ -140,10 +139,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final boolean isClientSide;
     private final WorldBorder worldBorder;
     private final BiomeManager biomeManager;
-    private final ResourceKey<Level> dimension;
+    public final ResourceKey<Level> dimension; // Canvas
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public java.util.concurrent.LinkedBlockingQueue<io.github.dueris.canvas.thread.ScheduledTask> scheduledTasks = new java.util.concurrent.LinkedBlockingQueue<>();
+    public int taskCount = 0;
 
     // CraftBukkit start Added the following
     private final CraftWorld world;
@@ -154,9 +155,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
     public boolean isBlockPlaceCancelled = false; // Paper - prevent calling cleanup logic when undoing a block place upon a cancelled BlockPlaceEvent
-    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
+    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = Collections.synchronizedMap(new java.util.LinkedHashMap<>()); // Paper // Canvas - synchronize
     public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper - Retain block place order when capturing blockstates
-    public List<ItemEntity> captureDrops;
+    public java.util.Queue<ItemEntity> captureDrops; // Canvas - CME
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -232,6 +233,58 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public CraftServer getCraftServer() {
         return (CraftServer) Bukkit.getServer();
     }
+    // Canvas start - scheduler tasks
+
+    @Override
+    public void scheduleTickTask(Runnable runnable, TickTaskHolder.Timing timing, TickTaskHolder.State state) {
+        this.scheduledTasks.add(new ScheduledTask(runnable, state.equals(TickTaskHolder.State.MAIN), timing));
+        taskCount++;
+    }
+
+    public void runAllScheduledTasks() {
+        if (taskCount == 0) return;
+        List<ScheduledTask> tasksToRun = new java.util.ArrayList<>(this.scheduledTasks);
+        this.scheduledTasks.clear();
+
+        for (ScheduledTask task : tasksToRun) {
+            task.run();
+            taskCount--;
+        }
+    }
+
+    public void runAllWithTiming(TickTaskHolder.Timing timing) {
+        if (taskCount == 0) return;
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (task.canRun(timing) && task.serverLevel()) {
+                iterator.remove();
+                task.run();
+                taskCount--;
+            }
+        }
+    }
+
+    public void runMainThreadTasks() {
+        if (taskCount == 0) return;
+        Iterator<ScheduledTask> iterator = this.scheduledTasks.iterator();
+        while (iterator.hasNext()) {
+            ScheduledTask task = iterator.next();
+            if (task == null) break;
+            if (!task.serverLevel()) {
+                iterator.remove();
+                task.run();
+                taskCount--;
+            }
+        }
+    }
+
+    public ScheduledTask[] getMainThreadTasks() {
+        return (ScheduledTask[]) this.scheduledTasks.stream().filter(s -> !s.serverLevel()).toArray().clone();
+    }
+    // Canvas end
+
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
@@ -875,6 +928,16 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     // Paper end - optimise random ticking
 
     protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray
+        // Canvas start
+        super(resourcekey.location().toString(), MinecraftServer.getServer());
+        this.setUncaughtExceptionHandler((thread1, throwable) -> {
+            ServerLevel.LOGGER.error("Uncaught exception in WorldTicker thread", throwable);
+        });
+        this.setPriority(Thread.NORM_PRIORITY + 2);
+        if (Runtime.getRuntime().availableProcessors() > 4) {
+            this.setPriority(8);
+        }
+        // Canvas end
         // Paper start - getblock optimisations - cache world height/sections
         final DimensionType dimType = holder.value();
         this.minY = dimType.minY();
@@ -1484,6 +1547,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public void addBlockEntityTicker(TickingBlockEntity ticker) {
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
     }
+    private it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity> toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Canvas
 
     protected void tickBlockEntities() {
         ProfilerFiller gameprofilerfiller = Profiler.get();
@@ -1502,7 +1566,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         int tickedEntities = 0; // Paper - rewrite chunk system
 
         int tilesThisCycle = 0;
-        var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll
+        // var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll // Canvas
         toRemove.add(null); // Paper - Fix MC-117075
         for (tileTickPosition = 0; tileTickPosition < this.blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters
             this.tileTickPosition = (this.tileTickPosition < this.blockEntityTickers.size()) ? this.tileTickPosition : 0;
@@ -1524,6 +1588,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
         }
         this.blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075
+        toRemove.clear(); // Canvas
 
         this.tickingBlockEntities = false;
         gameprofilerfiller.pop();
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index e9e919fdcd61cb59e8b02a0ac5b33c8a1c7ca240..1910ef50fa7025f303e3f84ac6a9c89dbe75a4fd 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -42,6 +42,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.levelgen.structure.Structure;
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 852bfe68ab722a5cbdd90dbd70501b751fe81a78..d3891f0966182a5815d0dd62e4090ea34397de89 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -329,7 +329,7 @@ public abstract class BlockBehaviour implements FeatureElement {
         return this.getCollisionShape(state, world, pos, context);
     }
 
-    protected void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {}
+    protected synchronized void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {} // Canvas
 
     protected void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {}
 
@@ -1277,7 +1277,7 @@ public abstract class BlockBehaviour implements FeatureElement {
             this.getBlock().tick(this.asState(), world, pos, random);
         }
 
-        public void randomTick(ServerLevel world, BlockPos pos, RandomSource random) {
+        public synchronized void randomTick(ServerLevel world, BlockPos pos, RandomSource random) { // Canvas
             this.getBlock().randomTick(this.asState(), world, pos, random);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 4640baec5bed6c2d53cc0f8ca1d273cc115abe9b..e6d8dd922224857deee76d01e03dccb2f1c2a56c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -549,6 +549,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
 
     @Override
     public void setBlockEntity(BlockEntity blockEntity) {
+        synchronized (this.level) { // Canvas - synchronize between levels
         BlockPos blockposition = blockEntity.getBlockPos();
         BlockState iblockdata = this.getBlockState(blockposition);
 
@@ -585,6 +586,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
             }
 
         }
+        } // Canvas - synchronize between levels
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index e4ae25c83ab9dd1aaa530a5456275ef63cdb8511..99b4e5884f4b4bf5dfa5ff7eaa5ab2c7ce904a7f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -19,8 +19,8 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
     public static final int SECTION_HEIGHT = 16;
     public static final int SECTION_SIZE = 4096;
     public static final int BIOME_CONTAINER_BITS = 2;
-    short nonEmptyBlockCount; // Paper - package private
-    private short tickingBlockCount;
+    public short nonEmptyBlockCount; // Paper - package private // Canvas - Implement noisium; why?
+    public short tickingBlockCount; // Canvas - AT
     private short tickingFluidCount;
     public final PalettedContainer<BlockState> states;
     private PalettedContainer<Holder<Biome>> biomes; // CraftBukkit - read/write
@@ -309,18 +309,14 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
     // CraftBukkit end
 
     public void fillBiomesFromNoise(BiomeResolver biomeSupplier, Climate.Sampler sampler, int x, int y, int z) {
-        PalettedContainer<Holder<Biome>> datapaletteblock = this.biomes.recreate();
-        boolean flag = true;
+        // Canvas start - Implement noisium; micro optimization
+        PalettedContainer<Holder<Biome>> palette = this.biomes.recreate();
 
-        for (int l = 0; l < 4; ++l) {
-            for (int i1 = 0; i1 < 4; ++i1) {
-                for (int j1 = 0; j1 < 4; ++j1) {
-                    datapaletteblock.getAndSetUnchecked(l, i1, j1, biomeSupplier.getNoiseBiome(x + l, y + i1, z + j1, sampler));
-                }
-            }
-        }
+        for (int y1 = 0; y1 < 4; ++y1) for (int z1 = 0; z1 < 4; ++z1) for (int x1 = 0; x1 < 4; ++x1)
+            palette.getAndSetUnchecked(x1, y1, z1, biomeSupplier.getNoiseBiome(x + x1, y + y1, z + z1, sampler));
 
-        this.biomes = datapaletteblock;
+        this.biomes = palette;
+        // Canvas end - Implement noisium; micro optimization
     }
 
     public LevelChunkSection copy() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 8b84bf2272556ac3321cbf16361d7f48a1cc6873..d3dff2921856e04fc39b236f8a6be1c3d46b0d91 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -30,7 +30,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     public final IdMap<T> registry;
     private final T @org.jetbrains.annotations.Nullable [] presetValues; // Paper - Anti-Xray - Add preset values
     public volatile PalettedContainer.Data<T> data; // Paper - optimise collisions - public
-    private final PalettedContainer.Strategy strategy;
+    public final PalettedContainer.Strategy strategy; // Canvas - private -> public
     // private final ThreadingDetector threadingDetector = new ThreadingDetector("PalettedContainer"); // Paper - unused
 
     public void acquire() {
diff --git a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
index b331c93c82c27f9456fec208a0c008c5bedfa8c4..ca8be11868236d59b21e17151cfd4ddbf7615df0 100644
--- a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -547,6 +547,7 @@ public class EndDragonFight {
             this.spawnExitPortal(true);
         } else {
             this.updateCrystalCount();
+            if (this.dragonUUID != null) { // Canvas
             Entity entity = this.level.getEntity(this.dragonUUID);
 
             if (entity instanceof EnderDragon) {
@@ -554,6 +555,7 @@ public class EndDragonFight {
 
                 entityenderdragon.onCrystalDestroyed(this.level, enderCrystal, enderCrystal.blockPosition(), source);
             }
+            } // Canvas
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index d8b4196adf955f8d414688dc451caac2d9c609d9..042858d683745e4c0fd5a9cfc7d6965f146efd5d 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -4,12 +4,14 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    public final ConcurrentLinkedQueue<Entity> entities = new ConcurrentLinkedQueue<>(); // private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system // Canvas
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
@@ -33,13 +35,13 @@ public class EntityTickList {
         // Paper start - rewrite chunk system
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
-        final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+        Iterator<Entity> iterator = this.entities.iterator();
         try {
             while (iterator.hasNext()) {
                 action.accept(iterator.next());
             }
         } finally {
-            iterator.finishedIterating();
+            // iterator.finishedIterating();
         }
         // Paper end - rewrite chunk system
     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 3f39d6c786d9dfdd9ad591e08ff05fcbb41a1df6..126016ac384fcba56563c98d137c4591ef7cedb4 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -13,6 +13,8 @@ import java.util.Objects;
 import java.util.OptionalInt;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -51,6 +53,8 @@ import org.apache.commons.lang3.mutable.MutableObject;
 
 public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
+    public static boolean NOISIUM = true; // Canvas - Implement noisium
+    private static ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();
     public static final MapCodec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
         return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((chunkgeneratorabstract) -> {
             return chunkgeneratorabstract.biomeSource;
@@ -377,6 +381,18 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
                                 iblockdata = this.debugPreliminarySurfaceLevel(noisechunk, j4, j3, i5, iblockdata);
                                 if (iblockdata != NoiseBasedChunkGenerator.AIR && !SharedConstants.debugVoidTerrain(chunk.getPos())) {
+                                    // Canvas start - Implement noisium
+                                    chunksection.nonEmptyBlockCount++;
+
+                                    if (!iblockdata.getFluidState().isEmpty()) chunksection.nonEmptyBlockCount++;
+                                    if (iblockdata.isRandomlyTicking()) chunksection.tickingBlockCount++;
+
+                                    chunksection.states.data.storage().set(
+                                        chunksection.states.strategy.getIndex(k4, k3, j5),
+                                        chunksection.states.data.palette().idFor(iblockdata)
+                                    );
+                                    // Canvas end - Implement noisium
+
                                     chunksection.setBlockState(k4, k3, j5, iblockdata, false);
                                     heightmap.update(k4, j3, j5, iblockdata);
                                     heightmap1.update(k4, j3, j5, iblockdata);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
index 932d1d9bd717b1176f8c82b0cf65d2eb6403ad40..9a6b15a7142c71ada70d42a403e6a97eebf97466 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
@@ -8,7 +8,12 @@ import net.minecraft.core.QuartPos;
 import net.minecraft.world.level.LevelHeightAccessor;
 import net.minecraft.world.level.dimension.DimensionType;
 
-public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int noiseSizeVertical) {
+// Canvas start - Implement noisium
+public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int noiseSizeVertical, int cellHeight, int cellWidth) {
+    public NoiseSettings(int minY, int height, int noiseSizeHorizontal, int noiseSizeVertical) {
+        this(minY, height, noiseSizeHorizontal, noiseSizeVertical, QuartPos.toBlock(noiseSizeHorizontal), QuartPos.toBlock(noiseSizeVertical));
+    }
+// Canvas end - Implement noisium
     public static final Codec<NoiseSettings> CODEC = RecordCodecBuilder.<NoiseSettings>create(
             instance -> instance.group(
                         Codec.intRange(DimensionType.MIN_Y, DimensionType.MAX_Y).fieldOf("min_y").forGetter(NoiseSettings::minY),
@@ -44,11 +49,11 @@ public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int n
     }
 
     public int getCellHeight() {
-        return QuartPos.toBlock(this.noiseSizeVertical());
+        return this.cellHeight; // Canvas - Implement noisium
     }
 
     public int getCellWidth() {
-        return QuartPos.toBlock(this.noiseSizeHorizontal());
+        return this.cellWidth; // Canvas - Implement noisium
     }
 
     public NoiseSettings clampToHeightAccessor(LevelHeightAccessor world) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
index 25591124b6fadd3b976dfab79b06ae30278f8e6b..e720501b4cdffd18639546f415d4a7736786baf6 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredFeature.java
@@ -22,6 +22,7 @@ public record ConfiguredFeature<FC extends FeatureConfiguration, F extends Featu
     public static final Codec<HolderSet<ConfiguredFeature<?, ?>>> LIST_CODEC = RegistryCodecs.homogeneousList(Registries.CONFIGURED_FEATURE, DIRECT_CODEC);
 
     public boolean place(WorldGenLevel world, ChunkGenerator chunkGenerator, RandomSource random, BlockPos origin) {
+        if (io.github.dueris.canvas.CanvasConfig.disableFeatures) return false; // Canvas
         return this.feature.place(this.config, world, chunkGenerator, random, origin);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java b/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
index 0e6dfe2635ea5f5e410049b05f94f5083b2f18a4..85b851bd8e835d965f37caa16253b3bdeb80ad18 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
@@ -11,9 +11,7 @@ public record MaterialRuleList(NoiseChunk.BlockStateFiller[] materialRuleList) i
     public BlockState calculate(DensityFunction.FunctionContext pos) {
         for (NoiseChunk.BlockStateFiller blockStateFiller : this.materialRuleList) {
             BlockState blockState = blockStateFiller.calculate(pos);
-            if (blockState != null) {
-                return blockState;
-            }
+            if (blockState == null) continue; return blockState; // Canvas - Implement noisium
         }
 
         return null;
diff --git a/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java b/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
index 7ed694cbdd3a0c8d5643524eba3f56bc533ef3a7..90801365c2e972600ecff950bf0b651af6967487 100644
--- a/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
+++ b/src/main/java/net/minecraft/world/level/lighting/DynamicGraphMinFixedPoint.java
@@ -6,6 +6,7 @@ import it.unimi.dsi.fastutil.longs.LongArrayList;
 import it.unimi.dsi.fastutil.longs.LongList;
 import java.util.function.LongPredicate;
 import net.minecraft.util.Mth;
+import javax.annotation.Nullable;
 
 public abstract class DynamicGraphMinFixedPoint {
     public static final long SOURCE = Long.MAX_VALUE;
@@ -127,9 +128,15 @@ public abstract class DynamicGraphMinFixedPoint {
         } else {
             while (!this.priorityQueue.isEmpty() && maxSteps > 0) {
                 maxSteps--;
-                long l = this.priorityQueue.removeFirstLong();
+                // Canvas start
+                Long l = this.priorityQueue.removeFirstLong();
+                if (l == null) break;
+
                 int i = Mth.clamp(this.getLevel(l), 0, this.levelCount - 1);
-                int j = this.computedLevels.remove(l) & 255;
+                Byte b = this.computedLevels.remove(l);
+                if (b == null) break; // Catch this early, stop if there are 0 left.
+                int j = b & 255;
+                // Canvas end
                 if (j < i) {
                     this.setLevel(l, j);
                     this.checkNeighborsAfterUpdate(l, j, true);
@@ -137,7 +144,7 @@ public abstract class DynamicGraphMinFixedPoint {
                     this.setLevel(l, this.levelCount - 1);
                     if (j != this.levelCount - 1) {
                         this.priorityQueue.enqueue(l, this.calculatePriority(this.levelCount - 1, j));
-                        this.computedLevels.put(l, (byte)j);
+                        this.computedLevels.put(l.longValue(), (byte)j); // Canvas
                     }
 
                     this.checkNeighborsAfterUpdate(l, i, false);
diff --git a/src/main/java/net/minecraft/world/level/lighting/LeveledPriorityQueue.java b/src/main/java/net/minecraft/world/level/lighting/LeveledPriorityQueue.java
index f6fbebe9f28b66db27ec9c20e9d672b2eebc99e0..23350e72e72d506a18d6c45430078bb59a159cfe 100644
--- a/src/main/java/net/minecraft/world/level/lighting/LeveledPriorityQueue.java
+++ b/src/main/java/net/minecraft/world/level/lighting/LeveledPriorityQueue.java
@@ -1,33 +1,53 @@
 package net.minecraft.world.level.lighting;
 
+import io.netty.util.internal.ConcurrentSet;
 import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class LeveledPriorityQueue {
     private final int levelCount;
-    private final LongLinkedOpenHashSet[] queues;
+    private final ConcurrentSkipListSet<Long>[] queues;
     private int firstQueuedLevel;
 
     public LeveledPriorityQueue(int levelCount, int expectedLevelSize) {
         this.levelCount = levelCount;
-        this.queues = new LongLinkedOpenHashSet[levelCount];
+        this.queues = new ConcurrentSkipListSet[levelCount];
 
         for (int i = 0; i < levelCount; i++) {
-            this.queues[i] = new LongLinkedOpenHashSet(expectedLevelSize, 0.5F) {
+            this.queues[i] = new ConcurrentSkipListSet<Long>();/*(expectedLevelSize, 0.5F) { // Canvas
                 protected void rehash(int i) {
                     if (i > expectedLevelSize) {
                         super.rehash(i);
                     }
                 }
-            };
+            };*/ // Canvas
         }
 
         this.firstQueuedLevel = levelCount;
     }
+    // Canvas start
 
-    public long removeFirstLong() {
-        LongLinkedOpenHashSet longLinkedOpenHashSet = this.queues[this.firstQueuedLevel];
-        long l = longLinkedOpenHashSet.removeFirstLong();
+    @Nullable
+    private static <E> E removeFirstEntry(ConcurrentSkipListSet<E> set) {
+        Iterator<E> iterator = set.iterator();
+        if (iterator.hasNext()) {
+            E firstElement = iterator.next();
+            set.remove(firstElement);
+            return firstElement;
+        }
+        return null;
+    }
+
+    @Nullable
+    public Long removeFirstLong() {
+    // Canvas end
+        ConcurrentSkipListSet<Long> longLinkedOpenHashSet = this.queues[this.firstQueuedLevel];
+        // Canvas start
+        @Nullable Long l = removeFirstEntry(longLinkedOpenHashSet);
         if (longLinkedOpenHashSet.isEmpty()) {
+        // Canvas end
             this.checkFirstQueuedLevel(this.levelCount);
         }
 
@@ -39,7 +59,7 @@ public class LeveledPriorityQueue {
     }
 
     public void dequeue(long id, int level, int levelCount) {
-        LongLinkedOpenHashSet longLinkedOpenHashSet = this.queues[level];
+        ConcurrentSkipListSet<Long> longLinkedOpenHashSet = this.queues[level];
         longLinkedOpenHashSet.remove(id);
         if (longLinkedOpenHashSet.isEmpty() && this.firstQueuedLevel == level) {
             this.checkFirstQueuedLevel(levelCount);
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 0587f4e5083a6c890a11642284a9c16fb2eb2fe1..4e0a729454d423f0067ba815f822ceb7057ccf2a 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -4,6 +4,8 @@ import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -17,8 +19,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
+    private final ConcurrentLinkedDeque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>(); // Canvas
     private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final ConcurrentLinkedDeque<Runnable> updateTasks = new ConcurrentLinkedDeque<>();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -48,7 +51,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         this.addAndRun(pos, new CollectingNeighborUpdater.MultiNeighborUpdate(pos.immutable(), sourceBlock, orientation, except));
     }
 
-    private void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) {
+    private synchronized void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) { // Canvas
         boolean bl = this.count > 0;
         boolean bl2 = this.maxChainedNeighborUpdates >= 0 && this.count >= this.maxChainedNeighborUpdates;
         this.count++;
@@ -56,10 +59,11 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             if (bl) {
                 this.addedThisLayer.add(entry);
             } else {
+                if (entry == null) return; // Canvas
                 this.stack.push(entry);
             }
         } else if (this.count - 1 == this.maxChainedNeighborUpdates) {
-            LOGGER.error("Too many chained neighbor updates. Skipping the rest. First skipped position: " + pos.toShortString());
+            LOGGER.error("Too many chained neighbor updates. Skipping the rest. First skipped position: {}", pos.toShortString()); // Canvas
         }
 
         if (!bl) {
@@ -68,9 +72,11 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     private void runUpdates() {
+        updateTasks.add(() -> { // Canvas
         try {
             while (!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
                 for (int i = this.addedThisLayer.size() - 1; i >= 0; i--) {
+                    if (this.addedThisLayer.get(i) == null) continue; // Canvas
                     this.stack.push(this.addedThisLayer.get(i));
                 }
 
@@ -79,7 +85,17 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
 
                 while (this.addedThisLayer.isEmpty()) {
                     if (!neighborUpdates.runNext(this.level)) {
+                        // Canvas start
+                        if (!this.stack.isEmpty()) {
+                        try {
                         this.stack.pop();
+                        } catch (NoSuchElementException e) {
+                            // Ignore throw, its fineeeee
+                        } catch (Throwable e) {
+                            throw e;
+                        }
+                        }
+                        // Canvas end
                         break;
                     }
                 }
@@ -89,6 +105,15 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             this.addedThisLayer.clear();
             this.count = 0;
         }
+        // Canvas start
+        });
+        synchronized (updateTasks) {
+            updateTasks.removeIf((run) -> {
+                run.run();
+                return true;
+            });
+        }
+        // Canvas end
     }
 
     static record FullNeighborUpdate(BlockState state, BlockPos pos, Block block, @Nullable Orientation orientation, boolean movedByPiston)
@@ -120,7 +145,12 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         }
 
         @Override
-        public boolean runNext(Level world) {
+        // Canvas start
+        public synchronized boolean runNext(Level world) {
+            if (this.idx >= NeighborUpdater.UPDATE_ORDER.length) {
+                return false;
+            }
+        // Canvas end
             Direction direction = NeighborUpdater.UPDATE_ORDER[this.idx++];
             BlockPos blockPos = this.sourcePos.relative(direction);
             BlockState blockState = world.getBlockState(blockPos);
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index 3858c83c58e78435a6e29de84c33faa2f26d593d..783fcdacc879092471f70f0bec3c900db41f3081 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -8,6 +8,7 @@ import java.util.Optional;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.PriorityBlockingQueue;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -18,7 +19,7 @@ import net.minecraft.nbt.ListTag;
 import net.minecraft.world.level.ChunkPos;
 
 public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickContainerAccess<T>, ca.spottedleaf.moonrise.patches.chunk_system.ticks.ChunkSystemLevelChunkTicks { // Paper - rewrite chunk system
-    private final Queue<ScheduledTick<T>> tickQueue = new PriorityQueue<>(ScheduledTick.DRAIN_ORDER);
+    private final Queue<ScheduledTick<T>> tickQueue = new PriorityBlockingQueue<>(11, ScheduledTick.DRAIN_ORDER); // Canvas
     @Nullable
     private List<SavedTick<T>> pendingTicks;
     private final Set<ScheduledTick<?>> ticksPerPosition = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 778e6476c86d823dc8efe603a95e589e8b2ea9d9..35707efb5d12dde951cde66eba4d34a023d5c2a1 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -11,14 +11,20 @@ import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 import java.util.LongSummaryStatistics;
+import java.util.Map;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.function.BiConsumer;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
+import io.github.dueris.canvas.util.WrappedConcurrentLockDeque;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -31,10 +37,10 @@ import net.minecraft.world.level.levelgen.structure.BoundingBox;
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
     private final LongPredicate tickCheck;
-    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
-    private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), map -> map.defaultReturnValue(Long.MAX_VALUE));
+    private final ConcurrentHashMap<Long, LevelChunkTicks<T>> allContainers = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Long, Long> nextTickForContainer = new ConcurrentHashMap<>();
     private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
-    private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
+    private final WrappedConcurrentLockDeque<ScheduledTick<T>> toRunThisTick = new WrappedConcurrentLockDeque<>(); // Canvas
     private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
@@ -98,12 +104,12 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void sortContainersToTick(long time) {
-        ObjectIterator<Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
+        Iterator<Map.Entry<Long, Long>> objectIterator = this.nextTickForContainer.entrySet().iterator();
 
         while (objectIterator.hasNext()) {
-            Entry entry = objectIterator.next();
-            long l = entry.getLongKey();
-            long m = entry.getLongValue();
+            Map.Entry<Long, Long> entry = objectIterator.next();
+            long l = entry.getKey();
+            long m = entry.getValue();
             if (m <= time) {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
@@ -212,7 +218,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
 
     private void calculateTickSetIfNeeded() {
         if (this.toRunThisTickSet.isEmpty() && !this.toRunThisTick.isEmpty()) {
-            this.toRunThisTickSet.addAll(this.toRunThisTick);
+            this.toRunThisTickSet.addAll(this.toRunThisTick.getRaw());
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 70b6e9a4484a398cd034c0b87203b891b79c7204..fd0d47842511aeb801471b8e3d403a10d43967be 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1236,6 +1236,7 @@ public final class CraftServer implements Server {
         io.papermc.paper.command.PaperCommands.registerCommands(this.console); // Paper
         this.spark.registerCommandBeforePlugins(this); // Paper - spark
         org.purpurmc.purpur.PurpurConfig.registerCommands(); // Purpur
+        io.github.dueris.canvas.CanvasConfig.registerCommands(); // Canvas
         this.overrideAllCommandBlockCommands = this.commandsConfiguration.getStringList("command-block-overrides").contains("*");
         this.ignoreVanillaPermissions = this.commandsConfiguration.getBoolean("ignore-vanilla-permissions");
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index ea1b4f0073f775fdd18eb080886d60c71a08ab2c..5761b4cb633948be0d3f3b5603fb2a667dc9c81a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -208,6 +208,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public int getEntityCount() {
         int ret = 0;
         for (net.minecraft.world.entity.Entity entity : world.getEntities().getAll()) {
+            if (entity == null) continue; // Canvas
             if (entity.isChunkLoaded()) {
                 ++ret;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index a6f5c65ec21b9671fc7c699bcf274b95c5fd8cdf..5afbfcbc26936216072ac321774ece355770941d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -32,6 +32,8 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
@@ -1020,20 +1022,20 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMultiBlockChange(final Map<? extends io.papermc.paper.math.Position, BlockData> blockChanges) {
         if (this.getHandle().connection == null) return;
 
-        Map<SectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState>> sectionMap = new HashMap<>();
+        Map<SectionPos, ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState>> sectionMap = new HashMap<>();
 
         for (Map.Entry<? extends io.papermc.paper.math.Position, BlockData> entry : blockChanges.entrySet()) {
             BlockData blockData = entry.getValue();
             BlockPos blockPos = io.papermc.paper.util.MCUtil.toBlockPos(entry.getKey());
             SectionPos sectionPos = SectionPos.of(blockPos);
 
-            it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState> sectionData = sectionMap.computeIfAbsent(sectionPos, key -> new it.unimi.dsi.fastutil.shorts.Short2ObjectArrayMap<>());
+            ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState> sectionData = sectionMap.computeIfAbsent(sectionPos, key -> new ConcurrentHashMap<>());
             sectionData.put(SectionPos.sectionRelativePos(blockPos), ((CraftBlockData) blockData).getState());
         }
 
-        for (Map.Entry<SectionPos, it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState>> entry : sectionMap.entrySet()) {
+        for (Map.Entry<SectionPos, ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState>> entry : sectionMap.entrySet()) {
             SectionPos sectionPos = entry.getKey();
-            it.unimi.dsi.fastutil.shorts.Short2ObjectMap<net.minecraft.world.level.block.state.BlockState> blockData = entry.getValue();
+            ConcurrentHashMap<Short, net.minecraft.world.level.block.state.BlockState> blockData = entry.getValue();
 
             net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket packet = new net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket(sectionPos, blockData);
             this.getHandle().connection.send(packet);
@@ -1077,10 +1079,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.sendBlockChanges(blocks);
     }
 
-    private record ChunkSectionChanges(ShortSet positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
+    private record ChunkSectionChanges(ConcurrentLinkedQueue<Short> positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
 
         public ChunkSectionChanges() {
-            this(new ShortArraySet(), new ArrayList<>());
+            this(new ConcurrentLinkedQueue(), new ArrayList<>());
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 1f22e7cf584bf7361f3ca078b9935a096d1acba6..dc7ab078c16960e5a1c56a9e078343540bab3037 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -12,6 +12,9 @@ import java.util.Collections;
 import java.util.EnumMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -409,6 +412,7 @@ public class CraftEventFactory {
 
         boolean canBuild = true;
         for (int i = 0; i < blockStates.size(); i++) {
+            if (blockStates.get(i) == null) continue; // Canvas - skip instance if null/AIR - NPE
             if (!CraftEventFactory.canBuild(world, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
                 canBuild = false;
                 break;
@@ -462,7 +466,7 @@ public class CraftEventFactory {
 
     public static void handleBlockDropItemEvent(Block block, BlockState state, ServerPlayer player, List<ItemEntity> items) {
         // Paper start - Allow adding items to BlockDropItemEvent
-        List<Item> list = new ArrayList<>();
+        List<Item> list = new CopyOnWriteArrayList<>(); // Canvas start - CME
         for (ItemEntity item : items) {
             list.add((Item) item.getBukkitEntity());
         }
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 4dbb109d0526afee99b9190fc256585121aac9b5..b75d0c89a9293083a1a840d10cb213174ec09e29 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -141,7 +141,7 @@ public class SpigotConfig
         return SpigotConfig.config.getBoolean( path, SpigotConfig.config.getBoolean( path ) );
     }
 
-    private static int getInt(String path, int def)
+    public static int getInt(String path, int def) // Canvas
     {
         SpigotConfig.config.addDefault( path, def );
         return SpigotConfig.config.getInt( path, SpigotConfig.config.getInt( path ) );
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 7ee650f6bd941a95248945405be6bd7b8e49b76e..ad4a31b5214896579728f36f54b134090401ae10 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -6,6 +6,8 @@ import java.lang.management.ThreadInfo;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+
 import org.bukkit.Bukkit;
 
 public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThread // Paper - rewrite chunk system
@@ -134,17 +136,33 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
             WatchdogThread.instance.stopping = true;
         }
     }
+    private static final long TIME_THRESHOLD = 45_000_000_000L; // Canvas
 
     @Override
     public void run()
     {
         while ( !this.stopping )
         {
-            //
             // Paper start
             Logger log = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
             MinecraftServer server = MinecraftServer.getServer();
+            // Canvas start
+            long curTime = System.nanoTime();
+            server.getAllLevels().forEach(level -> {
+                long elapsedTime = curTime - level.currentTime;
+
+                    if (elapsedTime >= TIME_THRESHOLD && level.running) {
+                        log.log(Level.SEVERE, "------------------------------");
+                        log.log(Level.SEVERE, "Well it seems something went wrong! A ServerLevel is crashing, wonderful.");
+                        for (final StackTraceElement stackTraceElement : level.getStackTrace()) {
+                            log.log(Level.SEVERE, "\t\t" + stackTraceElement.toString());
+                        }
+                        dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( level.getId(), Integer.MAX_VALUE ), log );
+                        log.log(Level.SEVERE, "------------------------------");
+                    }
+            });
+            // Canvas end
             if ( this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG) )) // Paper - add property to disable
             {
                 boolean isLongTimeout = currentTime > lastTick + timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > lastTick + 1000);
@@ -263,7 +281,7 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
             }
         }
         log.log( Level.SEVERE, "\tStack:" );
-        //
+
         for ( StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace()) ) // Paper
         {
             log.log( Level.SEVERE, "\t\t" + stack );
