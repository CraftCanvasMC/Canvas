From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Tue, 30 Apr 2024 20:04:22 -0700
Subject: [PATCH] Entity Goal Optimizations


diff --git a/src/main/java/me/dueris/canvas/CanvasConfig.java b/src/main/java/me/dueris/canvas/CanvasConfig.java
index a7804cccf8a8c46b7818be6df48a5d803a040825..66b6e324960db19645f9063f4d37492223b8e4b0 100644
--- a/src/main/java/me/dueris/canvas/CanvasConfig.java
+++ b/src/main/java/me/dueris/canvas/CanvasConfig.java
@@ -179,6 +179,16 @@ public class CanvasConfig {
     public static int asyncPathfindingKeepalive;
     public static int maxTickerThreads = 3;
     public static boolean autoStartSpark = true;
+    public static boolean playerProximityRateReducer = true;
+    public static int playerProximityRateReducerScanRate = 40;
+    public static int zombieVillageRaidChance = 33;
+    public static boolean optimizeZombieVillageRaids = true;
+    public static int playerProximityRateReducerCutoff = 12;
+    public static int mobEnemyTargetingReducedRatePercentChance = 10;
+    public static boolean optimizeMobWandering = true;
+    public static int mobWanderingPercentChance = 100;
+    public static int mobWanderingReducedRateMultiplier = 6;
+    public static int mobWanderingDelay = 20 * 5;
 
     private static void optimizations(){
         maxTickerThreads = getInt("optimizations.maxTickerThreads", maxTickerThreads);
@@ -194,6 +204,16 @@ public class CanvasConfig {
             asyncPathfindingMaxThreads = 0;
         else
             Bukkit.getLogger().log(Level.INFO, "Using " + asyncPathfindingMaxThreads + " threads for Async Pathfinding");
+        zombieVillageRaidChance = getInt("optimizations.zombieVillageRaidChange", zombieVillageRaidChance);
+        optimizeZombieVillageRaids = getBoolean("optimizations.optimizeZombieVillageRaids", optimizeZombieVillageRaids);
+        playerProximityRateReducer = getBoolean("optimizations.entity.usePlayerProximityRateReducer", playerProximityRateReducer);
+        playerProximityRateReducerScanRate = getInt("optimizations.entity.playerProximityRateReducerScanRate", playerProximityRateReducerScanRate);
+        playerProximityRateReducerCutoff = getInt("optimizations.entity.playerProximityRateReducerCutoff", playerProximityRateReducerCutoff);
+        mobEnemyTargetingReducedRatePercentChance = getInt("optimizations.entity.mobEnemyTargetingReducedRatePercentChance", mobEnemyTargetingReducedRatePercentChance);
+        optimizeMobWandering = getBoolean("optimizations.optimizeMobWandering", optimizeMobWandering);
+        mobWanderingDelay = getInt("optimizations.mobWanderingDelay", mobWanderingDelay);
+        mobWanderingPercentChance = getInt("optimizations.mobWanderingPercentChance", mobWanderingPercentChance);
+        mobWanderingReducedRateMultiplier = getInt("optimizations.mobWanderingReducedRateMultiplier", mobWanderingReducedRateMultiplier);
     }
     
     private static void blocks(){
diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index 0bd367235f80c1f0d319a6aa5130d82ad82d895c..501d951fd04ff3c23465bb844e7e9833042dca5c 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -573,6 +573,13 @@ public class Util {
     public static <T> Optional<T> getRandomSafe(List<T> list, RandomSource random) {
         return list.isEmpty() ? Optional.empty() : Optional.of(getRandom(list, random));
     }
+    // Canvas start
+
+    public static boolean rollPercentChance(float perc){
+        if(perc == 0) return false;
+        return new java.util.Random().nextFloat() <= (perc/100f);
+    }
+    // Canvas end
 
     private static BooleanSupplier createRenamer(Path src, Path dest) {
         return new BooleanSupplier() {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 4c9258b824bf0adf0bf779a6004ccbc857292c3a..0d2372d7060f48b47552b406f6f4303ae1426052 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -428,6 +428,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean freezeLocked = false; // Paper - Freeze Tick Lock API
     public boolean fixedPose = false; // Paper - Expand Pose API
     public @Nullable Boolean immuneToFire = null; // Purpur - Fire immune API
+    // Canvas start - optimize entity goals
+    private long lastWanderTime;
+    private long lastPlayerScanTime;
+    private boolean playerInRange;
+    // Canvas end
 
     public void setOrigin(@javax.annotation.Nonnull Location location) {
         this.origin = location.toVector();
@@ -689,6 +694,32 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public void setId(int id) {
         this.id = id;
     }
+    // Canvas start - optimize entity goals
+
+    public long getLastWanderTime(){
+        return this.lastWanderTime;
+    }
+
+    public void setLastWanderTime(long wanderTime){
+        this.lastWanderTime = wanderTime;
+    }
+
+    public long getLastPlayerScanTime(){
+        return this.lastPlayerScanTime;
+    }
+
+    public void setLastPlayerScanTime(long scanTime){
+        this.lastPlayerScanTime = scanTime;
+    }
+
+    public boolean isPlayerInRange(){
+        return this.playerInRange;
+    }
+
+    public void setPlayerInRange(boolean inRange){
+        this.playerInRange = inRange;
+    }
+    // Canvas end
 
     public Set<String> getTags() {
         return this.tags;
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/MoveThroughVillageGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/MoveThroughVillageGoal.java
index 708dce6a2a951c6ffb780a02146361b18a6aecf2..69f46a5c1640c3d219b83cfcc81290bc634e8bcf 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/MoveThroughVillageGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/MoveThroughVillageGoal.java
@@ -43,9 +43,23 @@ public class MoveThroughVillageGoal extends Goal {
             throw new IllegalArgumentException("Unsupported mob for MoveThroughVillageGoal");
         }
     }
+    // Canvas start
+
+    public boolean canVillageRaid(){
+        if(me.dueris.canvas.CanvasConfig.optimizeZombieVillageRaids){
+            return net.minecraft.Util.rollPercentChance(me.dueris.canvas.CanvasConfig.zombieVillageRaidChance);
+        }
+        return true;
+    }
+    // Canvas end
 
     @Override
     public boolean canUse() {
+        // Canvas start
+        if(!this.canVillageRaid()){
+            return false;
+        }
+        // Canvas end
         if (!GoalUtils.hasGroundPathNavigation(this.mob)) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
index 676e1580849e8942eb41c7a3a80f464138b22764..128d7423b4bca1e121e26f5fc968a4f82462e227 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
@@ -32,9 +32,55 @@ public class RandomStrollGoal extends Goal {
         this.checkNoActionTime = canDespawn;
         this.setFlags(EnumSet.of(Goal.Flag.MOVE));
     }
+    // Canvas start - optimize entity goals
+
+    public boolean canWander(PathfinderMob mob){
+        if(me.dueris.canvas.CanvasConfig.optimizeMobWandering){
+            if(net.minecraft.Util.rollPercentChance(me.dueris.canvas.CanvasConfig.mobWanderingPercentChance)) return false;
+
+            boolean useReducedRates = false;
+            if(me.dueris.canvas.CanvasConfig.playerProximityRateReducer){
+                long lastPlayerScan = this.mob.getLastPlayerScanTime();
+                if(lastPlayerScan + me.dueris.canvas.CanvasConfig.playerProximityRateReducerScanRate > this.mob.level().getGameTime()){
+                    useReducedRates = this.mob.isPlayerInRange();
+                } else {
+                    boolean playerInRangeBool = false;
+                    for(net.minecraft.world.entity.player.Player player : this.mob.level().players()){
+                        if(player.distanceToSqr(this.mob) < me.dueris.canvas.CanvasConfig.playerProximityRateReducerCutoff * me.dueris.canvas.CanvasConfig.playerProximityRateReducerCutoff){
+                            playerInRangeBool = true;
+                            break;
+                        }
+                    }
+
+                    if(playerInRangeBool){
+                        this.mob.setPlayerInRange(playerInRangeBool);
+                        this.mob.setLastPlayerScanTime(this.mob.level().getGameTime());
+                        useReducedRates = !playerInRangeBool;
+                    }
+                }
+            }
+
+            float multiplier = useReducedRates ? me.dueris.canvas.CanvasConfig.mobWanderingReducedRateMultiplier : 1;
+            long lastWander = this.mob.getLastWanderTime();
+
+            if(lastWander + me.dueris.canvas.CanvasConfig.mobWanderingDelay * multiplier > this.mob.level().getGameTime()){
+                return false;
+            }else{
+                this.mob.setLastWanderTime(mob.level().getGameTime());
+            }
+            return true;
+        }
+        return true;
+    }
+    // Canvas end
 
     @Override
     public boolean canUse() {
+        // Canvas start - optimize entity goals
+        if(!this.canWander(this.mob)){
+            return false;
+        }
+        // Canvas end
         if (this.mob.hasControllingPassenger()) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
index 175ba1184fc997f562f0834b172e17dc1b5b3027..3e15931315cdaeb3ac4306c3845fab269e70a579 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
@@ -40,9 +40,45 @@ public class NearestAttackableTargetGoal<T extends LivingEntity> extends TargetG
         this.targetConditions = TargetingConditions.forCombat().range(this.getFollowDistance()).selector(targetPredicate);
         if (mob.level().paperConfig().entities.entitiesTargetWithFollowRange) this.targetConditions.useFollowRange(); // Paper - Fix MC-145656
     }
+    // Canvas start
+
+    public boolean canTarget(Mob mob){
+        boolean useReducedRates = false;
+        if(me.dueris.canvas.CanvasConfig.playerProximityRateReducer){
+            long lastPlayerScan = this.mob.getLastPlayerScanTime();
+            if(lastPlayerScan + me.dueris.canvas.CanvasConfig.playerProximityRateReducerScanRate > this.mob.level().getGameTime()){
+                useReducedRates = this.mob.isPlayerInRange();
+            } else {
+                boolean playerInRangeBool = false;
+                for(net.minecraft.world.entity.player.Player player : this.mob.level().players()){
+                    if(player.distanceToSqr(this.mob) < me.dueris.canvas.CanvasConfig.playerProximityRateReducerCutoff * me.dueris.canvas.CanvasConfig.playerProximityRateReducerCutoff){
+                        playerInRangeBool = true;
+                        break;
+                    }
+                }
+
+                if(playerInRangeBool){
+                    this.mob.setPlayerInRange(playerInRangeBool);
+                    this.mob.setLastPlayerScanTime(this.mob.level().getGameTime());
+                    useReducedRates = !playerInRangeBool;
+                }
+            }
+        }
+
+        if(useReducedRates){
+            return net.minecraft.Util.rollPercentChance(me.dueris.canvas.CanvasConfig.mobEnemyTargetingReducedRatePercentChance);
+        }
+        return true;
+    }
+    // Canvas end
 
     @Override
     public boolean canUse() {
+        // Canvas start - optimize entity goals
+        if(!this.canTarget(this.mob)){
+            return false;
+        }
+        // Canvas end
         if (this.randomInterval > 0 && this.mob.getRandom().nextInt(this.randomInterval) != 0) {
             return false;
         } else {
